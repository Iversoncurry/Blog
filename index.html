<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Blog/css/main.css">


<link rel="stylesheet" href="/Blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gitee.com","root":"/Blog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="蚂蚁的博客">
<meta property="og:url" content="https://gitee.com/iversoncurry/Blog.git/index.html">
<meta property="og:site_name" content="蚂蚁的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="蚂蚁">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://gitee.com/iversoncurry/Blog.git/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>蚂蚁的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">蚂蚁的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/Blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/05/02/%E6%AD%A3%E5%88%99%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/05/02/%E6%AD%A3%E5%88%99%E5%8C%96/" class="post-title-link" itemprop="url">正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-02 20:28:47" itemprop="dateCreated datePublished" datetime="2020-05-02T20:28:47+08:00">2020-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-04 22:33:26" itemprop="dateModified" datetime="2020-05-04T22:33:26+08:00">2020-05-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><p>ECMAScript通过RegExp类型来支持正则表达式。<br>使用如下语法，就可以创建一个正则表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/pattern/</span>flags</span><br></pre></td></tr></table></figure>
<p>其中的pattern(模式)部分可以是任何简单或复杂的正则表达式，可以包含字符类，限定符，分组，向前查找以及反向引用。每个正则表达式都可以带有一个或多个标签（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列三个标志。<br>g：表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止<br>i：表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写<br>m：表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。<br>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：<br>( [{^$|?*+.}])<br>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对他们进行转义</p>
<p>前面举的例子是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量表达形式</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/[bc]at/i</span></span><br><span class="line"><span class="comment">// 使用构造函数形式</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'[bc]at'</span>, <span class="string">'i'</span>)</span><br></pre></td></tr></table></figure>
<p><em>由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符串进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此。例如，\n要写成\n,\要写成\\。</em></p>
<h3 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h3><p>RegExp的每个实例都具有如下属性，通过这些属性可以取得有关模式的各种信息。<br>global：布尔值，表示是否设置了g标志<br>ignorecase：布尔值，表示是否设置了i标志<br>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起<br>multiline：布尔值，表示是否设置了m标志<br>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</p>
<h3 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h3><p>RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接收一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。其中，index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项时与模式中的补货组匹配的字符串，其他项时与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'mom and dad and baby'</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = pattern.exec(text)</span><br><span class="line">alert(matches.index)      <span class="comment">//0</span></span><br><span class="line">alert(matches.input)     <span class="comment">//'mom and dad and baby'</span></span><br><span class="line">alert(matches[<span class="number">0</span>])        <span class="comment">//'mom and dad and baby'</span></span><br><span class="line">alert(matches[<span class="number">1</span>])        <span class="comment">//' and dad and baby</span></span><br><span class="line">alert(matches[<span class="number">2</span>])        <span class="comment">//' and baby'</span></span><br></pre></td></tr></table></figure>
<p>对于exec()方法而言，<strong>即使在模式中设定了全局标志(g)</strong>，它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'cat, bat, sat, fat'</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/.at/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = pattern1.exec(text)</span><br><span class="line">alert(matches.index)   <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>])      <span class="comment">//cat</span></span><br><span class="line">alert(pattern1.lastIndex)  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">matches = pattern1.exec(text)</span><br><span class="line">alert(matches.index)   <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>])      <span class="comment">//cat</span></span><br><span class="line">alert(pattern1.lastIndex)  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/.at/g</span></span><br><span class="line"><span class="keyword">var</span> matches = pattern2.exec(text)</span><br><span class="line">alert(matches.index)   <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>])      <span class="comment">//cat</span></span><br><span class="line">alert(pattern1.lastIndex)  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">matches = pattern2.exec(text)</span><br><span class="line">alert(matches.index)   <span class="comment">//5</span></span><br><span class="line">alert(matches[<span class="number">0</span>])      <span class="comment">//bat</span></span><br><span class="line">alert(pattern1.lastIndex)  <span class="comment">//8</span></span><br></pre></td></tr></table></figure>

<p>正则表达式的第二个方法是test()，它接受一个字符串参数。在末世与改参数匹配的情况下返回true；否则返回false。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/05/02/%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/05/02/%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">订阅发布模式和观察者模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-02 20:27:08" itemprop="dateCreated datePublished" datetime="2020-05-02T20:27:08+08:00">2020-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-04 13:49:38" itemprop="dateModified" datetime="2020-05-04T13:49:38+08:00">2020-05-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h2><p>订阅发布模式由三部分组成，订阅者（Subscriber），发布者（Publisher），调度中心（Topic）。</p>
<p><strong>发布订阅模式</strong>： 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//定义一家猎人工会</span></span><br><span class="line"><span class="comment">//主要功能包括任务发布大厅(topics)，以及订阅任务(subscribe)，发布任务(publish)</span></span><br><span class="line"><span class="keyword">let</span> HunterUnion = &#123;</span><br><span class="line">	type: <span class="string">'hunt'</span>,</span><br><span class="line">	topics: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">	subscribe: <span class="function"><span class="keyword">function</span> (<span class="params">topic, fn</span>)</span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(!<span class="keyword">this</span>.topics[topic])&#123;</span><br><span class="line">	      	<span class="keyword">this</span>.topics[topic] = [];  </span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">this</span>.topics[topic].push(fn);</span><br><span class="line">	&#125;,</span><br><span class="line">	publish: <span class="function"><span class="keyword">function</span> (<span class="params">topic, money</span>)</span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(!<span class="keyword">this</span>.topics[topic])</span><br><span class="line">	      	<span class="keyword">return</span>;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">let</span> fn <span class="keyword">of</span> <span class="keyword">this</span>.topics[topic])&#123;</span><br><span class="line">	    	fn(money)</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个猎人类</span></span><br><span class="line"><span class="comment">//包括姓名，级别</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hunter</span>(<span class="params">name, level</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name</span><br><span class="line">	<span class="keyword">this</span>.level = level</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//猎人可在猎人工会发布订阅任务</span></span><br><span class="line">Hunter.prototype.subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">topic, fn</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.level + <span class="string">'猎人'</span> + <span class="keyword">this</span>.name + <span class="string">'订阅了狩猎'</span> + topic + <span class="string">'的任务'</span>)</span><br><span class="line">    HunterUnion.subscribe(topic, fn)</span><br><span class="line">&#125;</span><br><span class="line">Hunter.prototype.publish = <span class="function"><span class="keyword">function</span> (<span class="params">topic, money</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.level + <span class="string">'猎人'</span> + <span class="keyword">this</span>.name + <span class="string">'发布了狩猎'</span> + topic + <span class="string">'的任务'</span>)</span><br><span class="line">    HunterUnion.publish(topic, money)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//猎人工会走来了几个猎人</span></span><br><span class="line"><span class="keyword">let</span> hunterMing = <span class="keyword">new</span> Hunter(<span class="string">'小明'</span>, <span class="string">'黄金'</span>)</span><br><span class="line"><span class="keyword">let</span> hunterJin = <span class="keyword">new</span> Hunter(<span class="string">'小金'</span>, <span class="string">'白银'</span>)</span><br><span class="line"><span class="keyword">let</span> hunterZhang = <span class="keyword">new</span> Hunter(<span class="string">'小张'</span>, <span class="string">'黄金'</span>)</span><br><span class="line"><span class="keyword">let</span> hunterPeter = <span class="keyword">new</span> Hunter(<span class="string">'Peter'</span>, <span class="string">'青铜'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//小明，小金，小张分别订阅了狩猎tiger的任务</span></span><br><span class="line">hunterMing.subscribe(<span class="string">'tiger'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">money</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'小明表示：'</span> + (money &gt; <span class="number">200</span> ? <span class="string">''</span> : <span class="string">'不'</span>) + <span class="string">'接取任务'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hunterJin.subscribe(<span class="string">'tiger'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">money</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'小金表示：接取任务'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">hunterZhang.subscribe(<span class="string">'tiger'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">money</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'小张表示：接取任务'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//Peter订阅了狩猎sheep的任务</span></span><br><span class="line">hunterPeter.subscribe(<span class="string">'sheep'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">money</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'Peter表示：接取任务'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Peter发布了狩猎tiger的任务</span></span><br><span class="line">hunterPeter.publish(<span class="string">'tiger'</span>, <span class="number">198</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//猎人们发布(发布者)或订阅(观察者/订阅者)任务都是通过猎人工会(调度中心)关联起来的，他们没有直接的交流。</span></span><br></pre></td></tr></table></figure>

<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式由两部分组成，观察者（Observer），主题（Subject）</p>
<p><strong>观察者模式</strong>： 观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有一家猎人工会，其中每个猎人都具有发布任务(publish)，订阅任务(subscribe)的功能</span></span><br><span class="line">	<span class="comment">//他们都有一个订阅列表来记录谁订阅了自己</span></span><br><span class="line">	<span class="comment">//定义一个猎人类</span></span><br><span class="line">	<span class="comment">//包括姓名，级别，订阅列表</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Hunter</span>(<span class="params">name, level</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name</span><br><span class="line">		<span class="keyword">this</span>.level = level</span><br><span class="line">		<span class="keyword">this</span>.list = []</span><br><span class="line">	&#125;</span><br><span class="line">	Hunter.prototype.publish = <span class="function"><span class="keyword">function</span> (<span class="params">money</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.level + <span class="string">'猎人'</span> + <span class="keyword">this</span>.name + <span class="string">'寻求帮助'</span>)</span><br><span class="line">	    <span class="keyword">this</span>.list.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>)</span>&#123;</span><br><span class="line">	    	item(money)</span><br><span class="line">	    &#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	Hunter.prototype.subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">targrt, fn</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.level + <span class="string">'猎人'</span> + <span class="keyword">this</span>.name + <span class="string">'订阅了'</span> + targrt.name)</span><br><span class="line">	    targrt.list.push(fn)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//猎人工会走来了几个猎人</span></span><br><span class="line">	<span class="keyword">let</span> hunterMing = <span class="keyword">new</span> Hunter(<span class="string">'小明'</span>, <span class="string">'黄金'</span>)</span><br><span class="line">	<span class="keyword">let</span> hunterJin = <span class="keyword">new</span> Hunter(<span class="string">'小金'</span>, <span class="string">'白银'</span>)</span><br><span class="line">	<span class="keyword">let</span> hunterZhang = <span class="keyword">new</span> Hunter(<span class="string">'小张'</span>, <span class="string">'黄金'</span>)</span><br><span class="line">	<span class="keyword">let</span> hunterPeter = <span class="keyword">new</span> Hunter(<span class="string">'Peter'</span>, <span class="string">'青铜'</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Peter等级较低，可能需要帮助，所以小明，小金，小张都订阅了Peter</span></span><br><span class="line">	hunterMing.subscribe(hunterPeter, <span class="function"><span class="keyword">function</span>(<span class="params">money</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'小明表示：'</span> + (money &gt; <span class="number">200</span> ? <span class="string">''</span> : <span class="string">'暂时很忙，不能'</span>) + <span class="string">'给予帮助'</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	hunterJin.subscribe(hunterPeter, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'小金表示：给予帮助'</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	hunterZhang.subscribe(hunterPeter, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'小金表示：给予帮助'</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Peter遇到困难，赏金198寻求帮助</span></span><br><span class="line">	hunterPeter.publish(<span class="number">198</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//猎人们(观察者)关联他们感兴趣的猎人(目标对象)，如Peter，当Peter有困难时，会自动通知给他们（观察者）</span></span><br></pre></td></tr></table></figure>

<p><strong>我的理解</strong><br>观察者模式需要在subject中维护一个Objecter的列表，同时，在Subject出现变化时需要触发相应的Objecter函数</p>
<p>订阅发布模式Publisher只需要发布事件给中间消息队列，订阅信息以及更新后的事件触发都交由中间消息队列完成。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/29/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/29/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">拓扑排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 23:03:08" itemprop="dateCreated datePublished" datetime="2020-04-29T23:03:08+08:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-30 11:16:19" itemprop="dateModified" datetime="2020-04-30T11:16:19+08:00">2020-04-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>拓扑排序的实现方法之一就是找到图中入度为零的节点，然后删除该节点一节和该节点有联系的边,具体实现需要根据图的表示形式改变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">val, node</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.val = val</span><br><span class="line">	<span class="keyword">this</span>.next = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gra = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">	gra.push(<span class="keyword">new</span> Node(i, <span class="literal">null</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gra[<span class="number">0</span>].next = <span class="literal">null</span></span><br><span class="line">gra[<span class="number">1</span>].next = <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="literal">null</span>)</span><br><span class="line">gra[<span class="number">2</span>].next = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="keyword">new</span> Node(<span class="number">4</span>, <span class="keyword">new</span> Node(<span class="number">5</span>, <span class="literal">null</span>)))</span><br><span class="line">gra[<span class="number">3</span>].next = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="literal">null</span>)</span><br><span class="line">gra[<span class="number">4</span>].next = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="literal">null</span>)</span><br><span class="line">gra[<span class="number">5</span>].next = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tuopu</span>(<span class="params">gra</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// let sourceNode = new Set()</span></span><br><span class="line">	<span class="keyword">let</span> targetNode = []</span><br><span class="line">	<span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">	<span class="keyword">let</span> tuopu = []</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> gra) &#123;</span><br><span class="line">		<span class="keyword">let</span> neighbors = item.next</span><br><span class="line">		<span class="keyword">while</span>(neighbors !==<span class="literal">null</span>) &#123;</span><br><span class="line">			targetNode.push(neighbors.val)</span><br><span class="line">			neighbors = neighbors.next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(gra.length !==<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// console.log(gra.length)</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; gra.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (targetNode.indexOf(gra[i].val) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">let</span> neighbors_i = gra[i].next</span><br><span class="line">				<span class="keyword">while</span>(neighbors_i !== <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						targetNode.splice(targetNode.indexOf(neighbors_i.val), <span class="number">1</span>)</span><br><span class="line">					&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">						<span class="built_in">console</span>.log(<span class="string">'neighbor has no inNode as same'</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">console</span>.log(neighbors_i.val)</span><br><span class="line"></span><br><span class="line">					neighbors_i = neighbors_i.next</span><br><span class="line">									&#125;</span><br><span class="line">				tuopu.push(gra[i].val)</span><br><span class="line">				gra.splice(i, <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">console</span>.log(targetNode)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// console.log(gra[i].val)</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tuopu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tuopu(gra))</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/28/BFC%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/28/BFC%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">'BFC理解'</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-28 21:30:52" itemprop="dateCreated datePublished" datetime="2020-04-28T21:30:52+08:00">2020-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-29 15:31:33" itemprop="dateModified" datetime="2020-04-29T15:31:33+08:00">2020-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>BFC是Web页面 CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。</p>
<p>下列方式会创建块格式化上下文：</p>
<p>根元素(<html>)<br>浮动元素（元素的 float 不是 none）<br>绝对定位元素（元素的 position 为 absolute 或 fixed）<br>行内块元素（元素的 display 为 inline-block）<br>表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）<br>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）<br>匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）<br>overflow 值不为 visible 的块元素<br>display 值为 flow-root 的元素<br>contain 值为 layout、content或 paint 的元素<br>弹性元素（display为 flex 或 inline-flex元素的直接子元素）<br>网格元素（display为 grid 或 inline-grid 元素的直接子元素）<br>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）<br>column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。<br>块格式化上下文包含创建它的元素内部的所有内容.</p>
<p>块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。</p>
<p><strong>浏览器对BFC区域的约束规则：</strong></p>
<p>生成BFC元素的子元素会一个接一个的放置。<br>垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的margin特性。在BFC中相邻的块级元素的外边距会折叠(Mastering margin collapsing)。<br>生成BFC元素的子元素中，每一个子元素左外边距与包含块的左边界相接触（对于从右到左的格式化，右外边距接触右边界），即使浮动元素也是如此（尽管子元素的内容区域会由于浮动而压缩），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。</p>
<p><strong>规则解读：</strong></p>
<p>内部的Box会在垂直方向上一个接一个的放置<br>内部的Box垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠。）<br>每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）<br>BFC的区域不会与float的元素区域重叠<br>计算BFC的高度时，浮动子元素也参与计算</p>
<p>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。我们可以利用BFC的这个特性来做很多事。</p>
<p><strong>阻止元素被浮动元素覆盖</strong><br>一个正常文档流的block元素可能被一个float元素覆盖，挤占正常文档流，因此可以设置一个元素的float、display、position值等方式触发BFC，以阻止被浮动盒子覆盖。</p>
<p><strong>可以包含浮动元素</strong><br>通过改变包含浮动子元素的父盒子的属性值，触发BFC，以此来包含子元素的浮动盒子。</p>
<p><strong>阻止因为浏览器因为四舍五入造成的多列布局换行的情况</strong><br>有时候因为多列布局采用小数点位的width导致因为浏览器因为四舍五入造成的换行的情况，可以在最后一列触发BFC的形式来阻止换行的发生。比如下面栗子的特殊情况</p>
<p><strong>阻止相邻元素的margin合并</strong><br>属于同一个BFC的两个相邻块级子元素的上下margin会发生重叠，(设置writing-mode:tb-rl时，水平margin会发生重叠)。所以当两个相邻块级子元素分属于不同的BFC时可以阻止margin重叠。<br>这里给任一个相邻块级盒子的外面包一个div，通过改变此div的属性使两个原盒子分属于两个不同的BFC，以此来阻止margin重叠。</p>
<p><strong>注意</strong>：display:table也可以生成BFC的原因在于Table会默认生成一个匿名的table-cell，是这个匿名的table-cell生成了BFC。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/27/display%E3%80%81contain%E3%80%81overflow%E5%B1%9E%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/27/display%E3%80%81contain%E3%80%81overflow%E5%B1%9E%E6%80%A7/" class="post-title-link" itemprop="url">display属性 contain属性 overflow属性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-27 23:18:39" itemprop="dateCreated datePublished" datetime="2020-04-27T23:18:39+08:00">2020-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-28 22:20:01" itemprop="dateModified" datetime="2020-04-28T22:20:01+08:00">2020-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h1><p>display 属性可以设置元素的内部和外部显示类型 display types。元素的外部显示类型 outer display types 将决定该元素在流式布局中的表现（块级或内联元素）；元素的内部显示类型 inner display types 可以控制其子元素的布局（例如：flow layout，grid 或 flex）。</p>
<p>display 属性使用关键字取值来指定，关键字取值被分为六类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;display-outside&gt; || &lt;display-inside&gt; ] | &lt;display-listitem&gt; | &lt;display-internal&gt; | &lt;display-box&gt; | &lt;display-legacy&gt;</span><br><span class="line">where </span><br><span class="line">&lt;display-outside&gt; = block | inline | run-in</span><br><span class="line">&lt;display-inside&gt; = flow | flow-root | table | flex | grid | ruby</span><br><span class="line">&lt;display-listitem&gt; = &lt;display-outside&gt;? &amp;&amp; [ flow | flow-root ]? &amp;&amp; list-item</span><br><span class="line">&lt;display-internal&gt; = table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container</span><br><span class="line">&lt;display-box&gt; = contents | none</span><br><span class="line">&lt;display-legacy&gt; = inline-block | inline-list-item | inline-table | inline-flex | inline-grid</span><br></pre></td></tr></table></figure>

<p><strong>Outside</strong><br><display-outside><br>这些关键字指定了元素的外部显示类型，实际上就是其在流式布局中的角色（即在流式布局中的表现），（块元素行内元素）。</p>
<p><strong>Inside</strong><br><display-inside> (flex)<br>这些关键字指定了元素的内部显示类型，它们定义了该元素内部内容的布局方式（假定该元素为非替换元素 non-replaced element）。</p>
<h1 id="contain属性"><a href="#contain属性" class="headerlink" title="contain属性"></a>contain属性</h1><p>contain 属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。这使得浏览器在重新计算布局、样式、绘图或它们的组合的时候，只会影响到有限的 DOM 区域，而不是整个页面。</p>
<h2 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h2><p>none<br>声明元素正常渲染，没有包含规则。<br>strict<br>声明所有的包含规则应用于这个元素。这样写等价于 contain: size layout style paint。<br>content<br>声明这个元素上有除了 size 外的所有包含规则。等价于 contain: layout style paint。<br>size<br>声明这个元素的尺寸计算不依赖于它的子孙元素的尺寸。<br>layout<br>声明没有外部元素可以影响它内部的布局，反之亦然。<br>style<br>声明那些同时会影响这个元素和其子孙元素的属性，都在这个元素的包含范围内。<br>paint<br>声明这个元素的子孙节点不会在它边缘外显示。如果一个元素在视窗外或因其他原因导致不可见，则同样保证它的子孙节点不会被显示。</p>
<h1 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h1><p>CSS属性 overflow 定义当一个元素的内容太大而无法适应 块级格式化上下文 时候该做什么。它是 overflow-x 和overflow-y的 简写属性 。</p>
<h2 id="属性值-1"><a href="#属性值-1" class="headerlink" title="属性值"></a>属性值</h2><p>visible<br>默认值。内容不会被修剪，可以呈现在元素框之外。<br>hidden<br>如果需要，内容将被剪裁以适合填充框。 不提供滚动条。<br>scroll<br>如果需要，内容将被剪裁以适合填充框。 浏览器显示滚动条，无论是否实际剪切了任何内容。 （这可以防止滚动条在内容更改时出现或消失。）打印机仍可能打印溢出的内容。<br>auto<br>取决于用户代理。 如果内容适合填充框内部，则它看起来与可见内容相同，但仍会建立新的块格式化上下文。 如果内容溢出，桌面浏览器会提供滚动条。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">前端路由实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 15:55:55 / Modified: 18:00:39" itemprop="dateCreated datePublished" datetime="2020-04-26T15:55:55+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>路由的概念来源于服务端，在服务端中路由描述的是URL与处理函数之间的映射关系。<br>在Web前端单页应用中，路由描述的是URL与UI之间的映射关系，这种映射是单向的，即URL变化引起UI更新（<strong>无需刷新页面</strong>）</p>
<h2 id="实现前端路由的基本原理"><a href="#实现前端路由的基本原理" class="headerlink" title="实现前端路由的基本原理"></a>实现前端路由的基本原理</h2><p>要实现前端路由，需要解决两个核心问题<br>1.改变URL不引起页面刷新<br>2.检测URL变化</p>
<p>利用hash或history可以解决这两个问题</p>
<h3 id="hash实现"><a href="#hash实现" class="headerlink" title="hash实现"></a>hash实现</h3><p>1.hash是URL中hash (#)及后面的那部分，常用作锚点在页面内进行导航，改变URL中的hash部分不会引起页面刷新<br>2.通过hashchange事件监听URL的变化。<br>浏览器前进或后退改变URL、通过标签改变URL、通过window.location改变URL，这几种情况都会触发hashchange事件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义路由 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/home"</span>&gt;</span>home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/about"</span>&gt;</span>about<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 渲染路由对应的 UI --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"routeView"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, onLoad)</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 监听路由变化</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, onHashChange)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 路由视图</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> routerView = <span class="literal">null</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">onLoad</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    routerView = <span class="built_in">document</span>.querySelector(<span class="string">'#routeView'</span>)</span></span><br><span class="line">    onHashChange()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="history实现"><a href="#history实现" class="headerlink" title="history实现"></a>history实现</h3><p>1.history提供了pushState和replaceState两个方法，这两个方法改变URL的path部分不会引起页面刷新<br>2.history提供popstate事件。但通过通过pushState/replaceState或标签改变 URL 不会触发 popstate 事件。但可以拦截pushState/replaceState的调用和标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'/home'</span>&gt;</span>home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'/about'</span>&gt;</span>about<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"routeView"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, onLoad)</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 监听路由变化</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, onPopState)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// 路由视图</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> routerView = <span class="literal">null</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">onLoad</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  routerView = <span class="built_in">document</span>.querySelector(<span class="string">'#routeView'</span>)</span></span><br><span class="line">  onPopState()</span><br><span class="line"></span><br><span class="line"><span class="actionscript"> href=<span class="string">""</span>&gt;  <span class="comment">// 拦截 &lt;a&gt; 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> linkList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'a[href]'</span>)</span></span><br><span class="line"><span class="javascript">  linkList.forEach(<span class="function"><span class="params">el</span> =&gt;</span> el.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line">    e.preventDefault()</span><br><span class="line"><span class="actionscript">    history.pushState(<span class="literal">null</span>, <span class="string">''</span>, el.getAttribute(<span class="string">'href'</span>))</span></span><br><span class="line">    onPopState()</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// 路由变化时，根据路由渲染对应 UI</span></span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">onPopState</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">switch</span> (location.pathname) &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">case</span> <span class="string">'/home'</span>:</span></span><br><span class="line"><span class="actionscript">      routerView.innerHTML = <span class="string">'Home'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">case</span> <span class="string">'/about'</span>:</span></span><br><span class="line"><span class="actionscript">      routerView.innerHTML = <span class="string">'About'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">default</span>:</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">引用类型之数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 11:26:13 / Modified: 11:29:19" itemprop="dateCreated datePublished" datetime="2020-04-26T11:26:13+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>除Object之外，Array类型是ECMAScript中最常用的类型，与其他语言不同，数组中可以保存任何类型的数据；同时数组大小可以随意调整，不同于java，当数组长度确定时不能再进行改变；Array 存储的对象能动态增多和减少，并且可以存储任何JavaScript值。</p>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>1.利用Array构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(args)</span><br></pre></td></tr></table></figure>
<p>其中args可以为空，也可以为一个数值或是字符串，当为数值时，生成一个长度为该数值的数组，当为字符串时，生成一个含有该字符串的数组；其中，new可以省略<br>2.利用数组字面量表示法进行创建</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>]</span><br></pre></td></tr></table></figure>
<p>其中数组中最后一项不要为逗号，如为逗号将产生一个长度不定的数组</p>
<h2 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h2><p>在读取和设置数组的值时，利用方括号并提供相应的数字索引，数字索引是从0开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])</span><br><span class="line">colors[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>通过length属性可以获取数组长度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">23</span>]</span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br></pre></td></tr></table></figure>
<p>对数组的length进行设置时，会改变数组项数，当设置的length大于数组实际长度时，超过的数组位置为undefined，当设置的length小于数组实际长度时，多余的数组会被移除</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">23</span>]</span><br><span class="line">colors.length = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>])</span><br><span class="line">colors.length = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>由此可以利用length属性实现数组的栈方法（构想，还没写😁）</p>
<h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><p>对于同一个网页或者一个全局作用域而言，利用instanceof操作符可以实现数组的检测</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)</span><br></pre></td></tr></table></figure>
<p>但如果网页中包含多个框架，导致存在两个及以上不同全局执行环境，从而导致多个不同版本的Array构造函数，instanceof方法将失效，此时可以利用Array.isArray()方法，该方法是最终确定一个值是否是数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value))</span><br></pre></td></tr></table></figure>

<h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><p>所有对象都有toLocaleString(), toString(), valueOf()方法。其中调用数组的toString()会返回有数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串（调用数组每一项的toString()方法；而调用valueOf()，返回的是数组；toLocaleString()方法调用每一项的toLocaleString()方法，对于alert方法，当其参数为数组时，会先调用数组的toString()方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(color.toString())</span><br><span class="line"><span class="built_in">console</span>.log(color.valueOf())</span><br></pre></td></tr></table></figure>
<p>通过调用数组的join()方法，传入分隔符参数，更改分隔符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(color.join(<span class="string">"||"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p>数组的push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改数组长度；pop()方法从数组末尾移除最后一项，减少数组的length，然后返回移除的项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">var</span> count = color.push(<span class="string">'yellow'</span>, <span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count)</span><br><span class="line">myColor = color.pop()</span><br><span class="line"><span class="built_in">console</span>.log(myColor)</span><br></pre></td></tr></table></figure>

<h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><p>与栈方法相比，队列方法将pop()方法变为shift()方法，该方法移除数组第一项并返回该项，push()方法与栈方法相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">myColor = color.shift()</span><br><span class="line"><span class="built_in">console</span>.log(myColor)</span><br></pre></td></tr></table></figure>

<h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2><p>数组有两个可以直接用来重排序的方法，reverse()和sort()方法。<br>reverse()方法将数组进行倒排</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">values.reverse()</span><br><span class="line"><span class="built_in">console</span>.log(values)</span><br></pre></td></tr></table></figure>
<p>sort()方法默认按升序排列数组，为实现排序，sort()方法会调用每个数组项的toString()方法，然后比较字符串，即使数组里每一项都是数值，sort()方法比较的也是字符串。但有些情况下，通过字符串比较会出现错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>]</span><br><span class="line">values.sort()</span><br><span class="line"><span class="built_in">console</span>.log(values) <span class="comment">//0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
<p>可通过给sort()函数传递一个比较函数作为参数（升序）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>]</span><br><span class="line">values.sort(compare)</span><br><span class="line"><span class="built_in">console</span>.log(values) <span class="comment">//0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
<p>当数组元素为数值类型或其valueOf方法会返回数值类型对象时比较函数可简化为（升序）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value2 - value1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：reverse()和sort()方法都是对原始数组进行修改</p>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。当concat()方法不传入参数时，只是对原数组进行复制并返回副本；当传入参数为一个或多个数组该方法将每个数组的每一项都添加到结果数组中；如果传入的参数不是数组，则值将会被简单添加到结果数组的末尾。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">var</span> color2 = colors.concat(<span class="string">'yellow'</span>, [<span class="string">'black'</span>, <span class="string">'brown'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(color2)</span><br></pre></td></tr></table></figure>
<p>注意concat()方法不改变原始数组。<br>slice()方法能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一个或两个参数，即要返回项的起始和结束位置；若slice()方法只传递一个参数，则返回从该参数指定位置看是到当前数组末尾的所有项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>, <span class="string">'black'</span>, <span class="string">'brown'</span>]</span><br><span class="line"><span class="keyword">var</span> color2 = colors.slice(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> color3 = colors.slice(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(color2)</span><br><span class="line"><span class="built_in">console</span>.log(color3)</span><br></pre></td></tr></table></figure>
<p>注意slice()方法不改变原始数组。<br>splice()方法主要用途时向数组中部插入项：<br>1.删除：可以删除任意数量的的项，需指定2个参数：要删除的第一项的位置和要删除的项数；<br>2.插入：可以向指定位置插入任意数量的项，需提供3个参数：起始位置、0（要删除的项）和要插入的项。最后一个参数可以为任意多项<br>3.替换：可以项指定位置插入任意数量的项，且同时删除任意数量的项，需指定3个参数：其实位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。<br>splice()方法始终返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">var</span> removed = color.splice(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(removed)</span><br><span class="line"></span><br><span class="line">removed = color.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">'yellow'</span>,<span class="string">'orange'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(removed)</span><br><span class="line"></span><br><span class="line">removed = color.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'red'</span>, <span class="string">'purple'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(removed)</span><br></pre></td></tr></table></figure>
<p>splice()方法改变原数组</p>
<h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><p>数组实例有两个位置方法：indexOf()和lastIndexOf()。这两个方法都接收两个参数，要查找的项和表示查找起点位置的索引（可选）。其中，indexOf()方法从起点位置从前向后查找，lastIndexOf()方法从起始点从后向前查找，两个方法返回要查找项在数组中的位置。如果要查找项不在数组中则返回-1.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(number.indexOf(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(number.lastIndexOf(<span class="number">4</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>ECMAScript5为数组定义了5个迭代方法，每个方法接受两个参数：要在每一项上运行的函数和运行该函数的作用域对象—-影响this的值。传入这些方法的函数接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。<br>1.every(): 对数组中的每一项运行给定函数，如果该函数对每一项都返回true则返回true；(当找到不满足条件的项时停止迭代)(不改变原数组)<br>2.filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组；(不改变原数组)<br>3.forEach(): 对数组中的每一项运行给定函数。这个方法没有返回值；本质上与for循环迭代数组一样。 (不改变原数组)<br>4.map(): 对数组中的每一项运行给定函数，返回每次函数调用结果组成的数组；(不改变原数组)<br>5.some(): 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。(当找到满足条件的项时停止迭代) (不改变原数组)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> everyResult = number.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> someResult = number.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> filterResult = number.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> mapResult = number.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line">number.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	number[index] = item*<span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="缩小方法"><a href="#缩小方法" class="headerlink" title="缩小方法"></a>缩小方法</h2><p>reduce()和reduceRight()方法为两个缩小数组方法，这两个方法都会迭代数组的所有项，其中reduce()方法从数组的第一项开始，逐个遍历到最后；而reduceRight()则从数组的最后一项开始，向前遍历到第一项。这连个方法都接收两个参数：一个在每一项上调用的函数和作为缩小基础的初始值（可选）。串给reduce()和reduceRight()函数接收4个参数：前一个值，当前值，想的索引和数组对象，函数返回的任何值都会作为第一个参数自动传给下一项，第一次迭代发生在数组的第二项上，因此第一个参数时数组的第一项，第二个参数就是数组的第二项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(sum)</span><br></pre></td></tr></table></figure>
<p>reduceRight()方法相较reduce()方法区别在于执行的方向不同。</p>
<h2 id="ES6增强的数组功能"><a href="#ES6增强的数组功能" class="headerlink" title="ES6增强的数组功能"></a>ES6增强的数组功能</h2><h3 id="Array-of-方法"><a href="#Array-of-方法" class="headerlink" title="Array.of()方法"></a>Array.of()方法</h3><p>JS语言中存在一个怪异点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> item = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])     <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">1</span>])     <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">item = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"2"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">item = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])     <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">1</span>])     <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">item = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="string">"2"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])     <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">1</span>])     <span class="comment">//"2"</span></span><br></pre></td></tr></table></figure>

<p>ES6中引用Array.of()方法来解决这个问题，该方法类似 Array 构造器，但在使用多个数值参数的时候不会导致特殊结果。Array.of()方法总会创建一个包含所有出入参数的数组，不管参数的数量和类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> item = <span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length)      <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])          <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">1</span>])          <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> item = <span class="built_in">Array</span>.of(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length)      <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])          <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> item = <span class="built_in">Array</span>.of(<span class="string">"2"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length)      <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])          <span class="comment">//"2"</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-from-方法"><a href="#Array-from-方法" class="headerlink" title="Array.from()方法"></a>Array.from()方法</h3><p>该方法将类数组对象转化为数组对象,同时，可以向from传入一个映射函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, (value) =&gt; value + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> number = translate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(number)                  <span class="comment">//2,3,4</span></span><br></pre></td></tr></table></figure>
<p>如果映射函数需要在对象上工作，可以手动传递第三个参数给Array.from()方法，从而<strong>指定映射函数内部</strong>的this值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> diff = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> helper = &#123;</span><br><span class="line">    diff: <span class="number">1</span>,</span><br><span class="line">    add(value) &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="keyword">this</span>.diff)</span><br><span class="line">        <span class="keyword">return</span> value + <span class="keyword">this</span>.diff</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.diff = <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, helper.add, helper) <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, helper.add)         <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers = translate(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers)       <span class="comment">//1     2,3,4   2    4,5,6</span></span><br></pre></td></tr></table></figure>
<p>Array.from()方法不仅可以用于类数组对象，也可以用于迭代对象，这意味着该方法可以将任意包含Symbol.iterator属性的对象转换为数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = &#123;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator] () &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers2 = <span class="built_in">Array</span>.from(numbers, (value)=&gt;value+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers2)</span><br></pre></td></tr></table></figure>
<h3 id="数组上的新方法"><a href="#数组上的新方法" class="headerlink" title="数组上的新方法"></a>数组上的新方法</h3><p>find()与findIndex()方法。ES5中增加了indexOf()和lastIndexOf()方法，从而允许开发者在数组中查找特定值，但仍存在限制。<br>find()和findIndex()方法均接受两个参数：一个回调函数、一个可选值用于指定回调函数内部的this。该回调函数可接受三个参数：数组的某个元素、该元素对应的索引位置以及该数组自身，这与map()和forEach()方法的回调函数所用的参数一致。<strong>该回调函数应当在给定的元素满足你定义的条件时返回true</strong>，而find()和findIndex()方法均会在回调函数第一次返回true时停止查找。find()会返回匹配的值，findIndex()会返回匹配位置的索引。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line"><span class="built_in">console</span>.log(numbers.find(<span class="function"><span class="params">n</span>=&gt;</span> n &gt; <span class="number">30</span>))</span><br><span class="line"><span class="built_in">console</span>.log(numbers.findIndex(<span class="function"><span class="params">n</span>=&gt;</span> n &gt; <span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<p><strong>find()与findIndex()方法在查找满足特定条件的数组元素时非常有用。但若想查找特定值，则使用 indexOf() 与 lastIndexOf() 方法会是更好的选择。</strong><br>fill()方法能使用特定值填充数组中的一个或多个元素，当只使用一个参数的时候，该方法会用该参数的值填充整个数组，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers.fill(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())   <span class="comment">//1,1,1,1</span></span><br></pre></td></tr></table></figure>
<p>当只改变部分值时，可设置起始位置和结束位置的参数（不包括结束位置）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers.fill(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())   <span class="comment">//1,2,1,1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers.fill(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())   <span class="comment">//1,1,1,4</span></span><br></pre></td></tr></table></figure>
<p>copyWithin()方法和fill()方法类似，可以一次性修改数组的多个元素。copyWithin()方法允许在数组内部复制自身元素，为此你需要传毒两个参数给copyWithin()方法：从什么位置开始填充，被用来复制的数据的起始位置索引以及终止位置索引</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">numbers.copyWithin()(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())  <span class="comment">//1,2,1,2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">numbers.copyWithin(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())</span><br></pre></td></tr></table></figure>
<h2 id="类型化数组"><a href="#类型化数组" class="headerlink" title="类型化数组"></a>类型化数组</h2><p>类型化数组是有特殊用途的数组，被设计用来处理数值类型数据（而不像名称暗示的那样，能处理所有类型）。引入类型化数组突破了格式限制并带来了更好的<br>数学运算性能，其设计概念是：单个数值可以被视为由“位”构成的数组，并且可以对其使用与JS 数组现有方法类似的方法。</p>
<h3 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a>数值数据类型</h3><p>JS 数值使用 IEEE 754 标准格式存储，使用64位来存储一个数值的浮点数表示形式，该格式在JS中被同时用来表示整数与浮点数；当值改变时，可能会频繁发生整数与浮点数之间的格式转换。而类型化数组则允许存储并操作八种不同的数值类型：</p>
<ol>
<li>8 位有符号整数（int8）</li>
<li>8 位无符号整数（uint8）</li>
<li>16 位有符号整数（int16）</li>
<li>16 位无符号整数（uint16）</li>
<li>32 位有符号整数（int32）</li>
<li>32 位无符号整数（uint32）</li>
<li>32 位浮点数（float32）</li>
<li>64 位浮点数（float64）<br>所有与类型化数组相关的操作和对象都围绕着这八种数据类型。为了使用它们，你首先需要创建一个数组缓冲区用于存储数据。<h3 id="数组缓冲区"><a href="#数组缓冲区" class="headerlink" title="数组缓冲区"></a>数组缓冲区</h3>数组缓冲区（array buffer）是内存中包含一定数量字节的区域，而所有的类型化数组都基于数组缓冲区。使用ArrayBuffer构造器来创建一个数组缓冲区；调用ArrayBuffer构造器时，只需要传入单个数值用于指定缓冲区包含的字节数。可以通过byteLength属性来获取缓冲区的字节数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(buffer.byteLength)</span><br></pre></td></tr></table></figure>
可以使用slice()方法来创建一个新的、包含已有缓冲区部分的内容数组缓冲区，和数组的slice()方法类似，可以使用起始位置与结束位置参数，返回由原缓冲区元素组成的一个新的ArrayBuffer实例。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> buffer2 = buffer.slice(<span class="number">4</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log((buffer2.byteLength))</span><br></pre></td></tr></table></figure>
<h2 id="使用视图操作数组缓冲区"><a href="#使用视图操作数组缓冲区" class="headerlink" title="使用视图操作数组缓冲区"></a>使用视图操作数组缓冲区</h2>数组缓冲区代表了一块内存区域，而视图（views）则是操作这块区域的接口。视图工作在数组缓冲区或其子集上，可以读写某种数值数据类型的数据。DataView类型时数组缓冲区的通用视图，允许对前述所有8中数值数据类型进行操作。同时可以对数据缓冲区的部分上创建视图，需要提供字节偏移量以及要包含的字节数。<strong>使用这种方式，你可以在同一个数组缓冲区上创建多个不同的视图，这样有助于将单块内存区域供给整个应用使用，而不必每次在有需要时才动态分配内存。</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buffer2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">5</span>,<span class="number">2</span>) <span class="comment">//包含位置5和位置6的字节</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>获取视图信息<br>可以通过查询一下只读属性来获取视图的信息：<br>buffer: 概述图所绑定的数组缓冲区；<br>byteOffset：传给DataView构造器的第二个参数，如果当时提供了的话（默认为0）；<br>byte Length：传给DataView构造器的第三个参数，如果当时提供的话（默认为该缓冲区的byteLength属性）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> view1 = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer)</span><br><span class="line"><span class="keyword">let</span> view2 = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(view1.buffer === buffer)            <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(view2.buffer === buffer)            <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(view1.byteOffset)</span><br><span class="line"><span class="built_in">console</span>.log(view2.byteOffset)</span><br><span class="line"><span class="built_in">console</span>.log(view1.byteLength)</span><br><span class="line"><span class="built_in">console</span>.log(view2.byteLength)</span><br></pre></td></tr></table></figure>

<p>读取和写入数据<br>对应JS所有8种数值数据类型，DataView视图的原型别提供了在数组缓冲区上写入数据的一个方法以及读取数据的一个方法，说有方法名都以“set”或“get”开始，气候跟随这对应数据类型的缩写,例如操作int8或unit8类型的读取/写入方法：<br>“get”方法接受两个参数：开始进行读取的字节偏移量、以及一个可选的布尔值，后者用于指定读取的值是否采用低字节优先方式（注：默认值为 false ）。“set”方法则接受三个参数：开始进行写入的字节偏移量、需要写入的数据值、以及一个可选的布尔值用于指定是否采用低字节优先方式存储数据。<br>**<br>getInt8(byteOffset,littleEndian): 从byteOffset处开始读取一个int8值；<br>setInt8(byteOffset, value, littleEndian): 从byteOffset处开始写入一个int8值；<br>**<br><strong>译注：低字节优先（Little-endian）也被翻译作“小端字节序”，指的是在存储数据的多个内存字节中，第一个内存字节存储着数据的最低字节数据，而最后一个内存字节存储着最高字节数据。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>),</span><br><span class="line">view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">view.setInt8(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">0</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">1</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>视图允许你使用任意格式对任意位置进行读写，而无须考虑这些数据此前是使用什么格式存储的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer)</span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">view.setInt8(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt16(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>在混用不同的数据类型时，使用DataView对象是一种完美方式，不过，若尽享使用特定的一种数据类型，那么特定类型试图会是更好的选择。</p>
<p>类型化数组即为视图</p>
<p>开始时，该数组缓冲区 16 个位均为 0 ；使用 setInt8() 向第一个字节写入 5 之后，该字节的内容就出现了一对 1 （因为 5 可以写为 8 位二进制数 00000101 ）；向第二个字节写入-1 会使得该字节的所有位都变成 1 （即 -1 的二进制补码形式）。接下来使用 getInt16() 就能将前面写入的 16 位数据以单个 16 位整数的方式读取出来，其十进制值就是1535。<br>ES6 的类型化数组实际上也是针对数组缓冲区的特定类型视图，你可以使用这些数组对象来处理特定的数据类型，而不必使用通用的 DataView 对象。一共存在八种特定类型视图，对应着八种数值数据类型，为处理 uint8 值提供了额外的选择。</p>
<p>构造器名称                          元素大小<br>Int8Array                               1<br>Uint8Array                              1<br>Uint8ClampedArray                       1<br>Int16Array                              2<br>Uint16Array                             2<br>Int32Array                              4<br>Uint32Array                             4<br>Float32Array                            4<br>Float64Array                            8<br><strong>类型化数组的构造器可以接受多种类型的参数</strong>，因此存在几种创建类型化数组的方式。<br>第一种方式是使用与创建 DataView 时相同的参数，即：一个数组缓冲区、一个可选的字节偏移量、以及一个可选的字节数量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> view1 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer)</span><br><span class="line"><span class="keyword">let</span> view2 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(view1.buffer === buffer)                    <span class="comment">//true               </span></span><br><span class="line"><span class="built_in">console</span>.log(view2.buffer === buffer)                    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(view1.byteOffset)                           <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(view2.byteOffset)                           <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(view1.byteLength)                           <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(view2.byteLength)                           <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>第二种方法是传递单个数值给类型化数组的构造器，<strong>此数值表示该数组包含的元素数量（而不是分配的字节数）</strong>。构造器会创建一个新的缓冲区，分配正确的字节数以便容纳指定数量的数组元素。可以通过length属性来获取这个元素数量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> floats = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ints.byteLength)</span><br><span class="line"><span class="built_in">console</span>.log(ints.length)</span><br><span class="line"><span class="built_in">console</span>.log(floats.byteLength)</span><br><span class="line"><span class="built_in">console</span>.log(floats.length)</span><br></pre></td></tr></table></figure>
<p><strong>如果调用类型化数组构造器时没有传入参数，构造器会认为传入了 0 ，这种方式创建的类型化数组不会被分配任何存储空间，因此也就不能被用于保存数据。</strong><br>第三种方式是向构造器传递单个对象参数<br><strong>类型化数组</strong>：数组所有元素都会被复制到新的类型化数组中。例如，如果你传递一个 int8类型的数组给 Int16Array 构造器，这些 int8 的值会被复制到 int16 数组中。新的类型化数组与原先的类型化数组会使用不同的数组缓冲区。<br><strong>可迭代对象</strong>：该对象的迭代器会被调用以便将数据插入到类型化数组中。如果其中包含了不匹配视图类型的值，那么构造器就会抛出错误。<br><strong>数组</strong>：该数组的元素会被插入到新的类型化数组中。如果其中包含了不匹配视图类型的值，那么构造器就会抛出错误。<br><strong>类数组对象</strong>：与传入数组的表现一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints1 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</span><br><span class="line">ints2 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(ints1);</span><br><span class="line"><span class="built_in">console</span>.log(ints1.buffer === ints2.buffer); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1.byteLength); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1[<span class="number">1</span>]); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2.byteLength); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2[<span class="number">1</span>]); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<h3 id="类型化数组与常规数组的相似点"><a href="#类型化数组与常规数组的相似点" class="headerlink" title="类型化数组与常规数组的相似点"></a>类型化数组与常规数组的相似点</h3><p>类型化数组与常规数组有好几个相似点，类型化数组在很多场景中都可以像常规数组那样被使用。例如，你可以使用length属性来获取类型化数组包含的元素数量，还可以使用数值类型的索引值来直接访问类型化数组的元素。<br><strong>与常规数组不同的是，你不能使用 length 属性来改变类型化数组的大小。该属性是不可写的，在非严格模式下写入操作会被忽略，而严格模式下则会抛出错误。</strong><br>类型化数组也拥有大量与常规数组等效的方法，你可以对类型化数组使用下列这些方法：<br>copyWithin()、entries()、fill()、filter()、find()、findIndex()、forEach()、indexOf()、join()、keys()、lastIndexOf()、map()、reduce()、reduceRight()、reverse()、slice()、some()、sort()、values()<br><strong>注意</strong>虽然这些方法的表现与数组原型上的对应方法相似，但它们并不完全相同。类型化数组的方法会进行额外的类型检查以确保安全，并且返回值会是某种类型化数组，而不是常规数组（归结于 Symbol.species 属性）。这里有个例子用于演示其中的区别：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</span><br><span class="line">mapped = ints.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mapped.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped[<span class="number">0</span>]); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped[<span class="number">1</span>]); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>**相同的迭代器<br>与常规数组相同，类型化数组也拥有三个迭代器，它们是 entries() 方法、 keys() 方法与values() 方法。这就意味着你可以对类型化数组使用扩展运算符，或者对其使用for-of 循环，就像对待常规数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</span><br><span class="line">intsArray = [...ints];</span><br><span class="line"><span class="built_in">console</span>.log(intsArray <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(intsArray[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(intsArray[<span class="number">1</span>]); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>of()和from()方法<br>所有的类型化数组都包含静态的 of() 与 from() 方法，作用类似于 Array.of() 与Array.from() 方法。其中的区别是类型化数组的版本会返回类型化数组，而不返回常规数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="built_in">Int16Array</span>.of(<span class="number">25</span>, <span class="number">50</span>),</span><br><span class="line">floats = <span class="built_in">Float32Array</span>.from([<span class="number">1.5</span>, <span class="number">2.5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(floats <span class="keyword">instanceof</span> <span class="built_in">Float32Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(ints.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(floats.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(floats[<span class="number">0</span>]); <span class="comment">// 1.5</span></span><br><span class="line"><span class="built_in">console</span>.log(floats[<span class="number">1</span>]); <span class="comment">// 2.5</span></span><br></pre></td></tr></table></figure>
<p>类型化数组与常规数组的区别</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(ints)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>行为差异<br>**常规数组可以被伸展或是收缩，然而类型化数组却会始终保持自身大小不变。你可以对常规数组一个不存在的索引位置进行赋值，但在类型化数组上这么做则会被忽略。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]); <span class="comment">// 50</span></span><br><span class="line">ints[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ints.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>类型化数组也会对数据类型进行检查以保证只使用有效的值，当无效的值被传入时，将会被替换为0</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="string">"hi"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>所有在类型化数组上修改项目值的方法都会受到相同的限制，例如当 map() 方法使用的映射函数返回一个无效值的时候，类型化数组会使用 0 来代替返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</span><br><span class="line">mapped = ints.map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mapped.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped[<span class="number">0</span>]); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped[<span class="number">1</span>]); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>尽管类型化数组拥有常规数组的很多同名方法，但仍然缺少了几个数组方法，包括下列这些：<br>concat()、pop()、push()、shift()、splice()、unshift()<br>除了 concat() 方法之外，该列表中的其余方法都会改变数组的大小，而由于类型化数组的大小不可变，因此这些方法都不能作用于类型化数组。 concat() 方法不可用的原因则是：连接两个类型化数组的结果是不确定的（特别是当它们处理的数据类型不同时），这种不确定情况原本就不应当使用类型化数组。</p>
<p>**附加的方法<br>类型化数组还有两个常规数组所不具备的方法： set() 方法与 subarray() 方法。这两个方法作用相反： set() 方法从另一个数组中复制元素到当前的类型化数组，而subarray() 方法则是将当前类型化数组的一部分提取为新的类型化数组。<br>set() 方法接受一个数组参数（无论是类型化的还是常规的）、以及一个可选的偏移量参数，后者指示了从什么位置开始插入数据（默认值为 0 ）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">4</span>);</span><br><span class="line">ints.set([<span class="number">25</span>, <span class="number">50</span>]);</span><br><span class="line">ints.set([<span class="number">75</span>, <span class="number">100</span>], <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ints.toString()); <span class="comment">// 25,50,75,100</span></span><br></pre></td></tr></table></figure>
<p>subarray() 方法接受一个可选的开始位置索引参数、以及一个可选的结束位置索引参数（像slice() 方法一样，结束位置的元素不会被包含在结果中），并会返回一个新的类型化数组。你可以同时省略这两个参数，从而创建原类型化数组的一个复制品。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]),</span><br><span class="line">subints1 = ints.subarray(),</span><br><span class="line">subints2 = ints.subarray(<span class="number">2</span>),</span><br><span class="line">subints3 = ints.subarray(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subints1.toString()); <span class="comment">// 25,50,75,100</span></span><br><span class="line"><span class="built_in">console</span>.log(subints2.toString()); <span class="comment">// 75,100</span></span><br><span class="line"><span class="built_in">console</span>.log(subints3.toString()); <span class="comment">// 50,75</span></span><br></pre></td></tr></table></figure>



<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="attr"></p>
<p>上图中展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系，由于所有实现中都无法访问到[[Prototype]]，因此可以通过isPrototypeOf()确定对象对象间是否存在这种关系，如下所示：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">面向对象的程序设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 11:26:13 / Modified: 11:28:26" itemprop="dateCreated datePublished" datetime="2020-04-26T11:26:13+08:00">2020-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">JavaScript高级程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>引用类型的值（对象）是引用类型的一个实例。</strong>在ECMAScript中，引用类型是一种书结构，用于将数据和功能组织在一起。尽管ECMAScript从技术上讲是一门面向对象的语言，但他不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。<br>对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的，构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。</p>
<h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>虽然Object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。<br>创建Object实例的方法有两种，第一种是使用new操作符后跟Object构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">"Nicholas"</span></span><br><span class="line">person.age = <span class="number">19</span></span><br></pre></td></tr></table></figure>
<p>另一种方式是使用<strong>对象字面量</strong>表示法，对象i字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。其中，属性名也可以使用字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>,</span><br><span class="line">person.age = <span class="number">19</span></span><br></pre></td></tr></table></figure>
<p>对象的属性可以通过点表示法和方括号法进行访问，从功能上看两者没有任何区别，但方括号语法的主要优点是可以通过变量来访问属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;</span><br><span class="line">    name: <span class="string">'daming'</span>,</span><br><span class="line">    age: <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personName = <span class="string">'name'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br><span class="line"><span class="built_in">console</span>.log(person[personName])</span><br></pre></td></tr></table></figure>
<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>ECMA-262在定义只有内部才能用的特性(attribute)时，描述了属性(property)的各种特征。这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问它们。为了表示特性是内部值，该规范把他们放在了两对方括号中，例如[[Enumerable]]。<br>对象有两种属性，数据属性和访问器属性</p>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有4个描述其行为的特性：<br>1.[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。<br>2.[[Enumerable]]:表示能否通过for-in循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true；<br>3.[[Writable]]:表示能否修改属性的值，像前面离震中那样直接在对象上定义的属性，它们的这个特性默认为true；<br>4.[[Value]]:包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性时，把新值保存在这个位置。这个特性的默认值为undefined。<br>对于前面例子中那样直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]、[[Writable]]特性都被设置为true，而[[Value]]特性被设置为指定的值<br>要修改属性默认的特性，必须使用Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象，属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable，enumerable，writable，value。设置其中的一个或多个值，可以修改对应的特性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">//Nicholas</span></span><br><span class="line">person.name = <span class="string">"daming"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>
<p>当writable为false时，在严格模式下赋值操作将抛出错误，在非严格模式下将被忽略，这个规则适用于”configurable: false”情况下。同时当把属性定义为不可配置的，就<strong>不能</strong>把它在变回可配置的。此时再调用Object.defineProperty()方法修改除writable之外的特性，都会导致错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configureble: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//一下代码将导致抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: ture,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p><strong>访问器属性不包含数据值</strong>，它们包含一对getter和setter函数（这两个函数都不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数，并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性：<br>[[Configurable]]: 表示能否通过delete删除从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性，对于直接在对象上定义的属性，合格特性的默认值为true<br>[[Enumerable]]：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。<br>[[Get]]：在读取属性时调用的函数。默认值为undefined<br>[[Set]]：再写入属性时。默认值为undefined<br>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _yera: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.edition)   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>_year前的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性；而<strong>访问器属性year</strong>则包含一个getter函数和一个setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，把year属性修改为2005会导致——year变为2005，而edition变为2.这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。<br>不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，非严格模式下尝试写入属性会被忽略；在严格模式下，尝试写入值制定了getter函数的属性会抛出错误。类似的，没有指定getter函数的属性也不能读，否则在非严格模式下会返回undefined，在严格模式下会抛出错误。</p>
<h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>由于为对象定义多个属性的可能性很大，ECMAScript 5 又定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">    _year:&#123;</span><br><span class="line">        value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>使用Object.definePropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和尧都区其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个歌对象的属性又configurable, enumerable, get, set；如果是数据属性，这个对象的属性有configurable, enumerable, writable, value.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperities(book, &#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>)</span><br><span class="line"><span class="keyword">var</span> descriptor2 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor2.value)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor2.enumerable)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor2.get)</span><br></pre></td></tr></table></figure>
<p>在JavaScript中，可以针对任何对象，包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    o.name = name</span><br><span class="line">    o.age = age</span><br><span class="line">    o.job = job</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>)</span><br></pre></td></tr></table></figure>
<p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别问题（即怎样知道一个对象的类型）。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"daming"</span>, <span class="number">13</span>, <span class="string">"SoftWare Engineer"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaoming"</span>, <span class="number">11</span>, <span class="string">"student"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：要创建Person的新实例，必须使用new操作符，这种方式调用构造函数实际上会经历以下4个步骤:<br>1.创建一个新对象<br>2.将构造函数的租用与赋给新对象（因此this就只想了这个新对象）<br>3.执行构造函数中的代码（为这个个新对象添加属性）<br>4.返回新对象</p>
<p>在前面的例子最后，person1和person2分别保存着Person的一个不同的实例，这两个对象都有一个constructor（构造函数）属性，改属性指向Person。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor === Person)    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor === Person)    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>对象的constructor属性最初时用来表示对象类型的。但是，提到检测对象类型，还是instanceof更可靠一些。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)         <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person)         <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而着正事构造函数模式胜过工厂模式的地方。<br><strong>以这种方式定义的构造函数是定义在Global对象（在浏览器中是window对象）中的。</strong></p>
<p>**将构造函数当作函数<br>构造函数与其他函数的唯一区别，就在于调用它们的方式不同，不过构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new操作符调用，那它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当作构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"software engineer"</span>)</span><br><span class="line">person.sayName()       <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//作为普通函数调用</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>)</span><br><span class="line"><span class="built_in">window</span>.sayName()                <span class="comment">//"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">Person.call(o, <span class="string">"daming"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>)</span><br><span class="line">o.sayName()              <span class="comment">//"daming"</span></span><br></pre></td></tr></table></figure>

<p>**构造函数的问题<br>构造函数模式虽然好用，但也并非没有缺点，使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。ECMAScript中的函数是对象，因此没定义一个函数，也就是实例化了一个对象，从逻辑角度讲，此时的构造函数也可以这样定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log(this.name)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个角度上来看构造函数，更容易明白每个Person实例都包含一个不同的Function实例（以显示name属性）的本质。以这种方式创建函数，会导致不同的作用域链和表示符解析，但创建Function新实例的机制仍然是相同的。因此不同实力上的同名函数是不相等的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName)       <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>然而，创建两个完成同样任务的Function实例的确没有必要，况且有this对象在，根本不用在执行代码前就把哈数绑定到特定对象上面。因此，大可像下面这样，通过函数定义转移到构造函数外部来解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"daming"</span>, <span class="number">19</span>, <span class="string">"software engineer"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaoming"</span>, <span class="number">17</span>, <span class="string">"docter"</span>)</span><br></pre></td></tr></table></figure>
<p>这个例子中，我们把sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们讲sayName属性设置等于全局的sayName函数，这样一来由于sayName包含的是一个指向函数的指针，因此person1和person2对象就共享了在全局作用臃肿定义的同一个sayName()函数。这解决了两个函数做同一件事的问题，但出现了新问题。全局作用域下的函数只能被某个对象调用，有违全局作用域的本意，同时如果对象需要定义很多方法，那么就要定义多个全局函数，这样就毫无封装性可言了。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。换句话说，不必再构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.prototype.name = <span class="string">"daming"</span></span><br><span class="line">    Person.prototype.age = <span class="number">19</span></span><br><span class="line">    Person.prototype.job = <span class="string">"software engineer"</span></span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line">person1.sayName()    <span class="comment">//daming</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line">person2.sayName()    <span class="comment">//daming</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName)    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在此，<strong>与构造函数不同之处在于，新对象的这些属性和方法是由所有实例共享的。</strong></p>
<p>理解原型对象<br>无论什么时候，只要创建了一个新函数，就回根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针，就拿前面的例子来说，Person.prototype.constructor指向Person。通过这个构造函数，我们可以继续为原型对象添加其他属性和方法。<br>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，至于其他方法，都是从Object继承而来。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象，ECMA-262第5版中管这个指针叫[[Prototype]]。<strong>要明确的是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例和构造函数之间</strong>。具体关系如下图</p>
<!-- ![attr](/public/images/实例原型构造函数关系图.png) -->
<p><img src="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/a.png" alt="attr"><br>如上例中，两个对象都不包含属性和方法，但我们却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。<br>虽然在所有实现中都无法访问到[[Prototype]],但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向 调用isPrototypeOf()方法的对象（Person.prototype),那么这个方法就返回true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1))</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person2))</span><br></pre></td></tr></table></figure>
<p>ECMAScript5中增加了一个新方法，叫Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype)     <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1).name)                    <span class="comment">//"daming"</span></span><br></pre></td></tr></table></figure>
<p>使用Object.getPrototypeOf()可以方便地取得一个对象的原型，而在利用原型实现集成的情况下是非常重要的。<br>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值，如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那就在实例中创建该属性，改属性将会屏蔽原型中的那个属性。添加这个属性只会阻止访问原型对象中的那个属性，但不会修改那个属性。即使将该属性设为null，也只会在实例中设置这个属性，不会恢复其指向原型的连接。不过delete操作符可以完全删除实例属性，从而能够重新访问原型中的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span></span><br><span class="line">Person.prototype.age = <span class="number">19</span></span><br><span class="line">Person.prototype.job = <span class="string">"software engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line">person1.name = <span class="string">"daming"</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name)   <span class="comment">//daming</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name)   <span class="comment">//Nicholas</span></span><br><span class="line">person1.sayName()           <span class="comment">//daming</span></span><br><span class="line">person2.sayName()           <span class="comment">//Nicholas</span></span><br><span class="line"></span><br><span class="line">person1.name = <span class="literal">null</span>         </span><br><span class="line"><span class="built_in">console</span>.log(person1.name)   <span class="comment">//null</span></span><br><span class="line">person1.sayName()           <span class="comment">//null</span></span><br><span class="line"><span class="keyword">delete</span> person1.name</span><br><span class="line"><span class="built_in">console</span>.log(person1.name)   <span class="comment">//Nicholas</span></span><br><span class="line">person1.sayName()           <span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>
<p>使用hasOwnProperty()方法可以检测一个属性是存在在于实例中还是存在在于原型中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span></span><br><span class="line">Person.prototype.age = <span class="number">19</span></span><br><span class="line">Person.prototype.job = <span class="string">"software engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line">person1.name = <span class="string">"daming"</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name)                    <span class="comment">//daming</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name)                    <span class="comment">//Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="keyword">delete</span> person1.name                           </span><br><span class="line"><span class="built_in">console</span>.log(person1.name)                    <span class="comment">//Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><strong>原型与in操作符</strong><br>有两种方式使用in操作符：单独使用和在for-in循环中使用。<br><strong>单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span></span><br><span class="line">Person.prototype.age = <span class="number">29</span></span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1)               <span class="comment">//true</span></span><br><span class="line">person1.name = <span class="string">"Greg"</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name)                    <span class="comment">//"Greg" -----来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1)               <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name)                    <span class="comment">//daming -----来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person2)               <span class="comment">//true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name</span><br><span class="line"><span class="built_in">console</span>.log(person1.name)                    <span class="comment">//daming -----来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1)               <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>在使用for-in循环时，返回的时所有能够通过对象访问的，可枚举的（enumerated）属性，其中，既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerale]]标记的属性）的实例也会在for-in循环中返回。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span></span><br><span class="line">Person.prototype.age = <span class="number">29</span></span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;                                    <span class="comment">//name, age, job, sayName</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"name"</span>, &#123;</span><br><span class="line">	enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;                                   <span class="comment">//age, job, sayName</span></span><br><span class="line">person1.name = <span class="string">"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;                                   <span class="comment">//name, age, job, sayName</span></span><br></pre></td></tr></table></figure>
<p>要取得对象上所有可枚举的实例属性，可以使用ECMAScript5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。<br><strong>注意Object.keys和for-in之间的差别</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"daming"</span></span><br><span class="line">Person.prototype.age = <span class="number">29</span></span><br><span class="line">Person.prototype.job = <span class="string">"softWare Engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(keys)                               <span class="comment">//name, age, job, sayName</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1.name = <span class="string">"Rob"</span></span><br><span class="line">p1.age = <span class="number">31</span></span><br><span class="line"><span class="keyword">var</span> p1keys = <span class="built_in">Object</span>.keys(p1)</span><br><span class="line"><span class="built_in">console</span>.log(p1keys)                            <span class="comment">//name, age</span></span><br></pre></td></tr></table></figure>
<p><strong>如果需要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(keys)                                   <span class="comment">//constructor, name, age, job, sayName</span></span><br></pre></td></tr></table></figure>

<p><strong>更简单的原型语法</strong><br>用一个包含所有属性和方法的对象字面量来重写整个原型对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，将Person.prototype设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外，constructor属性不再指向Person了。每创建一个函数，都会同时创建它的prototype对象，这个对象会自动获得constructor属性，而我们在这里使用的语法，本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数。此时，尽管instanceof操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor ==<span class="built_in">Object</span>)  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(friend2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend2 <span class="keyword">instanceof</span> Person)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend2.constructor == Person) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(friend2.constructor ==<span class="built_in">Object</span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>另一种写法，会导致不同的输出结果，原因在于重写了Person.prototype对象后Person.prototype已发生改变，<strong>注意与上一种的区别联系</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor ==<span class="built_in">Object</span>)  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person)  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor ==<span class="built_in">Object</span>)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>如果constructor的值真的很重要，可以像像下面这样特意将他设置会适当值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "nicholas",</span><br><span class="line">    age: 29,</span><br><span class="line">    job: "software Engineer",</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，以这种方式重设constructor属性会导致它的[[Enumerable]]特性被设置为true。默认情况下，原生的constructor属性是不可枚举的，弥补方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fucntion Person() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span></span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>原型的动态性</strong><br>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所作的任何修改都能够立即从实例上反映出来，即使先创建了实例后修改原型也照样如此。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line">friend.sayHi()     <span class="comment">//hi</span></span><br></pre></td></tr></table></figure>
<p>尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果重写整个原型对象就不一样了。其原因在于，调用构造函数时会为实力添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系。**实例中的指针仅指向原型，不指向构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sayAge'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'Nicholas',</span><br><span class="line">    age: 19,</span><br><span class="line">    job: 'software enginner',</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">friend.sayAge()                 <span class="comment">//'sayAge'</span></span><br><span class="line">friend.sayName()                <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p><strong>原生对象的原型</strong><br>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object, Array, String, 等等）都在其构造函数的原型上定义了方法。例如，在Array.prototype中可以找到sort()方法，而在String.prototype中可以找到substring()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort)                 <span class="comment">//funciton</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring)           <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型String添加了一个名为startsWith()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">'Hello World'</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">'Hello'</span>))   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>尽管可以这样做，但不推荐在产品化的程序中修改原生对象的原型。如果因某个事项中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的视线中运行代码时，就可能会导致命名冲突，而且这样做也可能会意外地重写原生方法。<br><strong>原生对象地问题</strong><br>原型模式也不是没有缺点，首先，它省略了为构造函数传递初始化阐述这一回姐，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题，原型模式的最大问题是由其共享的本性所导致的。<br>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性说得过去，因为通过在实力上添加一个同名属性，可以隐藏原型中的对应属性。但对于包含引用类型的属性来说，问题就比较突出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'Nicholas',</span><br><span class="line">    age: 19,</span><br><span class="line">    job: 'software enginee',</span><br><span class="line">    friends: ['daing', 'lingling'],</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line">person1.friends.push(<span class="string">'Van'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends)                       <span class="comment">//daing, lingling, Van</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends)                       <span class="comment">//daing, lingling, Van</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.freidns)   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在person1的friends中添加一项，person2的friends也相应添加了一项，在大多数情况下这是不想要的，这个问题正是很少有人单独使用原型模式的原因。</p>
<h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。<strong>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性</strong>。这样，每个实力都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，这最大限度地接上了内存。另外，这种混成模式还支持向构造函数传递参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">'daming'</span>, <span class="string">'lingling'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">19</span>, <span class="string">'software engineer'</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">17</span>, <span class="string">'doctor'</span>)</span><br><span class="line">person1.friends.push(<span class="string">'van'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends)                                 <span class="comment">//daming, lingling, van</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends)                                 <span class="comment">//daming, lingling</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends)             <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName)             <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>动态原型模式把所有信息都封装再了构造函数中，二通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否有需要初始化原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>通常，在前述的集中模式都不适用的情况下，可以使用寄生(parasitic)构造函数模式。这种模式的基本思想时创建一个函数，该函数的作用仅仅时封装创建对象的代码，然后再返回新建的对象；但从表面上看，这个函数又像是典型的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    o.name = name</span><br><span class="line">    o.age = age</span><br><span class="line">    o.job = job</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'software engineer'</span>)</span><br><span class="line">friend.sayName()                                                  <span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>
<p>这里除了使用new操作符并把使用的包装函数叫做构造函数骄傲做构造函数之外，这个模式跟工厂模式其实是一模一样的。<strong>构造函数在不返回值的情况下，默认会返回新对象实例。而通过构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值。</strong><br>这个模式可以在特殊的情况西用来为对象创建构造函数，假设我们向创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数，因此可以使用这个模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">    values.push.apply(values, <span class="built_in">arguments</span>)</span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>)</span><br><span class="line"><span class="built_in">console</span>.log((colors.toPipeString()));</span><br></pre></td></tr></table></figure>
<p>关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造汉顺外部创建的对象没有什么不同。为此不能依赖instanceof操作符来确定对象类型。</p>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this对象，稳妥对象最适合在一些安全的环境中使用（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">"Nicholas"</span>, <span class="number">19</span>, <span class="string">"Software Engineer"</span>)</span><br><span class="line">friend.sayName()                                             <span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>
<p>注意，在以这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法访问name的值。<br>这样，变量person中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。稳妥构造函数模式提供这种安全性。<br>与寄生构造函数模式类似，使用稳妥构造含糊模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。</p>
<h2 id="扩展的对象功能"><a href="#扩展的对象功能" class="headerlink" title="扩展的对象功能"></a>扩展的对象功能</h2><h3 id="对象类别"><a href="#对象类别" class="headerlink" title="对象类别"></a>对象类别</h3><p>对象类别包括：<br>普通对象： 拥有JS对象所有默认的内部行为<br>奇异对象：其内部行为在某些方面有别于默认行为<br>标准对象：在ES6中被定义的对象，例如Array、Date等等<br>内置对象：在脚本开始运行时由JS运行环境提供的对象。<strong>所有标准对象都是内置对象。</strong></p>
<h3 id="对象字面量语法的扩展"><a href="#对象字面量语法的扩展" class="headerlink" title="对象字面量语法的扩展"></a>对象字面量语法的扩展</h3><p>对象字面量是JS中最流行的模式之一（JSON就是基于这种语法），而它还存在于互联网上的几乎所有JS文件中。<br><strong>属性初始化器的速记法</strong><br>在ES5及更早的版本中，对象字面量是“键值对”的简单集合。这意味着在属性值被初始化时可能会有重复，ES6中，可以使用属性初始化器的速记法来消除对象名称与本地变量的重复情况。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6语法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cretePerson</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法简写</strong><br>ES6同样改进了为对象字面量方法赋值的语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"nicholas"</span>,</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>需计算属性名</strong><br>对象实例能使用”需计算属性名“，只要用方括号表示法来替代小数点表示法即可。方括号允许你将变量或字符串字面量指定为属性名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'last name'</span></span><br><span class="line">person[<span class="string">'first name'</span>] = <span class="string">'nicholas'</span></span><br><span class="line">person[lastName] = <span class="string">'zakas'</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])          <span class="comment">//nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastName])              <span class="comment">//zakas</span></span><br><span class="line"><span class="built_in">console</span>.log(person.first name)             <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>可以在对象字面量中将字符串字面量直接用作属性，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">'first name'</span>: <span class="string">'nicholas'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])</span><br></pre></td></tr></table></figure>
<p>在ES6中，需计算属性名时对象字面语法的一部分，它用的也是方括号表示法，于此前在对象实例上的用法一直</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastName = <span class="string">'last name'</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">'first name'</span>: <span class="string">'nicholas'</span>,</span><br><span class="line">    [lastName]: <span class="string">'zakas'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(person[lastName])</span><br></pre></td></tr></table></figure>
<p>对象字面量内的方括号表明该属性名需要计算，其结果是一个字符串，这意味着其中可以包含表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suffix = <span class="string">' name'</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    [<span class="string">'first'</span> + suffix]: <span class="string">'nicholas'</span>,</span><br><span class="line">    [<span class="string">'last'</span> + suffix]: <span class="string">'zakas'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'last name'</span>])</span><br></pre></td></tr></table></figure>
<h3 id="新的方法"><a href="#新的方法" class="headerlink" title="新的方法"></a>新的方法</h3><p>当JS中要比较两个值时，可能会使用相等运算符（==）或严格相等运算符（===）。为了避免在比较时发生前值类型转化，许多开发者更倾向使用后者。但严格相等运算符也不完全标准，例如它认为+0和-0相等，即使这两者在JS引擎中有不同的表示；另外NaN===NaN会返回false，因此有必要使用isNaN()函数来正确检查NaN，<br>ES6引入了Object.is()方法来弥补严格相等运算符残留的怪异点。此方法接收两个参数，并会在二者的值相等时返回true，此时要求二者类型相同并且值也相等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="string">"5"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="string">"5"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="number">5</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="string">"5"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>Object.assign方法</strong><br>混入（Mixin）是在JS中组合对象时最流行的模式。再一次混入中，一个对象会从另一个对象中接收属性与方法。很多JS的库中都有类似下面的混入方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minin</span>(<span class="params">receiver, supplier</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(supplier).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        receiver[key] = supplier[key]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> receiver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于mixin()函数使用了赋值运算符（=），<strong>因此无法将访问器属性复制到接收者上，Object.assign()体现了这种区别(即无法复制访问器属性）。</strong><br>Object.assign() 方法接受任意数量的供应者，而接收者会按照供应者在参数中的顺序来依次接收它们的属性。这意味着在接收者中，第二个供应者的属性可能会覆盖第一个供应者的，这在下面的代码片段中就发生了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(receiver,</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">"js"</span>,</span><br><span class="line">        name: <span class="string">"file.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">"css"</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(receiver.type) <span class="comment">// "css"</span></span><br><span class="line"><span class="built_in">console</span>.log(receiver.name) <span class="comment">// "file.js"</span></span><br></pre></td></tr></table></figure>
<p><strong>需要记住 Object.assign() 并未在接收者上创建访问器属性，即使供应者拥有访问器属性。由于 Object.assign() 使用赋值运算符，供应者的访问器属性就会转变成接收者数据属性</strong>，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> supplier = &#123;</span><br><span class="line">    <span class="keyword">get</span> name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"file.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(receiver, supplier)</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(receiver, <span class="string">"name"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value) <span class="comment">// "file.js"</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.get); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>重复的对象字面量属性</strong><br>ES5 严格模式为重复的对象字面量属性引入了一个检查，若找到重复的属性名，就会抛出错误。例如，以下代码就有问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    name: <span class="string">"Greg"</span> <span class="comment">// 在 ES5 严格模式中是语法错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但 ES6 移除了重复属性的检查，严格模式与非严格模式都不再检查重复的属性。当存在重复属性时，排在后面的属性的值会成为该属性的实际值，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    name: <span class="string">"Greg"</span> <span class="comment">// 在 ES6 严格模式中不会出错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// "Greg"</span></span><br></pre></td></tr></table></figure>
<p><strong>自有属性的枚举顺序</strong><br>ES5并没有定义对象属性的枚举顺序。ES6中则严格定义了对象自由属性在被美剧时返回的顺序。这对Object.getOwnPropertyNames()和Reflect.ownKeys如何返回属性造成了影响，同样影响了Object.assign()处理属性的顺序。<br>自有属性枚举时基本顺序如下：<br>1.所有的数字类型键，按升序排列；<br>2.所有的字符串类型键，按被添加到对象的顺序排类；<br>3.所有的符号类型键，也按添加顺序排列。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    c: <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">obj.d = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).join(<span class="string">""</span>)); <span class="comment">// "012acbd"</span></span><br></pre></td></tr></table></figure>
<p><strong>for-in 循环的枚举顺序仍未被明确规定，因为并非所有的 JS 引擎都采用相同的方式。而 Object.keys() 和 JSON.stringify() 也使用了与 for-in 一样的枚举顺序。</strong><br><strong>更强大的原型</strong><br>修改对象的原型<br>一般来说，对象的原型会在通过构造器或 Object.create() 方法创建该对象时被指定。直到ES5 为止， JS 编程最重要的假定之一就是对象的原型在初始化完成后会保持不变。尽管ES5 添加了 Object.getPrototypeOf() 方法来从任意指定对象中获取其原型，但仍然缺少在初始化之后更改对象原型的标准方法。<br>ES6 通过添加 Object.setPrototypeOf() 方法而改变了这种假定，此方法允许你修改任意指定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = <span class="built_in">Object</span>.create(person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 将原型设置为 dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Woof"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>对象原型的实际值被存储在一个内部属性[[Prototype]]上，Object.getPrototypeOf()方法会返回此属性存储的值，而Object.setPrototypeOf()方法能够修改该值。<br><strong>使用super引用的简单原型访问</strong><br>关于原型的另一项进步就是引入了super引用，这让在对象原型上的功能调用变得更加容易。例如若要覆盖对象实例的一个方法、但依然要调用原型上的同名方法，如下（以下代码为ES5的实现方案）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">	name: <span class="string">'daming'</span>,</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="comment">// return 'woof' + this.name</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'woof'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">	name: <span class="string">'friend'</span>,</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">', hi'</span>         <span class="comment">//这里的this指向friend，可以通过this.name验证</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person)</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting())                             <span class="comment">//hello, hi</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person)         <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog)</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting())                             <span class="comment">//woof, hi</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog)            <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>从代码中可以看出this的指向过于复杂。ES6中引入super。简单说，super是指向当前对象的原型的一个指针，实际上就是Object.getPrototypeOf(this)的值。由此简化friend中的getGreet()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">    <span class="comment">// 这相当于上个例子中的：</span></span><br><span class="line">    <span class="comment">// Object.getPrototypeOf(this).getGreeting.call(this)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处调用super.getGreeting()等用于在上例的环境中使用Object.getPrototypeOf(this).getGreeting.call(this).类似的，能使用super引用来调用对象原型上的任何方法，<strong>只要这个引用时位于简写的方法之内</strong>。试图在方法接卸之外的情况使用super会导致语法错误，<strong>在这种上下文中 super 是不可用的：错误信息（SyntaxError: ‘super’ keyword unexpected here）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">', hi'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在多继承时，super引用功能非常强大，因为这种情况下，Object.getPrototypeOf()不再适用于所有场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="comment">// console.log('%%%%%%%%%%%%%%%%')</span></span><br><span class="line">    	<span class="comment">// console.log(this === relative)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">',hi'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person)</span><br><span class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend)</span><br><span class="line"><span class="built_in">console</span>.log(person.getGreeting())                   <span class="comment">//hello</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting())                   <span class="comment">//hello, hi</span></span><br><span class="line"><span class="built_in">console</span>.log(relative.getGreeting())                 <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>调用 Object.getPrototypeOf() 时，在调用 relative.getGreeting() 处发生了错误。这是因为此时 this 的值是 relative ，而 relative 的原型是 friend 对象，这样<br>friend.getGreeting().call() 调用就会导致进程开始反复进行递归调用，直到发生堆栈错误。(原因在于this引用的一直都是relative)<br>在ES6中，利用super可以解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person)</span><br><span class="line"><span class="comment">// 原型为 friend</span></span><br><span class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend)</span><br><span class="line"><span class="built_in">console</span>.log(person.getGreeting()) <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()) <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(relative.getGreeting()) <span class="comment">// "Hello, hi!"</span></span><br></pre></td></tr></table></figure>
<p><strong>正式的“方法”定义</strong><br>在ES6之前，“方法”的概念从未被正式定义，此前禁止对象的函数属性（而非数据属性）。ES6中正事做出了定义：方法时一个拥有[[HomeObject]]内部属性的函数，此内部属性指向该方法所属的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shareGreeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何对 super 的引用都会使用 [[HomeObject]] 属性来判断要做什么。第一步是在[[HomeObject]] 上调用 Object.getPrototypeOf() 来获取对原型的引用；接下来，在该原型<br>上查找同名函数；最后，创建 this 绑定并调用该方法。这里有个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person)</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()) <span class="comment">// "Hello, hi!"</span></span><br></pre></td></tr></table></figure>
<p>调用 friend.getGreeting() 返回了一个字符串，也就是 person.getGreeting() 的返回值与”, hi!” 的合并结果。此时 friend.getGreeting() 的 [[HomeObject]] 值是 friend ，并且friend 的原型是 person ，因此 super.getGreeting() 就等价于person.getGreeting.call(this) 。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ECMAScript中描述了<strong>原型链</strong>的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。<br>实现原型链有一种基本模式，其代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue())         <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.constructor)             <span class="comment">//SuperType</span></span><br></pre></td></tr></table></figure>
<p>通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。即，当一度去模式访问一个实例属性是，首先会在实力上搜索改属性，果果没有找到改属性，则会继续搜索实例的原型，再通过原型链实现集成的请款西，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，条用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype；3）搜索SuperType.prototype，最后一步才会找到该方法。再找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。<br><strong>默认的原型</strong><br>之前的例子中展示的原型链还少一环。所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。所有函数的默认原型都是Object的实例。因此默认内源性都会包含一个内部指针，指向Object.prototype。这也是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。<br><strong>SubType继承了SuperType，而SuperType继承了Object。</strong><br><strong>确定原型和实例关系</strong><br>可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用instanceof操作符。只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就回返回true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>)                <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperType)             <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SubType)               <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>由于原型链的关系，可以说instance是Object、SuperType或SubType中任何一个类型的实例。<br>第二种方法是使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型。因此isPrototypeOf()方法也会返回true：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance))     <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance))  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(SubType.prototoye.insPrototypeOf(instance))   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>谨慎的定义方法</strong><br>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue())              <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个继承SuperType的对象对getSuperValue()的引用未发生改变</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anSubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.anSubProperty = <span class="string">'hhh'</span></span><br><span class="line">&#125;</span><br><span class="line">anSubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">anSubType.prototype.getanSubProperty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.anSubProperty</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anInstance = <span class="keyword">new</span> anSubType()</span><br><span class="line"><span class="built_in">console</span>.log(anInstance.getSuperValue())             <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>当通过SubType的实例调用getSuperValue()时，调用的就是这个重新定义的方法；但通过SuperType的实例调用getSuperValue()时，还会继续调用原来的那个方法。<br>这里要格外注意的时，<strong>必须在用SuperType的实例替换原型之后，再定义这两个方法。</strong><br>除默认原型外，其他实例中不包含指向构造函数的指针，这也就是图6-5中展现出的形式，即SubType.prototype不包含constructor属性，因为它是由SuperType生成的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(SubType.prototype.constructor)               <span class="comment">//SuperType</span></span><br></pre></td></tr></table></figure>
<p>还有一点要注意，即在通过原型链实现继承，不能使用对象字面量创建原型方法，因为这样做就会重写原型链:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    getSubValue: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">    &#125;,</span><br><span class="line">    getSuperValue: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue())               <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>以上代码展示了刚刚把SuperType的实例赋值给原型链，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，一次原型链已经被切断。<br><strong>此处继承和通过原型构造实例的对象字面量方式的区别与联系在于：</strong></p>
<p><strong>原型链的问题</strong><br>原型链虽然很强大，可以用它来实现继承，但也存在一些问题。其中最主要的问题来自包含引用类型值的原型。包含引用类型值的原型属性会被所有实例共享，这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType()</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)            <span class="comment">//red, blue, green, black</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)            <span class="comment">//red, blue, green, black</span></span><br></pre></td></tr></table></figure>
<p>原型链的第二个问题是：在创建i之类性的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>在解决原型中包含引用类型值所带来问题的过程中，开始使用一种叫做借用构造函数的技术。其基本思想为在子类型构造函数的内部调用超类型构造函数。**函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）创建的对象上执行构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType()</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)</span><br></pre></td></tr></table></figure>
<p>代码中注释”继承了SuperType”那一行代码借调了超类型的构造函数。通过使用call()方法和apply()方法，实际上是在新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就回在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码（实际上利用this绑定到新对象），由此，SubType的每个实例就都会具有自己的colors属性的副本。<br><strong>传递函数</strong><br>相对于原型链而言，借用构造函数有一个很大的优势： 即可以在子类型构造函数中向超类型构造函数传递参数，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>)</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.name)                   <span class="comment">//Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age)                    <span class="comment">//19</span></span><br></pre></td></tr></table></figure>
<p>以上代码中的SuperType只接收一个参数name，该参数会直接赋给一个属性，在SubType构造函数内部调用SuperType构造函数时，实际上是为SubType的实例设置了name属性。为保证SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。<br><strong>借用构造函数的问题</strong><br>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题————方法都在构造函数中定义，因此无法进行函数复用。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术结合到一起。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">19</span>)</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)</span><br><span class="line">instance1.sayName()</span><br><span class="line">instance1.sayAge()</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">17</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)</span><br><span class="line">instance2.sayName()</span><br><span class="line">instance2.sayAge()</span><br></pre></td></tr></table></figure>
<p>instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>该方式的基本想法为借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        F.prototype = o</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象左右这个构造函数的原型，最后返回了这个临时类型的新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'shelby'</span>, <span class="string">'court'</span>, <span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person)</span><br><span class="line">anotherPerson.name = <span class="string">'Greg'</span></span><br><span class="line">anotherPerson.friends.push(<span class="string">'rob'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person)</span><br><span class="line">yetAnotherPerson.name = <span class="string">'linda'</span></span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">'barbie'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.friends)                    <span class="comment">//'shelby', 'court', 'van', 'rob'</span></span><br></pre></td></tr></table></figure>
<p>实际上，上述代码相当于又创建了person的两个副本<br>ECMAScript5通过Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()和Object()方法的行为相同。(<strong>注意基本数据类型和引用类型的区别</strong>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'shelby'</span>, <span class="string">'count'</span>, <span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person)</span><br><span class="line">aontherPerson.name = <span class="string">'Greg'</span></span><br><span class="line">anotherPerson.friends.push(<span class="string">'Rob'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person)</span><br><span class="line">yetAnotherPerson.name = <span class="string">'Linda'</span></span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">'Barbie'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.friends)                <span class="comment">//'shelby', 'count', 'van', 'Rob', 'Barbie'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    name: <span class="string">'nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'shelby'</span>, <span class="string">'count'</span>, <span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">'greg'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name)                <span class="comment">//greg</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson)                     <span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person)                            <span class="comment">//&#123; name: 'nicholas', friends: [ 'shelby', 'count', 'van' ] &#125;</span></span><br></pre></td></tr></table></figure>
<p>在没必要使用构造函数，只想让一个对象与另一个对象保持类似的情况西，原型式继承完全可以胜任。不过，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承是与原型式继承相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即船舰一个仅用于封装击沉过程的函数，该函数在内部以某种愤怒时来增强对象，最后再像真的是他做了所有工作一样返回对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object(original)</span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'shelby'</span>, <span class="string">'courts'</span>, <span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person)</span><br><span class="line">anotherPerson.sayHi()</span><br></pre></td></tr></table></figure>
<p>使用寄生式继承来为对象添加函数会由于不饿能做到函数复用而降低效率；这一点与构造函数类似</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>前面说过，组合继承是javaScript最常用的集成模式；不过，也有不足。组合继承最大的问题就是无论什么请款下，都会调用两次超类型构造函数：一次实在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例，但不得不再调用子类型构造函数时重写这些属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Supertype</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name)                   <span class="comment">//调用第二次构造函数，重写SubType原型SuperType中的name和colors属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()              <span class="comment">//调用第一次构造函数</span></span><br><span class="line">SubType.prototype.constructor = SubType</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形成来继承方法。其背后的思路是：不必为了指定子类型的原型而调用超类型的构造函数，所需的无非是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.ptototype)</span><br><span class="line">    prototype.constructor = subType</span><br><span class="line">    subType.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/%E4%BA%8B%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/%E4%BA%8B%E4%BB%B6/" class="post-title-link" itemprop="url">事件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 10:04:36 / Modified: 11:23:05" itemprop="dateCreated datePublished" datetime="2020-04-26T10:04:36+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JavaScript与HTML之间的交互是通过事件实现的。<strong>事件，就是文档或浏览器窗口中发生的一些特定交互瞬间。</strong>可以使用侦听器（或处理程序）来订阅事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式。支持页面的行为与页面的外观之间的松散耦合。</p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>IE的事件流叫做事件冒泡（event bubbling），即事件开始时有最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>事件捕获的思想是不太具体的节点更早接收到事件，具体的节点最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。老版本的浏览器对事件捕获不支持。</p>
<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。</p>
<p>在DOM事件流中，实际的目标（<div>元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从document到<html>再到<body>后就停止了。下一个阶段是“处于目标阶段，于是事件在<div>上发生，并在事件处理中被看成冒泡阶段的一部分。然后冒泡阶段发生，事件又传回文档。</p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>事件就是用户或浏览器自身执行的某种动作。诸如click、load和mouseover，都是事件的名字。而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以“on”开头，因此click事件的处理程序就是onclick，load事件的处理程序就是onload。</p>
<h3 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h3><p>某个元素支持的每种事件，都可以使用一个与响应事件处理程序的同名HTML特性来指定。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">onclick</span>=<span class="string">"alert('Click')"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样指定时间处理程序有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"click me"</span> onclick=<span class="string">"alert(event.type)"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>通过event变量，可以直接访问事件对象，不用自己定义它，也不用从函数的参数列表中读取。<br>在这个函数内部，this值等于事件的目标元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(event.type)"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于这个动态函数，在它内部，可以像访问局部变量一样访问document及该元素本身的成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(<span class="built_in">document</span>) &#123;</span><br><span class="line">        <span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 元素属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是由JavaScript底层实现，不需要开发者编写。<br>由此，可以更便利的访问自己的属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(value)"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果当前元素是一个表单输入元素，则作用域中还会包含访问表单元素（父元素）的入口，这个函数就变成了如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(<span class="built_in">document</span>) &#123;</span><br><span class="line">        <span class="keyword">with</span>(<span class="keyword">this</span>.form) &#123;</span><br><span class="line">            <span class="keyword">with</span>(<span class="keyword">this</span>)</span><br><span class="line">            <span class="comment">// 元素属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这样扩展作用域的方式，无非就是想让事件处理程序无需引用表单元素就能访问其他表单字段</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Echo Username"</span> <span class="attr">onclick</span>=<span class="string">"alert(username.value)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不过在HTML中指定事件处理程序有两个缺点。首先，存在一个时间差问题。因为用户可能会在HTML元素已出现在页面上就触发相应的事件，但当时事件处理程序可能不具备执行条件（还没有被解析）<br>另一个缺点是，这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。<br>还有就是导致HTML和JavaScript代码紧密耦合。</p>
<h3 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h3><p>通过JavaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。要使用JavaScript指定事件处理程序，首先必须取得一个要操作的对象引用。<br>每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。这种属性的值设置为一个函数，就可以指定事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bin = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Clicked"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这段代码运行之前不会指定事件处理程序，因此如果这些代码在页面中位于按钮后面，就有可能在一段时间内单击没反应。<br><strong>使用DOM0级方法指定的事件处理程序被认为是元素的方法。</strong>因此，这时候的事件处理程序实在元素的作用域中运行；换句话说，程序中的this引用当前元素。<br>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。<br>也可以删除通过DOM0级方法指定的事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><p>“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。所有DOM节点中都包含这两个方法，并且它们都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。<br>要在按钮上click事件添加事件处理程序如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>同时可以添加多个事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>这里为按钮添加了两个事件处理程序，会按照添加它们的顺序触发。<strong>与DOM0级方法一样，这里添加的事件处理程序也是再其依附的元素的作用域中运行。</strong><br>通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；一出事传入的参数与添加处理程序时使用的参数相同。<strong>这也意味着通过addEventListener()添加的匿名函数将无法移除</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventlisterer(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">//无效</span></span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventlisterer(<span class="string">'click'</span>, handler, <span class="literal">false</span>)   <span class="comment">//有效</span></span><br></pre></td></tr></table></figure>

<h3 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h3><p>IE实现了与DOM中类似的两个方法：attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。attachEvent()添加的事件处理程序都会被添加到事件冒泡阶段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'clicked'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>在IE中使用attachEvent()与使用DOM0级方法的主要区别在于事件处理程序的作用域。在使用attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此this等于window。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span> === <span class="built_in">window</span>)   <span class="comment">//true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>attachEvent()方法也可以用来为一个元素添加多个事件处理程序。但执行顺序与DOM2方法相反。<br>使用attachEvent()添加的事件可以通过detachEvent()来移除，条件是必须提供相同的参数。</p>
<p><strong>跨浏览器的事件处理需要检查浏览器对事件的支持程度（DOM0、DOM2或IE）</strong></p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含这所有与事件有关的信息。包括导致事件的元素，事件的类型以及其他与特定事件相关的信息。所有浏览器都支持event对象，但支持方式不同。</p>
<h3 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h3><p>兼容DOM的浏览器会将一个event对象传入到事件处理程序中国。无论指定时间处理程序时使用什么方法（DOM0级或DOM2级），都会传入event对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.type)   <span class="comment">//click</span></span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.type)   <span class="comment">//click</span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>在通过HTML特定定义事件处理程序是，变量event中保存着event对象。以这种方式提供event对象，可以让HTML特性事件处理程序与JavaScript函数执行相同的操作。<br>要阻止特定事件的默认行为，可以使用preventDefault()方法。例如链接的默认行为就是在被单击是会导航到其href特性指定的URL。如果想阻止连接导航这一默认行为，那么通过链接的onclick事件处理程序可以取消它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">'myLink'</span>)</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。例如，直接添加到一个按钮的事件处理程序可以调用stopPropagation(),从而避免触发注册在document.body上面的事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'clicked'</span>)</span><br><span class="line">    event.stopPropagation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'body clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件对象的eventPhase属性，可以用来确定事件当前正位于事件流的那个阶段。如果是在捕获阶段调用的事件处理程序，那么eventPhase等于1；如果事件处理程序处于目标对象上，则eventPhase等于2；如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。尽管“处于目标”发生在冒泡阶段，但eventPhase仍然一直等于2；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.eventPhase)  <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.eventPhase) <span class="comment">//1</span></span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.eventPhase)   <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h3><p>访问DOM的event对象不同，要访问IE中的event对象有几种不同方式，取决于指定时间处理程序的方法。在使用DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> event = <span class="built_in">window</span>.event</span><br><span class="line">    alert(event.type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果事件处理程序时使用attachEvent()添加的，那么就会有一个event对象作为参数被传入事件处理程序函数中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.type)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用attachEvent()的情况下，也可以通过window对象来访问event对象，就像使用DOM0级方法一样。<br>如果是通过HTML特性指定的事件处理程序，那么可以通过一个名叫event的变量来访问event对象（与DOM中的事件模型相同）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(event.type)"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标。故而，最好还是使用event.srcElement比较保险。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>)  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.srcElement === <span class="keyword">this</span>)       <span class="comment">//false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在第一个事件处理程序中（使用DOM0级方法指定的），srcElement属性等于this，但在第二个事件处理程序中，这两者的值不相同。<br>returnValue属性相当于DOM中的preventDefault()方法，它们的作用都是取消给定事件的默认行为。只要将returnValue设置为false，就可以阻止默认行为。</p>
<h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有时间。例如，click事件会一直冒泡到document层次。也就是说，我们可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</p>
<h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><p>每当事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的JavaScript代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。可以使用事件委托技术，显示建立连接数量。另外，再不需要的时候移除事件处理程序，也是解决这个问题的一种方案。内存中留有那些过时不用的“空事件处理程序”，也是造成Web应用程序内存与性能问题的主要原因。<br>两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有时间处理程序的元素时。可能是通过纯粹的DOM操作，例如使用removeChild()和replaceChild()方法，但更多地是发生在使用innerHTML替换页面中某一部分。如果带有时间处理程序的元素被innerHTML删除了，那么原来添加到元素中的事件处理程序极有可能无法被当做垃圾回收。<br>这种情况下，当知道某个元素即将被移除，手动移除事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn")</span></span><br><span class="line"><span class="string">btn.onclick = function() &#123;</span></span><br><span class="line"><span class="string">    btn.onclick = null</span></span><br><span class="line"><span class="string">    document.getElementById('</span>myDiv<span class="string">').innerHTML = '</span>Processing...<span class="string">'</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>另一种情况就是卸载页面的时候。如果页面卸载之前没有清理干净事件处理程序，那么就会滞留在内存中。每次加载完页面再卸载页面时（可能是在两个页面间来回切换，也可以是单击了刷新按钮）内存中直流的对象数目就会增加，因为事件处理程序占用的内存并没有被释放。<br>这种情况最好的做法是在页面卸载之前，通过onunload事件处理程序移处所有事件处理程序。</p>
<h2 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h2><p>事件，就是网页中某个特别值得关注的瞬间。事件经常由用户操作或通过其他浏览器功能来触发。<br>事实上，可以使用JavaScript在任意时刻来触发特定的事件，而此时的事件就如同浏览器创建的事件一样。也就是所，这些事件通浏览器创建的事件一样可以冒泡，也可以指定事件处理程序。</p>
<h3 id="DOM中的事件模拟"><a href="#DOM中的事件模拟" class="headerlink" title="DOM中的事件模拟"></a>DOM中的事件模拟</h3><p>可以在document对象上使用creatEvent方法创建event对象。这个方法接收一个参数，即表示要创建的事件类型的字符串。在DOM2级中，所有这些字符串都使用英文复数形式，而在DOM3级中都变成了单数。<br>这个字符串可以是下列几个字符串之一。<br>1.UIEvents：一般化UI事件。鼠标事件和键盘事件都继承UI事件。<br>2.MouseEvents：一般化的鼠标事件。<br>3.MutationEvents：一般化的DOM变动事件<br>4.HTMLEvents：一般化的HTML事件 如focus…</p>
<p>模拟事件步骤：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domElement = <span class="built_in">document</span>.getElementById(<span class="string">'someId'</span>)</span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.creatEvent(<span class="string">"MouseEvents"</span>)</span><br><span class="line">event.initMouseEvent(<span class="string">'props...'</span>)  <span class="comment">//不同方法事件参数不一样</span></span><br><span class="line">domElement.dispatchEvent(event)   <span class="comment">//等同于触发了initMouseEvent中type设置的事件</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义DOM事件</strong><br>DOM3级还定义了“自定义事件”。自定义事件不是由DOM原生触发的，它的目的是让开发人员创建自己的事件。要创建新的自定义事件，可以调用createEvent(‘CustomEvent’)。返回的对象有一个名为initCustomEvent()的方法，接收如下4个参数。<br>1.type(字符串)：触发的事件类型，可入“keydown”<br>2.bubble(布尔值)：表示事件是否应该冒泡<br>3.cancelable(布尔值)：表示事件是否可以取消<br>4.detail(对象)：任意值，保存在event对象的detail属性中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"><span class="keyword">var</span> event;</span><br><span class="line">EventUtil.addHandler(div, <span class="string">'myevent'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'div:'</span> + event.detail)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">'myevent'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'document:'</span> + event.detail)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">'CustomEvents'</span>, <span class="string">'3.0'</span>)) &#123;</span><br><span class="line">    event = <span class="built_in">document</span>.createEvent(<span class="string">'CustomEvent'</span>)</span><br><span class="line">    event.initCustomEvent(<span class="string">'myevent'</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">'hello world'</span>)</span><br><span class="line">    div.dispatchEvent(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子创建了一个冒泡事件‘myevent’。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/" class="post-title-link" itemprop="url">跨域资源共享</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 10:04:36 / Modified: 15:57:58" itemprop="dateCreated datePublished" datetime="2020-04-26T10:04:36+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通过XHR实现Ajax通信的一个主要限制，来源于跨域安全策略（同源策略）。</p>
<h2 id="同源的定义"><a href="#同源的定义" class="headerlink" title="同源的定义"></a>同源的定义</h2><p>如果两个URL的协议（protocol）、端口（port）（如果有指定的话）和域名（host）都相同的话，则这两个URL是同源。这个方案也被称为‘协议/主机/端口元组’，或者直接是‘元组’。（‘元组’是指一组项目构成的整体，‘三重/四重/五重/等的通用形式）。<br>一下给出了与URL <a href="http://store.company.com/dir/page.html的源进行对比的示例。" target="_blank" rel="noopener">http://store.company.com/dir/page.html的源进行对比的示例。</a></p>
<p>1.<a href="http://store.company.com/dir2/other.html" target="_blank" rel="noopener">http://store.company.com/dir2/other.html</a><br>同源，只有路径不同<br>2.<a href="http://store.company.com/dir/inner/another.html" target="_blank" rel="noopener">http://store.company.com/dir/inner/another.html</a><br>同源，只有路径不同<br>3.<a href="https://store.company.com/secure.html" target="_blank" rel="noopener">https://store.company.com/secure.html</a><br>不同源，协议不同<br>4.<a href="http://store.company.com:81/dir/etc.html" target="_blank" rel="noopener">http://store.company.com:81/dir/etc.html</a><br>不同源，端口不同（http默认是80端口）<br>5.<a href="http://news.company.com/dir/other.html" target="_blank" rel="noopener">http://news.company.com/dir/other.html</a><br>不同源，主机（域名）不同</p>
<h2 id="源的继承"><a href="#源的继承" class="headerlink" title="源的继承"></a>源的继承</h2><p>在页面中通过 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。</p>
<p>例如，about:blank 通常作为父脚本写入内容的新的空白弹出窗口的 URL（例如，通过  Window.open()  ）。 如果此弹出窗口也包含 JavaScript，则该脚本将从创建它的脚本那里继承对应的源。</p>
<p>注意：在Gecko 6.0之前，如果用户在位置栏中输入 data URLs，data URLs 将继承当前浏览器窗口中网页的安全上下文。</p>
<p>data：URLs 获得一个新的，空的安全上下文。</p>
<h2 id="源的更改"><a href="#源的更改" class="headerlink" title="源的更改"></a>源的更改</h2><p>满足某些限制条件的情况下，页面是可以修改它的源。脚本可以将documet.domain的值设置为其当前域的父域。如果将其设置为当前域的父域，则这个较短的父域将用于后续源检查。<br>例如，假设http://<strong>store.company.com</strong>/dir/other.html文档中的一个脚本执行以下语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">'company.com'</span></span><br></pre></td></tr></table></figure>
<p>这条语句执行以后，页面将会成功地通过与http://<strong>company.com</strong>/dir/page.html的同源检测（假设<a href="http://company.com.dir/page.html将其document设置为“company.com&quot;,已表明它希望允许这样做。然而，company.com" target="_blank" rel="noopener">http://company.com.dir/page.html将其document设置为“company.com&quot;,已表明它希望允许这样做。然而，company.com</a> 不能设置 document.domain 为 othercompany.com，因为它不是 company.com 的父域。</p>
<h2 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h2><p>通过XHR实现Ajax通信的一个主要限制，来源于跨域安全策略。默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。<br>CORS（Cross-Origin Resource Sharing，跨源资源共享），定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或相应应该是成功，还是失败。<br>比如一个简单的使用GET或POST发送的请求，它没有自定义的头部，而主体内容是text/plain。在发送请求时，需要给它附加一个额外的Origin头部，其中包含情感求页面的源信息（协议、域名和端口），以便服务器进行根据这个头部信息来决定是否给予响应。<br>  Origin: <a href="http://www.nczonline.net" target="_blank" rel="noopener">http://www.nczonline.net</a><br>如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发<strong><em>）<br>  Access-Control-Allow-Origin: <a href="http://www.nczonline.net" target="_blank" rel="noopener">http://www.nczonline.net</a><br>如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。*</em></strong>注意，请求和响应都不包含cookie信息。</p>
<h3 id="IE对CORS的实现"><a href="#IE对CORS的实现" class="headerlink" title="IE对CORS的实现"></a>IE对CORS的实现</h3><p>IE8中引入了XDR（XDomainRequest）类型。这个对象与XHR类似，但能实现安全可靠的跨域通信。XDR对象的安全机制部分实现了W3C的CORS规范。一下是XDR与XHR的一些不同之处。<br>1.cookie不会随请求发送，也不会随响应返回<br>2.只能设置请求头部信息的Content-Type字段<br>3.不能访问响应头部信息<br>4.只支持GET和POST请求。<br>这些变化使CSRF（Cross-Site Request Forgey，跨站点请求伪造）和XSS（Corss-Site Scripting，跨站点脚本）的问题得到了缓解。被请求的资源可以根据它认为合适的任意数据（用户代理、来源页面等）来决定是否设置Access-Control-Allow-Origin头部。作为请求的一部分，Origin头部的值表示请求的来源域，以便远程资源明确地识别XDR请求。<br>XDR对象的使用方法与XHR对象非常相似。也是创建一个XDomainRequest的实例，调用open()方法，再调用send()方法。但与XHR对象的open()方法不同，XDR对象的open()方法只接收两个参数：请求的类型和URL。<br>所有XDR请求都是异步执行的，不能用它来创建同步请求。请求返回后，会触发load事件，响应的数据也会保存在reponseText属性中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest()</span><br><span class="line">xdr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(xdr.responseText)</span><br><span class="line">&#125;</span><br><span class="line">xdr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xdr.open(<span class="string">'get'</span>, <span class="string">'http://www.somewhere-else.com/page/'</span>)</span><br><span class="line">xdr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>在请求返回前调用abort()方法可以终止请求：<br>xdr.abort()   //终止请求</p>
<p>与XHR一样XDR对象也支持timeout属性以及ontimeout事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest()</span><br><span class="line">xdr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(xdr.responseText)</span><br><span class="line">&#125;</span><br><span class="line">xdr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xdr.timeout = <span class="number">1000</span>;</span><br><span class="line">xdr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'timeout'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xdr.open(<span class="string">'get'</span>,<span class="string">'url'</span>)</span><br><span class="line">xdr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>为支持POST请求，XDR对象提供了contentType属性，用来表示发送数据的格式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest()</span><br><span class="line">xdr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(xdr.responseText)</span><br><span class="line">&#125;</span><br><span class="line">xdr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xdr.timeout = <span class="number">1000</span>;</span><br><span class="line">xdr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'timeout'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xdr.open(<span class="string">'post'</span>,<span class="string">'url'</span>)</span><br><span class="line">xdr.contentType = <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">xdr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>这个属性是通过XDR对象影响头部信息的唯一方式</p>
<h3 id="其他浏览器对CORS的实现"><a href="#其他浏览器对CORS的实现" class="headerlink" title="其他浏览器对CORS的实现"></a>其他浏览器对CORS的实现</h3><p>其他浏览器都通过XMLHttpRequest对象实现了对CORS的原生支持。在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。要请求位于另一个域中的资源，使用标准的XHR对象并在open()方法中传入绝对URL即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR()</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">'error'</span> + xhr.status)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.somewhere-else.com/page/'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>由于无论同源请求还是跨源请求都使用相同的接口，因此对于本地资源，最好使用相对URL，在访问远程资源时再使用绝对URL。这样做能消除歧义，避免出现限制访问头部或本地cookie信息等问题。</p>
<h3 id="Preflighted-Requests"><a href="#Preflighted-Requests" class="headerlink" title="Preflighted Requests"></a>Preflighted Requests</h3><p>CORS通过一种叫做Prefilghed Request的透明服务器验证机制支持开发人员使用自定义的头部、GET或POST之外的方法，以及不同类型的主体内容。在使用下列高级选项来发送请求时，就会像服务器发送一个Preflight请求。这种请求使用OPTIONS方法，发送下列头部。<br>1.Origin：与简单的请求相同<br>2.Access-Control-Request-Method：请求自身使用的方法。<br>3.Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号分隔。<br>以下是一个带有自定义头部NCZ的使用POST方法发送的请求。<br>Origin: <a href="http://www.nczonline.net" target="_blank" rel="noopener">http://www.nczonline.net</a><br>Access-Control-Request-Method: POST<br>Access-Control-Request-Headers: NCZ<br>发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通。<br>1.Access-Control-Allow-Origin：与简单的请求相同。<br>2.Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔<br>3.Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔<br>4.Access-Control-Max-Age：应该讲这个Preflight请求缓存多长时间</p>
<p>例如：<br>Access-Control-Allow-Origin: <a href="http://www.nczonline.net" target="_blank" rel="noopener">http://www.nczonline.net</a><br>Access-Control-Allow-Methods: POST, GET<br>Access-Control-Allow-Headers: NCZ<br>Access-Control-Max-Age: 172800<br>Preflight请求结束后，结果将按照响应中指定的时间缓存起来</p>
<h3 id="带凭据的请求"><a href="#带凭据的请求" class="headerlink" title="带凭据的请求"></a>带凭据的请求</h3><p>默认情况下，跨域请求不提供凭据（cookie、HTTP认证及客户端SSL证明等）。通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据。如果服务器接收带凭据的请求，就会用下面的HTTP头部来响应。<br>Access-Control-Allow-Credentials: true<br>如果发送的是带凭据的请求，单服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给JavaScript（于是，responseText中将是空字符串，status的值为0，而且会调用onerror()事件处理程序）。另外服务器还可以在Preflight响应中发送这个HTTP头部，表示允许源发送带凭据的请求。</p>
<h2 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h2><p>在CORS出现以前，要实现跨域Ajax通信破费一些周折。开发人员想出了一些办法，利用DOM中能够执行跨域请求的功能，在不依赖XHR对象的情况下也能发送某种请求。虽然CORS技术已经无处不在，但开发人员自己发明的技术仍然被广泛使用，因为不需要修改服务器端代码。</p>
<h3 id="子域和父域跨域"><a href="#子域和父域跨域" class="headerlink" title="子域和父域跨域"></a>子域和父域跨域</h3><p>修改脚本的documet.domain为同一域名实现跨域（必须在同一父域下）。</p>
<h3 id="图像Ping"><a href="#图像Ping" class="headerlink" title="图像Ping"></a>图像Ping</h3><p>上述第一种跨域请求技术是使用<img>标签。一个网页可以从任何网页中加载图像，不用担心跨域不跨域。这也是在线广告跟踪浏览量的主要方式。也可以动态地创建图像，使用它们的onload和onerror事件处理程序来确定是否接收到了响应。<br>动态创建图像经常用于图像Ping。图像Ping是服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符形式发送的，而响应可以是任意内容，但通常是像素图或204响应。通过图像Ping，浏览器得不到任何具体的数据，但通过真挺load和error事件，能知道响应是什么时候接收到的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'done'</span>)</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">'http://www.example.com/test?name=Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>这里创建了一个Image的实例，然后将onload和onerror事件吹程序指定为同一个函数。这样无论是什么响应，只要请求完成，就能得到通知。**请求从设置src属性那一刻开始，而这个例子在啊请求中发送了一个name参数。<br>图像Ping最常用于跟踪用户点击页面活动太广告曝光次数。图像Ping有两个主要的缺点，一是只能发送GET请求，二是无法访问服务器的响应文本。因此图像Ping只能用于浏览器与服务器之间额单向通信。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是JSON with padding（填充式JSON或参数式JSON）的简写，是应用JSON的一种新方法，再后来的Web服务中非常流行。JSONP看起来与JSON差不多，只不过是包含在函数调用中的JSON就像下面这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(&#123;<span class="string">'name'</span>: <span class="string">'Nicholas'</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。下面是一个典型的JSONP请求<br><a href="http://freegeoip.net/json/?callback=handleResponse" target="_blank" rel="noopener">http://freegeoip.net/json/?callback=handleResponse</a><br>这个URL是在请求一个JSONP地理定位服务。通过查询字符串来指定JSONP服务的回调函数，就像上面的URL所示，这里指定的回调函数的名字叫handlerResponse()<br>JSONP是通过动态script标签来使用，使用时可以为src属性指定一个跨域URL。这里的script元素与img元素类似，都有能力不受限制的从其他域中加载资源。因为JSONP是有效的JavaScript代码，所以在请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'you are at ip address'</span> + response.ip + <span class="string">'which is in'</span> resoponse.city + <span class="string">','</span> + response.region_name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">script.src = <span class="string">'http://freegeoip.net/json/?callback=handleResponse'</span></span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, documetn.body.firstChild)</span><br></pre></td></tr></table></figure>
<p>这个例子通过查询地理定位服务来显示IP地址和位置信息。<br>JSONP之所以在开发人员中极为流行，只要原因是它非常简单易用。与图像Ping相比，它的优点在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。不过，JSONP也有两点不足。<br>首先，JSONP是从其他域中加载代码执行。如果其他域不安全，很可能会在响应夹带一些恶意代码，而此时除了完全放弃JSONP调用之外，没有办法追究。<br>其次要确定JSONP请求是否失败并不容易。虽然HTML5给‘script’元素新增了一个onerror事件处理程序，但目前还没有得到任何浏览器支持。为此，开发人员不得不使用计时器检测指定时间内是否接收到了响应。但就算这样也不能尽如人意，毕竟不是每个用户上网的速度和带宽都一样。</p>
<h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>Comet值得是一种更高级的Ajax技术（经常也有人称为‘服务器推送’）。Ajax是一种从页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。Comet能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。<br>有两种实现Comet的方式：长轮询和流。长轮询是传统轮询（也称短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据。<br>长轮询把短轮询颠倒了一下。页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可以发送。发送完数据时候，浏览器关闭连接，随即又发起一个到服务器的新请求。<br>无论长轮询还是短轮询，浏览器都要在接收数据之前，先发起对服务器的链接。两者最大的区别在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询则是等待发送响应。轮询的优势是所有浏览器都支持，因为使用XHR对象和setTimeout()就能实现。<br>第二种流行的Comet实现是HTTP流。流不同于上述两种轮询方式，因为它在页面的整个生命周期内只是用一个HTTP链接。具体来说就是浏览器向服务器发送一个请求，而服务器保持链接打开，然后周期性的向浏览器发送数据。<br>在Firefox和Chorme中，通过侦听readystatechange事件及readyState的值是否为3，就可以利用XHR对象实现HTTP流。在上述这些浏览器中，随着不断从服务器接收数据，readyState的值会周期性地变为3.dangreadyState值变为3时，responseText属性中就会保存接收到的所有数据。此时，就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。使用XHR对象实现HTTP流的典型代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStreamingClinet</span>(<span class="params">url, progress, finished</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    <span class="keyword">var</span> received = <span class="number">0</span>;</span><br><span class="line">    xhr.open(<span class="string">'get'</span>, url, <span class="literal">true</span>)</span><br><span class="line">    xrh.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">3</span>) &#123;</span><br><span class="line">            result = xhr.responseText.substring(received)</span><br><span class="line">            received +=result.length</span><br><span class="line">            progress(result)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">            finished(xhr.responseText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> xhr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> client = creatStreamingClient(<span class="string">'streaming.php'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Received: '</span> + data)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'done'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个createStreamingClient()函数接收三个参数：要连接的URL、在接收到数据时调用的函数。有时候，当连接关闭时，很有可能需要重新建立，所以关注连接，所以关注连接什么时候关闭还是有必要的。<br>只要readystatechange事件发生，而且readyState值为3，就对responseText进行分割以取得最新数据。这里的received变量用于记录已经处理了多少个字符，每次readyState值为3时都递增。然后，通过process回调函数来处理传入的新数据。而当readyState值为4时则执行finished回调函数，传入响应返回的全部内容。</p>
<h3 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h3><p>SSE（Serve-Sent Events，服务器发送事件）是围绕只读Comet交互推出的API或者模式。SSEAPI用于创建到服务器的单向连接，服务器通过这个链接可以发送任意数量的数据。服务器响应的MIME类型必须是text/event-stream,而且是浏览器中的JavaScript API能解析格式输出。SSE支持短轮询、长轮询和HTTP流，而且能在断开连接时自动确定合适重新连接。有了这么简单实用的API，再实现Comet就容易多了。</p>
<p>1.SSE API<br>SSE的JavaScript API与其他传递消息的JavaScript API很相似。要预定新的事件流，首先要创建一个新的EventSource对象，并传进一个入口点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> EVENTSource(<span class="string">'myevents.php'</span>)</span><br></pre></td></tr></table></figure>
<p>注意，传入的URL必须与创建对象的页面同源（相同的URL模式、域以及端口）。EventSource的实例有一个readyState属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2表示关闭了连接。<br>另外，还有以下三个事件。<br>1.open：在建立连接时触发<br>2.message：在从服务器接收到新事件时触发。<br>3.error：在无法建立连接时触发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器发回的数据以字符串形式保存在event.data中。默认情况下，eventsource对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味着SSE社和长轮询和HTTP流。如果想强制立即断开连接并且不再重新连接，可以调用close()方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source.close()</span><br></pre></td></tr></table></figure>

<p>2.事件流<br>所谓的服务器事件会通过一个持久的HTTP响应发送，这个响应的MIME类型为text/event-stream。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀data：，例如<br>data: foo</p>
<p>data: bar</p>
<p>data: foo<br>data: bar<br>对于以上响应，事件流中的第一个message事件返回的event.data值为foo，第二个message事件返回的event.data值为bar，第三个message事件返回的event.data值为foo\nbar。对于多个连续的以data:开头的数据行，将作为多端数据解析，每个值之间以一个换行符分隔。只有在包含data:的数据行后面有空行时，才会触发message事件，因此在服务器上生成事件流时不能忘了多添加这一行。<br>通过id:前缀可以给特定的事件指定一个关联的ID，这个ID行位于data:行前面或后面<br>data: foo<br>id: 1<br>设置了ID后，EventSource对象上会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个包含名为Last-Event-ID的特殊HTTP头部的请求，以便服务器知道下次该触发哪个事件。再多次连接的事件流中，这种机制可以确保浏览器以正确的顺序接收到连接的数据段。</p>
<h3 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h3><p>Web Sockets的目标是在一个单独的持久连接上提供全双工、双向通信。在JavaScript中创建了Web Socket之后，会有一个HTTP请求发送到浏览器以发起连接。在取得服务器响应之后，建立的链接会使用HTTP升级从HTTP协议交换为Web Socket协议，就是说，使用标准的HTTP服务器无法实现Web Sockets，只有支持这种协议的专门服务器才能正常工作。<br>由于Web Sockets使用了自定义的协议，所以URL模式也略有不同。未加密的链接不再是http://,而是ws://。加密的链接也不是https://,而是wss://。在使用Web Socket URL时，必须带着这个模式，因为将来还有可能支持其他模式。<br>使用自定义协议而非HTTP协议的好处是，能够在客户端和服务器之间发送非常少量的数据，而不必担心HTTP那样的字节级的开销。由于传递的数据包很小，因此Web Sockets非常适合移动应用。毕竟对移动应用而言，带宽和网络延迟都是关键问题。使用自定义协议的缺点在于，指定协议的时间比指定JavaScript API的时间还要长。</p>
<p>1.Web Sockets API<br>要创建Web Socket，先实例化一个WebSocket对象并传入要连接的URL</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://www.example.com/server.php'</span>)</span><br></pre></td></tr></table></figure>
<p>注意必须给WebSocket构造函数传入绝对URL。同源策略对Web Sockets不适用，因此可以通过它打开到任何站点的链接。至于是否会与某个域中的页面通信，则完全取决于服务器。（通过握手信息就可以知道请求来自何方）</p>
<p>实例化了WebSocket对象后，浏览器就会马上尝试创建连接。与XHR类似，WebSocket也有一个表示当前状态的readyState属性，取值如下：<br>WebSocket.OPENING(0):正在建立连接<br>WebSocket.OPEN(1)：已经建立连接<br>WebSocket.CLOSING(2)：正在关闭连接<br>WebSocket.CLOSE(3)：已经关闭连接</p>
<p>WebSocket没有readystatechange事件，步步哦有其他事件，对应着不同的状态。readyState的值永远从0开始。<br>要关闭Web Socket连接，可以任何时候调用close()方法。<br>socket.close()<br>调用了close()之后，readyState的值立即变为2（正在关闭），而在关闭连接后就会变为3.</p>
<p>2.发送和接收数据<br>Web Socket打开之后，就可以通过链接发送和接收数据。要向服务器发送数据，使用send()方法并传入任意字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://www.example.com/server.php'</span>)</span><br><span class="line">socket.send(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>
<p>因为Web Socket只能通过连接发送纯文本数据，所以对于复杂的数据结构，在通过连接发送之前，必须进行序列化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> Data(),</span><br><span class="line">    text: <span class="string">'hello world'</span>,</span><br><span class="line">    clientId: <span class="string">'asdfp'</span></span><br><span class="line">&#125;</span><br><span class="line">socket.send(<span class="built_in">JSON</span>.stringify(message))</span><br></pre></td></tr></table></figure>
<p>接下来，服务器要读取其中的数据，就要解析接收到的JSON字符串。<br>当服务器向客户端发来消息时，WebSocket对象就会触发message事件。这个message事件与掐他产地消息的协议类似，也是吧返回的数据保存在event.data属性中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与通过send()发送到服务器的数据一样，event.data中返回的数据也是字符串，需要手工解析。</p>
<p>3.其他事件<br>WebSocket对象还有其他三个事件，在连接声明追的不同阶段触发<br>open：在成功建立连接时触发<br>error：在发生错误时触发，连接不能持续<br>close：在连接关闭时触发。<br>WevScket对象不支持DOM2级事件侦听器，因此必须使用DOM0级语法分别定义每个事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'wsurl'</span>)</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'connect on'</span>)</span><br><span class="line">&#125;</span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'close'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vue开发模式和生产模式下跨域"><a href="#vue开发模式和生产模式下跨域" class="headerlink" title="vue开发模式和生产模式下跨域"></a>vue开发模式和生产模式下跨域</h3><p>开发模式<br>找到并打开config文件夹下的index.js,做如下配置proxyTable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">  <span class="string">'/api'</span>: &#123;</span><br><span class="line">    target: <span class="string">'http://xxxxxxxx.com/api'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">'^/api'</span>: <span class="string">'/api'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明配置中的target后面内容为后端人员提供的数据接口。</span></span><br><span class="line"><span class="comment">//原理就是类似vpn做了一个中转，Node替你去接口请求数据而已</span></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">this</span>.$http.get(<span class="string">'/api/login'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>生产模式<br>将项目部署到nginx服务器，利用nginx做反向代理进行跨域，只需配置nginx文件<br>参考链接 <a href="https://www.cnblogs.com/web-record/p/9467258.html" target="_blank" rel="noopener">https://www.cnblogs.com/web-record/p/9467258.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/Blog/page/2/">2</a><a class="page-number" href="/Blog/page/3/">3</a><a class="extend next" rel="next" href="/Blog/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">蚂蚁</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Blog/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蚂蚁</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Blog/lib/anime.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/Blog/js/utils.js"></script>

<script src="/Blog/js/motion.js"></script>


<script src="/Blog/js/schemes/pisces.js"></script>


<script src="/Blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
