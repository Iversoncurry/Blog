<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-数组类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time datetime="2020-04-26T03:26:13.286Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/">引用类型之数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>除Object之外，Array类型是ECMAScript中最常用的类型，与其他语言不同，数组中可以保存任何类型的数据；同时数组大小可以随意调整，不同于java，当数组长度确定时不能再进行改变；Array 存储的对象能动态增多和减少，并且可以存储任何JavaScript值。</p>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>1.利用Array构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(args)</span><br></pre></td></tr></table></figure>
<p>其中args可以为空，也可以为一个数值或是字符串，当为数值时，生成一个长度为该数值的数组，当为字符串时，生成一个含有该字符串的数组；其中，new可以省略<br>2.利用数组字面量表示法进行创建</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>]</span><br></pre></td></tr></table></figure>
<p>其中数组中最后一项不要为逗号，如为逗号将产生一个长度不定的数组</p>
<h2 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h2><p>在读取和设置数组的值时，利用方括号并提供相应的数字索引，数字索引是从0开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])</span><br><span class="line">colors[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>通过length属性可以获取数组长度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">23</span>]</span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br></pre></td></tr></table></figure>
<p>对数组的length进行设置时，会改变数组项数，当设置的length大于数组实际长度时，超过的数组位置为undefined，当设置的length小于数组实际长度时，多余的数组会被移除</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">23</span>]</span><br><span class="line">colors.length = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>])</span><br><span class="line">colors.length = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>由此可以利用length属性实现数组的栈方法（构想，还没写😁）</p>
<h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><p>对于同一个网页或者一个全局作用域而言，利用instanceof操作符可以实现数组的检测</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)</span><br></pre></td></tr></table></figure>
<p>但如果网页中包含多个框架，导致存在两个及以上不同全局执行环境，从而导致多个不同版本的Array构造函数，instanceof方法将失效，此时可以利用Array.isArray()方法，该方法是最终确定一个值是否是数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value))</span><br></pre></td></tr></table></figure>

<h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><p>所有对象都有toLocaleString(), toString(), valueOf()方法。其中调用数组的toString()会返回有数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串（调用数组每一项的toString()方法；而调用valueOf()，返回的是数组；toLocaleString()方法调用每一项的toLocaleString()方法，对于alert方法，当其参数为数组时，会先调用数组的toString()方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(color.toString())</span><br><span class="line"><span class="built_in">console</span>.log(color.valueOf())</span><br></pre></td></tr></table></figure>
<p>通过调用数组的join()方法，传入分隔符参数，更改分隔符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(color.join(<span class="string">"||"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p>数组的push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改数组长度；pop()方法从数组末尾移除最后一项，减少数组的length，然后返回移除的项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">var</span> count = color.push(<span class="string">'yellow'</span>, <span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count)</span><br><span class="line">myColor = color.pop()</span><br><span class="line"><span class="built_in">console</span>.log(myColor)</span><br></pre></td></tr></table></figure>

<h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><p>与栈方法相比，队列方法将pop()方法变为shift()方法，该方法移除数组第一项并返回该项，push()方法与栈方法相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">myColor = color.shift()</span><br><span class="line"><span class="built_in">console</span>.log(myColor)</span><br></pre></td></tr></table></figure>

<h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2><p>数组有两个可以直接用来重排序的方法，reverse()和sort()方法。<br>reverse()方法将数组进行倒排</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">values.reverse()</span><br><span class="line"><span class="built_in">console</span>.log(values)</span><br></pre></td></tr></table></figure>
<p>sort()方法默认按升序排列数组，为实现排序，sort()方法会调用每个数组项的toString()方法，然后比较字符串，即使数组里每一项都是数值，sort()方法比较的也是字符串。但有些情况下，通过字符串比较会出现错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>]</span><br><span class="line">values.sort()</span><br><span class="line"><span class="built_in">console</span>.log(values) <span class="comment">//0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
<p>可通过给sort()函数传递一个比较函数作为参数（升序）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>]</span><br><span class="line">values.sort(compare)</span><br><span class="line"><span class="built_in">console</span>.log(values) <span class="comment">//0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
<p>当数组元素为数值类型或其valueOf方法会返回数值类型对象时比较函数可简化为（升序）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value2 - value1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：reverse()和sort()方法都是对原始数组进行修改</p>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。当concat()方法不传入参数时，只是对原数组进行复制并返回副本；当传入参数为一个或多个数组该方法将每个数组的每一项都添加到结果数组中；如果传入的参数不是数组，则值将会被简单添加到结果数组的末尾。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">var</span> color2 = colors.concat(<span class="string">'yellow'</span>, [<span class="string">'black'</span>, <span class="string">'brown'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(color2)</span><br></pre></td></tr></table></figure>
<p>注意concat()方法不改变原始数组。<br>slice()方法能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一个或两个参数，即要返回项的起始和结束位置；若slice()方法只传递一个参数，则返回从该参数指定位置看是到当前数组末尾的所有项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>, <span class="string">'black'</span>, <span class="string">'brown'</span>]</span><br><span class="line"><span class="keyword">var</span> color2 = colors.slice(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> color3 = colors.slice(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(color2)</span><br><span class="line"><span class="built_in">console</span>.log(color3)</span><br></pre></td></tr></table></figure>
<p>注意slice()方法不改变原始数组。<br>splice()方法主要用途时向数组中部插入项：<br>1.删除：可以删除任意数量的的项，需指定2个参数：要删除的第一项的位置和要删除的项数；<br>2.插入：可以向指定位置插入任意数量的项，需提供3个参数：起始位置、0（要删除的项）和要插入的项。最后一个参数可以为任意多项<br>3.替换：可以项指定位置插入任意数量的项，且同时删除任意数量的项，需指定3个参数：其实位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。<br>splice()方法始终返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">var</span> removed = color.splice(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(removed)</span><br><span class="line"></span><br><span class="line">removed = color.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">'yellow'</span>,<span class="string">'orange'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(removed)</span><br><span class="line"></span><br><span class="line">removed = color.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'red'</span>, <span class="string">'purple'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(removed)</span><br></pre></td></tr></table></figure>
<p>splice()方法改变原数组</p>
<h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><p>数组实例有两个位置方法：indexOf()和lastIndexOf()。这两个方法都接收两个参数，要查找的项和表示查找起点位置的索引（可选）。其中，indexOf()方法从起点位置从前向后查找，lastIndexOf()方法从起始点从后向前查找，两个方法返回要查找项在数组中的位置。如果要查找项不在数组中则返回-1.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(number.indexOf(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(number.lastIndexOf(<span class="number">4</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>ECMAScript5为数组定义了5个迭代方法，每个方法接受两个参数：要在每一项上运行的函数和运行该函数的作用域对象—-影响this的值。传入这些方法的函数接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。<br>1.every(): 对数组中的每一项运行给定函数，如果该函数对每一项都返回true则返回true；(当找到不满足条件的项时停止迭代)(不改变原数组)<br>2.filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组；(不改变原数组)<br>3.forEach(): 对数组中的每一项运行给定函数。这个方法没有返回值；本质上与for循环迭代数组一样。 (不改变原数组)<br>4.map(): 对数组中的每一项运行给定函数，返回每次函数调用结果组成的数组；(不改变原数组)<br>5.some(): 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。(当找到满足条件的项时停止迭代) (不改变原数组)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> everyResult = number.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> someResult = number.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> filterResult = number.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> mapResult = number.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line">number.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	number[index] = item*<span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="缩小方法"><a href="#缩小方法" class="headerlink" title="缩小方法"></a>缩小方法</h2><p>reduce()和reduceRight()方法为两个缩小数组方法，这两个方法都会迭代数组的所有项，其中reduce()方法从数组的第一项开始，逐个遍历到最后；而reduceRight()则从数组的最后一项开始，向前遍历到第一项。这连个方法都接收两个参数：一个在每一项上调用的函数和作为缩小基础的初始值（可选）。串给reduce()和reduceRight()函数接收4个参数：前一个值，当前值，想的索引和数组对象，函数返回的任何值都会作为第一个参数自动传给下一项，第一次迭代发生在数组的第二项上，因此第一个参数时数组的第一项，第二个参数就是数组的第二项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(sum)</span><br></pre></td></tr></table></figure>
<p>reduceRight()方法相较reduce()方法区别在于执行的方向不同。</p>
<h2 id="ES6增强的数组功能"><a href="#ES6增强的数组功能" class="headerlink" title="ES6增强的数组功能"></a>ES6增强的数组功能</h2><h3 id="Array-of-方法"><a href="#Array-of-方法" class="headerlink" title="Array.of()方法"></a>Array.of()方法</h3><p>JS语言中存在一个怪异点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> item = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])     <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">1</span>])     <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">item = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"2"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">item = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])     <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">1</span>])     <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">item = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="string">"2"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])     <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">1</span>])     <span class="comment">//"2"</span></span><br></pre></td></tr></table></figure>

<p>ES6中引用Array.of()方法来解决这个问题，该方法类似 Array 构造器，但在使用多个数值参数的时候不会导致特殊结果。Array.of()方法总会创建一个包含所有出入参数的数组，不管参数的数量和类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> item = <span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length)      <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])          <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">1</span>])          <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> item = <span class="built_in">Array</span>.of(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length)      <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])          <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> item = <span class="built_in">Array</span>.of(<span class="string">"2"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length)      <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])          <span class="comment">//"2"</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-from-方法"><a href="#Array-from-方法" class="headerlink" title="Array.from()方法"></a>Array.from()方法</h3><p>该方法将类数组对象转化为数组对象,同时，可以向from传入一个映射函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, (value) =&gt; value + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> number = translate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(number)                  <span class="comment">//2,3,4</span></span><br></pre></td></tr></table></figure>
<p>如果映射函数需要在对象上工作，可以手动传递第三个参数给Array.from()方法，从而<strong>指定映射函数内部</strong>的this值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> diff = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> helper = &#123;</span><br><span class="line">    diff: <span class="number">1</span>,</span><br><span class="line">    add(value) &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="keyword">this</span>.diff)</span><br><span class="line">        <span class="keyword">return</span> value + <span class="keyword">this</span>.diff</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.diff = <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, helper.add, helper) <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, helper.add)         <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers = translate(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers)       <span class="comment">//1     2,3,4   2    4,5,6</span></span><br></pre></td></tr></table></figure>
<p>Array.from()方法不仅可以用于类数组对象，也可以用于迭代对象，这意味着该方法可以将任意包含Symbol.iterator属性的对象转换为数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = &#123;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator] () &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers2 = <span class="built_in">Array</span>.from(numbers, (value)=&gt;value+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers2)</span><br></pre></td></tr></table></figure>
<h3 id="数组上的新方法"><a href="#数组上的新方法" class="headerlink" title="数组上的新方法"></a>数组上的新方法</h3><p>find()与findIndex()方法。ES5中增加了indexOf()和lastIndexOf()方法，从而允许开发者在数组中查找特定值，但仍存在限制。<br>find()和findIndex()方法均接受两个参数：一个回调函数、一个可选值用于指定回调函数内部的this。该回调函数可接受三个参数：数组的某个元素、该元素对应的索引位置以及该数组自身，这与map()和forEach()方法的回调函数所用的参数一致。<strong>该回调函数应当在给定的元素满足你定义的条件时返回true</strong>，而find()和findIndex()方法均会在回调函数第一次返回true时停止查找。find()会返回匹配的值，findIndex()会返回匹配位置的索引。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line"><span class="built_in">console</span>.log(numbers.find(<span class="function"><span class="params">n</span>=&gt;</span> n &gt; <span class="number">30</span>))</span><br><span class="line"><span class="built_in">console</span>.log(numbers.findIndex(<span class="function"><span class="params">n</span>=&gt;</span> n &gt; <span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<p><strong>find()与findIndex()方法在查找满足特定条件的数组元素时非常有用。但若想查找特定值，则使用 indexOf() 与 lastIndexOf() 方法会是更好的选择。</strong><br>fill()方法能使用特定值填充数组中的一个或多个元素，当只使用一个参数的时候，该方法会用该参数的值填充整个数组，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers.fill(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())   <span class="comment">//1,1,1,1</span></span><br></pre></td></tr></table></figure>
<p>当只改变部分值时，可设置起始位置和结束位置的参数（不包括结束位置）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers.fill(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())   <span class="comment">//1,2,1,1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers.fill(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())   <span class="comment">//1,1,1,4</span></span><br></pre></td></tr></table></figure>
<p>copyWithin()方法和fill()方法类似，可以一次性修改数组的多个元素。copyWithin()方法允许在数组内部复制自身元素，为此你需要传毒两个参数给copyWithin()方法：从什么位置开始填充，被用来复制的数据的起始位置索引以及终止位置索引</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">numbers.copyWithin()(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())  <span class="comment">//1,2,1,2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">numbers.copyWithin(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())</span><br></pre></td></tr></table></figure>
<h2 id="类型化数组"><a href="#类型化数组" class="headerlink" title="类型化数组"></a>类型化数组</h2><p>类型化数组是有特殊用途的数组，被设计用来处理数值类型数据（而不像名称暗示的那样，能处理所有类型）。引入类型化数组突破了格式限制并带来了更好的<br>数学运算性能，其设计概念是：单个数值可以被视为由“位”构成的数组，并且可以对其使用与JS 数组现有方法类似的方法。</p>
<h3 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a>数值数据类型</h3><p>JS 数值使用 IEEE 754 标准格式存储，使用64位来存储一个数值的浮点数表示形式，该格式在JS中被同时用来表示整数与浮点数；当值改变时，可能会频繁发生整数与浮点数之间的格式转换。而类型化数组则允许存储并操作八种不同的数值类型：</p>
<ol>
<li>8 位有符号整数（int8）</li>
<li>8 位无符号整数（uint8）</li>
<li>16 位有符号整数（int16）</li>
<li>16 位无符号整数（uint16）</li>
<li>32 位有符号整数（int32）</li>
<li>32 位无符号整数（uint32）</li>
<li>32 位浮点数（float32）</li>
<li>64 位浮点数（float64）<br>所有与类型化数组相关的操作和对象都围绕着这八种数据类型。为了使用它们，你首先需要创建一个数组缓冲区用于存储数据。<h3 id="数组缓冲区"><a href="#数组缓冲区" class="headerlink" title="数组缓冲区"></a>数组缓冲区</h3>数组缓冲区（array buffer）是内存中包含一定数量字节的区域，而所有的类型化数组都基于数组缓冲区。使用ArrayBuffer构造器来创建一个数组缓冲区；调用ArrayBuffer构造器时，只需要传入单个数值用于指定缓冲区包含的字节数。可以通过byteLength属性来获取缓冲区的字节数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(buffer.byteLength)</span><br></pre></td></tr></table></figure>
可以使用slice()方法来创建一个新的、包含已有缓冲区部分的内容数组缓冲区，和数组的slice()方法类似，可以使用起始位置与结束位置参数，返回由原缓冲区元素组成的一个新的ArrayBuffer实例。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> buffer2 = buffer.slice(<span class="number">4</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log((buffer2.byteLength))</span><br></pre></td></tr></table></figure>
<h2 id="使用视图操作数组缓冲区"><a href="#使用视图操作数组缓冲区" class="headerlink" title="使用视图操作数组缓冲区"></a>使用视图操作数组缓冲区</h2>数组缓冲区代表了一块内存区域，而视图（views）则是操作这块区域的接口。视图工作在数组缓冲区或其子集上，可以读写某种数值数据类型的数据。DataView类型时数组缓冲区的通用视图，允许对前述所有8中数值数据类型进行操作。同时可以对数据缓冲区的部分上创建视图，需要提供字节偏移量以及要包含的字节数。<strong>使用这种方式，你可以在同一个数组缓冲区上创建多个不同的视图，这样有助于将单块内存区域供给整个应用使用，而不必每次在有需要时才动态分配内存。</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buffer2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">5</span>,<span class="number">2</span>) <span class="comment">//包含位置5和位置6的字节</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>获取视图信息<br>可以通过查询一下只读属性来获取视图的信息：<br>buffer: 概述图所绑定的数组缓冲区；<br>byteOffset：传给DataView构造器的第二个参数，如果当时提供了的话（默认为0）；<br>byte Length：传给DataView构造器的第三个参数，如果当时提供的话（默认为该缓冲区的byteLength属性）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> view1 = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer)</span><br><span class="line"><span class="keyword">let</span> view2 = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(view1.buffer === buffer)            <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(view2.buffer === buffer)            <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(view1.byteOffset)</span><br><span class="line"><span class="built_in">console</span>.log(view2.byteOffset)</span><br><span class="line"><span class="built_in">console</span>.log(view1.byteLength)</span><br><span class="line"><span class="built_in">console</span>.log(view2.byteLength)</span><br></pre></td></tr></table></figure>

<p>读取和写入数据<br>对应JS所有8种数值数据类型，DataView视图的原型别提供了在数组缓冲区上写入数据的一个方法以及读取数据的一个方法，说有方法名都以“set”或“get”开始，气候跟随这对应数据类型的缩写,例如操作int8或unit8类型的读取/写入方法：<br>“get”方法接受两个参数：开始进行读取的字节偏移量、以及一个可选的布尔值，后者用于指定读取的值是否采用低字节优先方式（注：默认值为 false ）。“set”方法则接受三个参数：开始进行写入的字节偏移量、需要写入的数据值、以及一个可选的布尔值用于指定是否采用低字节优先方式存储数据。<br>**<br>getInt8(byteOffset,littleEndian): 从byteOffset处开始读取一个int8值；<br>setInt8(byteOffset, value, littleEndian): 从byteOffset处开始写入一个int8值；<br>**<br><strong>译注：低字节优先（Little-endian）也被翻译作“小端字节序”，指的是在存储数据的多个内存字节中，第一个内存字节存储着数据的最低字节数据，而最后一个内存字节存储着最高字节数据。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>),</span><br><span class="line">view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">view.setInt8(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">0</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">1</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>视图允许你使用任意格式对任意位置进行读写，而无须考虑这些数据此前是使用什么格式存储的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer)</span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">view.setInt8(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt16(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>在混用不同的数据类型时，使用DataView对象是一种完美方式，不过，若尽享使用特定的一种数据类型，那么特定类型试图会是更好的选择。</p>
<p>类型化数组即为视图</p>
<p>开始时，该数组缓冲区 16 个位均为 0 ；使用 setInt8() 向第一个字节写入 5 之后，该字节的内容就出现了一对 1 （因为 5 可以写为 8 位二进制数 00000101 ）；向第二个字节写入-1 会使得该字节的所有位都变成 1 （即 -1 的二进制补码形式）。接下来使用 getInt16() 就能将前面写入的 16 位数据以单个 16 位整数的方式读取出来，其十进制值就是1535。<br>ES6 的类型化数组实际上也是针对数组缓冲区的特定类型视图，你可以使用这些数组对象来处理特定的数据类型，而不必使用通用的 DataView 对象。一共存在八种特定类型视图，对应着八种数值数据类型，为处理 uint8 值提供了额外的选择。</p>
<p>构造器名称                          元素大小<br>Int8Array                               1<br>Uint8Array                              1<br>Uint8ClampedArray                       1<br>Int16Array                              2<br>Uint16Array                             2<br>Int32Array                              4<br>Uint32Array                             4<br>Float32Array                            4<br>Float64Array                            8<br><strong>类型化数组的构造器可以接受多种类型的参数</strong>，因此存在几种创建类型化数组的方式。<br>第一种方式是使用与创建 DataView 时相同的参数，即：一个数组缓冲区、一个可选的字节偏移量、以及一个可选的字节数量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> view1 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer)</span><br><span class="line"><span class="keyword">let</span> view2 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(view1.buffer === buffer)                    <span class="comment">//true               </span></span><br><span class="line"><span class="built_in">console</span>.log(view2.buffer === buffer)                    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(view1.byteOffset)                           <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(view2.byteOffset)                           <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(view1.byteLength)                           <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(view2.byteLength)                           <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>第二种方法是传递单个数值给类型化数组的构造器，<strong>此数值表示该数组包含的元素数量（而不是分配的字节数）</strong>。构造器会创建一个新的缓冲区，分配正确的字节数以便容纳指定数量的数组元素。可以通过length属性来获取这个元素数量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> floats = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ints.byteLength)</span><br><span class="line"><span class="built_in">console</span>.log(ints.length)</span><br><span class="line"><span class="built_in">console</span>.log(floats.byteLength)</span><br><span class="line"><span class="built_in">console</span>.log(floats.length)</span><br></pre></td></tr></table></figure>
<p><strong>如果调用类型化数组构造器时没有传入参数，构造器会认为传入了 0 ，这种方式创建的类型化数组不会被分配任何存储空间，因此也就不能被用于保存数据。</strong><br>第三种方式是向构造器传递单个对象参数<br><strong>类型化数组</strong>：数组所有元素都会被复制到新的类型化数组中。例如，如果你传递一个 int8类型的数组给 Int16Array 构造器，这些 int8 的值会被复制到 int16 数组中。新的类型化数组与原先的类型化数组会使用不同的数组缓冲区。<br><strong>可迭代对象</strong>：该对象的迭代器会被调用以便将数据插入到类型化数组中。如果其中包含了不匹配视图类型的值，那么构造器就会抛出错误。<br><strong>数组</strong>：该数组的元素会被插入到新的类型化数组中。如果其中包含了不匹配视图类型的值，那么构造器就会抛出错误。<br><strong>类数组对象</strong>：与传入数组的表现一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints1 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</span><br><span class="line">ints2 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(ints1);</span><br><span class="line"><span class="built_in">console</span>.log(ints1.buffer === ints2.buffer); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1.byteLength); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1[<span class="number">1</span>]); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2.byteLength); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2[<span class="number">1</span>]); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<h3 id="类型化数组与常规数组的相似点"><a href="#类型化数组与常规数组的相似点" class="headerlink" title="类型化数组与常规数组的相似点"></a>类型化数组与常规数组的相似点</h3><p>类型化数组与常规数组有好几个相似点，类型化数组在很多场景中都可以像常规数组那样被使用。例如，你可以使用length属性来获取类型化数组包含的元素数量，还可以使用数值类型的索引值来直接访问类型化数组的元素。<br><strong>与常规数组不同的是，你不能使用 length 属性来改变类型化数组的大小。该属性是不可写的，在非严格模式下写入操作会被忽略，而严格模式下则会抛出错误。</strong><br>类型化数组也拥有大量与常规数组等效的方法，你可以对类型化数组使用下列这些方法：<br>copyWithin()、entries()、fill()、filter()、find()、findIndex()、forEach()、indexOf()、join()、keys()、lastIndexOf()、map()、reduce()、reduceRight()、reverse()、slice()、some()、sort()、values()<br><strong>注意</strong>虽然这些方法的表现与数组原型上的对应方法相似，但它们并不完全相同。类型化数组的方法会进行额外的类型检查以确保安全，并且返回值会是某种类型化数组，而不是常规数组（归结于 Symbol.species 属性）。这里有个例子用于演示其中的区别：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</span><br><span class="line">mapped = ints.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mapped.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped[<span class="number">0</span>]); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped[<span class="number">1</span>]); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>**相同的迭代器<br>与常规数组相同，类型化数组也拥有三个迭代器，它们是 entries() 方法、 keys() 方法与values() 方法。这就意味着你可以对类型化数组使用扩展运算符，或者对其使用for-of 循环，就像对待常规数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</span><br><span class="line">intsArray = [...ints];</span><br><span class="line"><span class="built_in">console</span>.log(intsArray <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(intsArray[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(intsArray[<span class="number">1</span>]); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>of()和from()方法<br>所有的类型化数组都包含静态的 of() 与 from() 方法，作用类似于 Array.of() 与Array.from() 方法。其中的区别是类型化数组的版本会返回类型化数组，而不返回常规数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="built_in">Int16Array</span>.of(<span class="number">25</span>, <span class="number">50</span>),</span><br><span class="line">floats = <span class="built_in">Float32Array</span>.from([<span class="number">1.5</span>, <span class="number">2.5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(floats <span class="keyword">instanceof</span> <span class="built_in">Float32Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(ints.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(floats.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(floats[<span class="number">0</span>]); <span class="comment">// 1.5</span></span><br><span class="line"><span class="built_in">console</span>.log(floats[<span class="number">1</span>]); <span class="comment">// 2.5</span></span><br></pre></td></tr></table></figure>
<p>类型化数组与常规数组的区别</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(ints)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>行为差异<br>**常规数组可以被伸展或是收缩，然而类型化数组却会始终保持自身大小不变。你可以对常规数组一个不存在的索引位置进行赋值，但在类型化数组上这么做则会被忽略。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]); <span class="comment">// 50</span></span><br><span class="line">ints[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ints.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>类型化数组也会对数据类型进行检查以保证只使用有效的值，当无效的值被传入时，将会被替换为0</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="string">"hi"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>所有在类型化数组上修改项目值的方法都会受到相同的限制，例如当 map() 方法使用的映射函数返回一个无效值的时候，类型化数组会使用 0 来代替返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</span><br><span class="line">mapped = ints.map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mapped.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped[<span class="number">0</span>]); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped[<span class="number">1</span>]); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>尽管类型化数组拥有常规数组的很多同名方法，但仍然缺少了几个数组方法，包括下列这些：<br>concat()、pop()、push()、shift()、splice()、unshift()<br>除了 concat() 方法之外，该列表中的其余方法都会改变数组的大小，而由于类型化数组的大小不可变，因此这些方法都不能作用于类型化数组。 concat() 方法不可用的原因则是：连接两个类型化数组的结果是不确定的（特别是当它们处理的数据类型不同时），这种不确定情况原本就不应当使用类型化数组。</p>
<p>**附加的方法<br>类型化数组还有两个常规数组所不具备的方法： set() 方法与 subarray() 方法。这两个方法作用相反： set() 方法从另一个数组中复制元素到当前的类型化数组，而subarray() 方法则是将当前类型化数组的一部分提取为新的类型化数组。<br>set() 方法接受一个数组参数（无论是类型化的还是常规的）、以及一个可选的偏移量参数，后者指示了从什么位置开始插入数据（默认值为 0 ）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">4</span>);</span><br><span class="line">ints.set([<span class="number">25</span>, <span class="number">50</span>]);</span><br><span class="line">ints.set([<span class="number">75</span>, <span class="number">100</span>], <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ints.toString()); <span class="comment">// 25,50,75,100</span></span><br></pre></td></tr></table></figure>
<p>subarray() 方法接受一个可选的开始位置索引参数、以及一个可选的结束位置索引参数（像slice() 方法一样，结束位置的元素不会被包含在结果中），并会返回一个新的类型化数组。你可以同时省略这两个参数，从而创建原类型化数组的一个复制品。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]),</span><br><span class="line">subints1 = ints.subarray(),</span><br><span class="line">subints2 = ints.subarray(<span class="number">2</span>),</span><br><span class="line">subints3 = ints.subarray(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subints1.toString()); <span class="comment">// 25,50,75,100</span></span><br><span class="line"><span class="built_in">console</span>.log(subints2.toString()); <span class="comment">// 75,100</span></span><br><span class="line"><span class="built_in">console</span>.log(subints3.toString()); <span class="comment">// 50,75</span></span><br></pre></td></tr></table></figure>



<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="attr"></p>
<p>上图中展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系，由于所有实现中都无法访问到[[Prototype]]，因此可以通过isPrototypeOf()确定对象对象间是否存在这种关系，如下所示：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/" data-id="ck9ghxoox000v7kr9a3eo9n0a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-面向对象的程序设计总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-04-26T03:26:13.274Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/">面向对象的程序设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>引用类型的值（对象）是引用类型的一个实例。</strong>在ECMAScript中，引用类型是一种书结构，用于将数据和功能组织在一起。尽管ECMAScript从技术上讲是一门面向对象的语言，但他不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。<br>对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的，构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。</p>
<h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>虽然Object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。<br>创建Object实例的方法有两种，第一种是使用new操作符后跟Object构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">"Nicholas"</span></span><br><span class="line">person.age = <span class="number">19</span></span><br></pre></td></tr></table></figure>
<p>另一种方式是使用<strong>对象字面量</strong>表示法，对象i字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。其中，属性名也可以使用字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>,</span><br><span class="line">person.age = <span class="number">19</span></span><br></pre></td></tr></table></figure>
<p>对象的属性可以通过点表示法和方括号法进行访问，从功能上看两者没有任何区别，但方括号语法的主要优点是可以通过变量来访问属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;</span><br><span class="line">    name: <span class="string">'daming'</span>,</span><br><span class="line">    age: <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personName = <span class="string">'name'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br><span class="line"><span class="built_in">console</span>.log(person[personName])</span><br></pre></td></tr></table></figure>
<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>ECMA-262在定义只有内部才能用的特性(attribute)时，描述了属性(property)的各种特征。这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问它们。为了表示特性是内部值，该规范把他们放在了两对方括号中，例如[[Enumerable]]。<br>对象有两种属性，数据属性和访问器属性</p>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有4个描述其行为的特性：<br>1.[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。<br>2.[[Enumerable]]:表示能否通过for-in循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true；<br>3.[[Writable]]:表示能否修改属性的值，像前面离震中那样直接在对象上定义的属性，它们的这个特性默认为true；<br>4.[[Value]]:包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性时，把新值保存在这个位置。这个特性的默认值为undefined。<br>对于前面例子中那样直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]、[[Writable]]特性都被设置为true，而[[Value]]特性被设置为指定的值<br>要修改属性默认的特性，必须使用Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象，属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable，enumerable，writable，value。设置其中的一个或多个值，可以修改对应的特性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">//Nicholas</span></span><br><span class="line">person.name = <span class="string">"daming"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>
<p>当writable为false时，在严格模式下赋值操作将抛出错误，在非严格模式下将被忽略，这个规则适用于”configurable: false”情况下。同时当把属性定义为不可配置的，就<strong>不能</strong>把它在变回可配置的。此时再调用Object.defineProperty()方法修改除writable之外的特性，都会导致错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configureble: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//一下代码将导致抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: ture,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p><strong>访问器属性不包含数据值</strong>，它们包含一对getter和setter函数（这两个函数都不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数，并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性：<br>[[Configurable]]: 表示能否通过delete删除从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性，对于直接在对象上定义的属性，合格特性的默认值为true<br>[[Enumerable]]：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。<br>[[Get]]：在读取属性时调用的函数。默认值为undefined<br>[[Set]]：再写入属性时。默认值为undefined<br>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _yera: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.edition)   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>_year前的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性；而<strong>访问器属性year</strong>则包含一个getter函数和一个setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，把year属性修改为2005会导致——year变为2005，而edition变为2.这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。<br>不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，非严格模式下尝试写入属性会被忽略；在严格模式下，尝试写入值制定了getter函数的属性会抛出错误。类似的，没有指定getter函数的属性也不能读，否则在非严格模式下会返回undefined，在严格模式下会抛出错误。</p>
<h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>由于为对象定义多个属性的可能性很大，ECMAScript 5 又定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">    _year:&#123;</span><br><span class="line">        value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>使用Object.definePropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和尧都区其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个歌对象的属性又configurable, enumerable, get, set；如果是数据属性，这个对象的属性有configurable, enumerable, writable, value.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperities(book, &#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>)</span><br><span class="line"><span class="keyword">var</span> descriptor2 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor2.value)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor2.enumerable)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor2.get)</span><br></pre></td></tr></table></figure>
<p>在JavaScript中，可以针对任何对象，包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    o.name = name</span><br><span class="line">    o.age = age</span><br><span class="line">    o.job = job</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>)</span><br></pre></td></tr></table></figure>
<p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别问题（即怎样知道一个对象的类型）。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"daming"</span>, <span class="number">13</span>, <span class="string">"SoftWare Engineer"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaoming"</span>, <span class="number">11</span>, <span class="string">"student"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：要创建Person的新实例，必须使用new操作符，这种方式调用构造函数实际上会经历以下4个步骤:<br>1.创建一个新对象<br>2.将构造函数的租用与赋给新对象（因此this就只想了这个新对象）<br>3.执行构造函数中的代码（为这个个新对象添加属性）<br>4.返回新对象</p>
<p>在前面的例子最后，person1和person2分别保存着Person的一个不同的实例，这两个对象都有一个constructor（构造函数）属性，改属性指向Person。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor === Person)    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor === Person)    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>对象的constructor属性最初时用来表示对象类型的。但是，提到检测对象类型，还是instanceof更可靠一些。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)         <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person)         <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而着正事构造函数模式胜过工厂模式的地方。<br><strong>以这种方式定义的构造函数是定义在Global对象（在浏览器中是window对象）中的。</strong></p>
<p>**将构造函数当作函数<br>构造函数与其他函数的唯一区别，就在于调用它们的方式不同，不过构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new操作符调用，那它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当作构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"software engineer"</span>)</span><br><span class="line">person.sayName()       <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//作为普通函数调用</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>)</span><br><span class="line"><span class="built_in">window</span>.sayName()                <span class="comment">//"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">Person.call(o, <span class="string">"daming"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>)</span><br><span class="line">o.sayName()              <span class="comment">//"daming"</span></span><br></pre></td></tr></table></figure>

<p>**构造函数的问题<br>构造函数模式虽然好用，但也并非没有缺点，使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。ECMAScript中的函数是对象，因此没定义一个函数，也就是实例化了一个对象，从逻辑角度讲，此时的构造函数也可以这样定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log(this.name)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个角度上来看构造函数，更容易明白每个Person实例都包含一个不同的Function实例（以显示name属性）的本质。以这种方式创建函数，会导致不同的作用域链和表示符解析，但创建Function新实例的机制仍然是相同的。因此不同实力上的同名函数是不相等的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName)       <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>然而，创建两个完成同样任务的Function实例的确没有必要，况且有this对象在，根本不用在执行代码前就把哈数绑定到特定对象上面。因此，大可像下面这样，通过函数定义转移到构造函数外部来解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"daming"</span>, <span class="number">19</span>, <span class="string">"software engineer"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaoming"</span>, <span class="number">17</span>, <span class="string">"docter"</span>)</span><br></pre></td></tr></table></figure>
<p>这个例子中，我们把sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们讲sayName属性设置等于全局的sayName函数，这样一来由于sayName包含的是一个指向函数的指针，因此person1和person2对象就共享了在全局作用臃肿定义的同一个sayName()函数。这解决了两个函数做同一件事的问题，但出现了新问题。全局作用域下的函数只能被某个对象调用，有违全局作用域的本意，同时如果对象需要定义很多方法，那么就要定义多个全局函数，这样就毫无封装性可言了。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。换句话说，不必再构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.prototype.name = <span class="string">"daming"</span></span><br><span class="line">    Person.prototype.age = <span class="number">19</span></span><br><span class="line">    Person.prototype.job = <span class="string">"software engineer"</span></span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line">person1.sayName()    <span class="comment">//daming</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line">person2.sayName()    <span class="comment">//daming</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName)    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在此，<strong>与构造函数不同之处在于，新对象的这些属性和方法是由所有实例共享的。</strong></p>
<p>理解原型对象<br>无论什么时候，只要创建了一个新函数，就回根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针，就拿前面的例子来说，Person.prototype.constructor指向Person。通过这个构造函数，我们可以继续为原型对象添加其他属性和方法。<br>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，至于其他方法，都是从Object继承而来。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象，ECMA-262第5版中管这个指针叫[[Prototype]]。<strong>要明确的是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例和构造函数之间</strong>。具体关系如下图</p>
<!-- ![attr](/public/images/实例原型构造函数关系图.png) -->
<p><img src="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/a.png" alt="attr"><br>如上例中，两个对象都不包含属性和方法，但我们却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。<br>虽然在所有实现中都无法访问到[[Prototype]],但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向 调用isPrototypeOf()方法的对象（Person.prototype),那么这个方法就返回true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1))</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person2))</span><br></pre></td></tr></table></figure>
<p>ECMAScript5中增加了一个新方法，叫Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype)     <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1).name)                    <span class="comment">//"daming"</span></span><br></pre></td></tr></table></figure>
<p>使用Object.getPrototypeOf()可以方便地取得一个对象的原型，而在利用原型实现集成的情况下是非常重要的。<br>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值，如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那就在实例中创建该属性，改属性将会屏蔽原型中的那个属性。添加这个属性只会阻止访问原型对象中的那个属性，但不会修改那个属性。即使将该属性设为null，也只会在实例中设置这个属性，不会恢复其指向原型的连接。不过delete操作符可以完全删除实例属性，从而能够重新访问原型中的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span></span><br><span class="line">Person.prototype.age = <span class="number">19</span></span><br><span class="line">Person.prototype.job = <span class="string">"software engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line">person1.name = <span class="string">"daming"</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name)   <span class="comment">//daming</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name)   <span class="comment">//Nicholas</span></span><br><span class="line">person1.sayName()           <span class="comment">//daming</span></span><br><span class="line">person2.sayName()           <span class="comment">//Nicholas</span></span><br><span class="line"></span><br><span class="line">person1.name = <span class="literal">null</span>         </span><br><span class="line"><span class="built_in">console</span>.log(person1.name)   <span class="comment">//null</span></span><br><span class="line">person1.sayName()           <span class="comment">//null</span></span><br><span class="line"><span class="keyword">delete</span> person1.name</span><br><span class="line"><span class="built_in">console</span>.log(person1.name)   <span class="comment">//Nicholas</span></span><br><span class="line">person1.sayName()           <span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>
<p>使用hasOwnProperty()方法可以检测一个属性是存在在于实例中还是存在在于原型中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span></span><br><span class="line">Person.prototype.age = <span class="number">19</span></span><br><span class="line">Person.prototype.job = <span class="string">"software engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line">person1.name = <span class="string">"daming"</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name)                    <span class="comment">//daming</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name)                    <span class="comment">//Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="keyword">delete</span> person1.name                           </span><br><span class="line"><span class="built_in">console</span>.log(person1.name)                    <span class="comment">//Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><strong>原型与in操作符</strong><br>有两种方式使用in操作符：单独使用和在for-in循环中使用。<br><strong>单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span></span><br><span class="line">Person.prototype.age = <span class="number">29</span></span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1)               <span class="comment">//true</span></span><br><span class="line">person1.name = <span class="string">"Greg"</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name)                    <span class="comment">//"Greg" -----来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1)               <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name)                    <span class="comment">//daming -----来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person2)               <span class="comment">//true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name</span><br><span class="line"><span class="built_in">console</span>.log(person1.name)                    <span class="comment">//daming -----来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1)               <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>在使用for-in循环时，返回的时所有能够通过对象访问的，可枚举的（enumerated）属性，其中，既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerale]]标记的属性）的实例也会在for-in循环中返回。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span></span><br><span class="line">Person.prototype.age = <span class="number">29</span></span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;                                    <span class="comment">//name, age, job, sayName</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"name"</span>, &#123;</span><br><span class="line">	enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;                                   <span class="comment">//age, job, sayName</span></span><br><span class="line">person1.name = <span class="string">"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;                                   <span class="comment">//name, age, job, sayName</span></span><br></pre></td></tr></table></figure>
<p>要取得对象上所有可枚举的实例属性，可以使用ECMAScript5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。<br><strong>注意Object.keys和for-in之间的差别</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"daming"</span></span><br><span class="line">Person.prototype.age = <span class="number">29</span></span><br><span class="line">Person.prototype.job = <span class="string">"softWare Engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(keys)                               <span class="comment">//name, age, job, sayName</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1.name = <span class="string">"Rob"</span></span><br><span class="line">p1.age = <span class="number">31</span></span><br><span class="line"><span class="keyword">var</span> p1keys = <span class="built_in">Object</span>.keys(p1)</span><br><span class="line"><span class="built_in">console</span>.log(p1keys)                            <span class="comment">//name, age</span></span><br></pre></td></tr></table></figure>
<p><strong>如果需要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(keys)                                   <span class="comment">//constructor, name, age, job, sayName</span></span><br></pre></td></tr></table></figure>

<p><strong>更简单的原型语法</strong><br>用一个包含所有属性和方法的对象字面量来重写整个原型对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，将Person.prototype设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外，constructor属性不再指向Person了。每创建一个函数，都会同时创建它的prototype对象，这个对象会自动获得constructor属性，而我们在这里使用的语法，本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数。此时，尽管instanceof操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor ==<span class="built_in">Object</span>)  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(friend2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend2 <span class="keyword">instanceof</span> Person)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend2.constructor == Person) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(friend2.constructor ==<span class="built_in">Object</span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>另一种写法，会导致不同的输出结果，原因在于重写了Person.prototype对象后Person.prototype已发生改变，<strong>注意与上一种的区别联系</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor ==<span class="built_in">Object</span>)  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person)  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor ==<span class="built_in">Object</span>)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>如果constructor的值真的很重要，可以像像下面这样特意将他设置会适当值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "nicholas",</span><br><span class="line">    age: 29,</span><br><span class="line">    job: "software Engineer",</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，以这种方式重设constructor属性会导致它的[[Enumerable]]特性被设置为true。默认情况下，原生的constructor属性是不可枚举的，弥补方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fucntion Person() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span></span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>原型的动态性</strong><br>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所作的任何修改都能够立即从实例上反映出来，即使先创建了实例后修改原型也照样如此。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line">friend.sayHi()     <span class="comment">//hi</span></span><br></pre></td></tr></table></figure>
<p>尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果重写整个原型对象就不一样了。其原因在于，调用构造函数时会为实力添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系。**实例中的指针仅指向原型，不指向构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sayAge'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'Nicholas',</span><br><span class="line">    age: 19,</span><br><span class="line">    job: 'software enginner',</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">friend.sayAge()                 <span class="comment">//'sayAge'</span></span><br><span class="line">friend.sayName()                <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p><strong>原生对象的原型</strong><br>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object, Array, String, 等等）都在其构造函数的原型上定义了方法。例如，在Array.prototype中可以找到sort()方法，而在String.prototype中可以找到substring()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort)                 <span class="comment">//funciton</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring)           <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型String添加了一个名为startsWith()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">'Hello World'</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">'Hello'</span>))   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>尽管可以这样做，但不推荐在产品化的程序中修改原生对象的原型。如果因某个事项中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的视线中运行代码时，就可能会导致命名冲突，而且这样做也可能会意外地重写原生方法。<br><strong>原生对象地问题</strong><br>原型模式也不是没有缺点，首先，它省略了为构造函数传递初始化阐述这一回姐，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题，原型模式的最大问题是由其共享的本性所导致的。<br>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性说得过去，因为通过在实力上添加一个同名属性，可以隐藏原型中的对应属性。但对于包含引用类型的属性来说，问题就比较突出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'Nicholas',</span><br><span class="line">    age: 19,</span><br><span class="line">    job: 'software enginee',</span><br><span class="line">    friends: ['daing', 'lingling'],</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line">person1.friends.push(<span class="string">'Van'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends)                       <span class="comment">//daing, lingling, Van</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends)                       <span class="comment">//daing, lingling, Van</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.freidns)   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在person1的friends中添加一项，person2的friends也相应添加了一项，在大多数情况下这是不想要的，这个问题正是很少有人单独使用原型模式的原因。</p>
<h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。<strong>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性</strong>。这样，每个实力都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，这最大限度地接上了内存。另外，这种混成模式还支持向构造函数传递参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">'daming'</span>, <span class="string">'lingling'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">19</span>, <span class="string">'software engineer'</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">17</span>, <span class="string">'doctor'</span>)</span><br><span class="line">person1.friends.push(<span class="string">'van'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends)                                 <span class="comment">//daming, lingling, van</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends)                                 <span class="comment">//daming, lingling</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends)             <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName)             <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>动态原型模式把所有信息都封装再了构造函数中，二通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否有需要初始化原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>通常，在前述的集中模式都不适用的情况下，可以使用寄生(parasitic)构造函数模式。这种模式的基本思想时创建一个函数，该函数的作用仅仅时封装创建对象的代码，然后再返回新建的对象；但从表面上看，这个函数又像是典型的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    o.name = name</span><br><span class="line">    o.age = age</span><br><span class="line">    o.job = job</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'software engineer'</span>)</span><br><span class="line">friend.sayName()                                                  <span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>
<p>这里除了使用new操作符并把使用的包装函数叫做构造函数骄傲做构造函数之外，这个模式跟工厂模式其实是一模一样的。<strong>构造函数在不返回值的情况下，默认会返回新对象实例。而通过构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值。</strong><br>这个模式可以在特殊的情况西用来为对象创建构造函数，假设我们向创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数，因此可以使用这个模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">    values.push.apply(values, <span class="built_in">arguments</span>)</span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>)</span><br><span class="line"><span class="built_in">console</span>.log((colors.toPipeString()));</span><br></pre></td></tr></table></figure>
<p>关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造汉顺外部创建的对象没有什么不同。为此不能依赖instanceof操作符来确定对象类型。</p>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this对象，稳妥对象最适合在一些安全的环境中使用（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">"Nicholas"</span>, <span class="number">19</span>, <span class="string">"Software Engineer"</span>)</span><br><span class="line">friend.sayName()                                             <span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>
<p>注意，在以这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法访问name的值。<br>这样，变量person中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。稳妥构造函数模式提供这种安全性。<br>与寄生构造函数模式类似，使用稳妥构造含糊模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。</p>
<h2 id="扩展的对象功能"><a href="#扩展的对象功能" class="headerlink" title="扩展的对象功能"></a>扩展的对象功能</h2><h3 id="对象类别"><a href="#对象类别" class="headerlink" title="对象类别"></a>对象类别</h3><p>对象类别包括：<br>普通对象： 拥有JS对象所有默认的内部行为<br>奇异对象：其内部行为在某些方面有别于默认行为<br>标准对象：在ES6中被定义的对象，例如Array、Date等等<br>内置对象：在脚本开始运行时由JS运行环境提供的对象。<strong>所有标准对象都是内置对象。</strong></p>
<h3 id="对象字面量语法的扩展"><a href="#对象字面量语法的扩展" class="headerlink" title="对象字面量语法的扩展"></a>对象字面量语法的扩展</h3><p>对象字面量是JS中最流行的模式之一（JSON就是基于这种语法），而它还存在于互联网上的几乎所有JS文件中。<br><strong>属性初始化器的速记法</strong><br>在ES5及更早的版本中，对象字面量是“键值对”的简单集合。这意味着在属性值被初始化时可能会有重复，ES6中，可以使用属性初始化器的速记法来消除对象名称与本地变量的重复情况。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6语法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cretePerson</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法简写</strong><br>ES6同样改进了为对象字面量方法赋值的语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"nicholas"</span>,</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>需计算属性名</strong><br>对象实例能使用”需计算属性名“，只要用方括号表示法来替代小数点表示法即可。方括号允许你将变量或字符串字面量指定为属性名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'last name'</span></span><br><span class="line">person[<span class="string">'first name'</span>] = <span class="string">'nicholas'</span></span><br><span class="line">person[lastName] = <span class="string">'zakas'</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])          <span class="comment">//nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastName])              <span class="comment">//zakas</span></span><br><span class="line"><span class="built_in">console</span>.log(person.first name)             <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>可以在对象字面量中将字符串字面量直接用作属性，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">'first name'</span>: <span class="string">'nicholas'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])</span><br></pre></td></tr></table></figure>
<p>在ES6中，需计算属性名时对象字面语法的一部分，它用的也是方括号表示法，于此前在对象实例上的用法一直</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastName = <span class="string">'last name'</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">'first name'</span>: <span class="string">'nicholas'</span>,</span><br><span class="line">    [lastName]: <span class="string">'zakas'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(person[lastName])</span><br></pre></td></tr></table></figure>
<p>对象字面量内的方括号表明该属性名需要计算，其结果是一个字符串，这意味着其中可以包含表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suffix = <span class="string">' name'</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    [<span class="string">'first'</span> + suffix]: <span class="string">'nicholas'</span>,</span><br><span class="line">    [<span class="string">'last'</span> + suffix]: <span class="string">'zakas'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'last name'</span>])</span><br></pre></td></tr></table></figure>
<h3 id="新的方法"><a href="#新的方法" class="headerlink" title="新的方法"></a>新的方法</h3><p>当JS中要比较两个值时，可能会使用相等运算符（==）或严格相等运算符（===）。为了避免在比较时发生前值类型转化，许多开发者更倾向使用后者。但严格相等运算符也不完全标准，例如它认为+0和-0相等，即使这两者在JS引擎中有不同的表示；另外NaN===NaN会返回false，因此有必要使用isNaN()函数来正确检查NaN，<br>ES6引入了Object.is()方法来弥补严格相等运算符残留的怪异点。此方法接收两个参数，并会在二者的值相等时返回true，此时要求二者类型相同并且值也相等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="string">"5"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="string">"5"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="number">5</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="string">"5"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>Object.assign方法</strong><br>混入（Mixin）是在JS中组合对象时最流行的模式。再一次混入中，一个对象会从另一个对象中接收属性与方法。很多JS的库中都有类似下面的混入方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minin</span>(<span class="params">receiver, supplier</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(supplier).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        receiver[key] = supplier[key]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> receiver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于mixin()函数使用了赋值运算符（=），<strong>因此无法将访问器属性复制到接收者上，Object.assign()体现了这种区别(即无法复制访问器属性）。</strong><br>Object.assign() 方法接受任意数量的供应者，而接收者会按照供应者在参数中的顺序来依次接收它们的属性。这意味着在接收者中，第二个供应者的属性可能会覆盖第一个供应者的，这在下面的代码片段中就发生了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(receiver,</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">"js"</span>,</span><br><span class="line">        name: <span class="string">"file.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">"css"</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(receiver.type) <span class="comment">// "css"</span></span><br><span class="line"><span class="built_in">console</span>.log(receiver.name) <span class="comment">// "file.js"</span></span><br></pre></td></tr></table></figure>
<p><strong>需要记住 Object.assign() 并未在接收者上创建访问器属性，即使供应者拥有访问器属性。由于 Object.assign() 使用赋值运算符，供应者的访问器属性就会转变成接收者数据属性</strong>，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> supplier = &#123;</span><br><span class="line">    <span class="keyword">get</span> name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"file.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(receiver, supplier)</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(receiver, <span class="string">"name"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value) <span class="comment">// "file.js"</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.get); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>重复的对象字面量属性</strong><br>ES5 严格模式为重复的对象字面量属性引入了一个检查，若找到重复的属性名，就会抛出错误。例如，以下代码就有问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    name: <span class="string">"Greg"</span> <span class="comment">// 在 ES5 严格模式中是语法错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但 ES6 移除了重复属性的检查，严格模式与非严格模式都不再检查重复的属性。当存在重复属性时，排在后面的属性的值会成为该属性的实际值，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    name: <span class="string">"Greg"</span> <span class="comment">// 在 ES6 严格模式中不会出错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// "Greg"</span></span><br></pre></td></tr></table></figure>
<p><strong>自有属性的枚举顺序</strong><br>ES5并没有定义对象属性的枚举顺序。ES6中则严格定义了对象自由属性在被美剧时返回的顺序。这对Object.getOwnPropertyNames()和Reflect.ownKeys如何返回属性造成了影响，同样影响了Object.assign()处理属性的顺序。<br>自有属性枚举时基本顺序如下：<br>1.所有的数字类型键，按升序排列；<br>2.所有的字符串类型键，按被添加到对象的顺序排类；<br>3.所有的符号类型键，也按添加顺序排列。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    c: <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">obj.d = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).join(<span class="string">""</span>)); <span class="comment">// "012acbd"</span></span><br></pre></td></tr></table></figure>
<p><strong>for-in 循环的枚举顺序仍未被明确规定，因为并非所有的 JS 引擎都采用相同的方式。而 Object.keys() 和 JSON.stringify() 也使用了与 for-in 一样的枚举顺序。</strong><br><strong>更强大的原型</strong><br>修改对象的原型<br>一般来说，对象的原型会在通过构造器或 Object.create() 方法创建该对象时被指定。直到ES5 为止， JS 编程最重要的假定之一就是对象的原型在初始化完成后会保持不变。尽管ES5 添加了 Object.getPrototypeOf() 方法来从任意指定对象中获取其原型，但仍然缺少在初始化之后更改对象原型的标准方法。<br>ES6 通过添加 Object.setPrototypeOf() 方法而改变了这种假定，此方法允许你修改任意指定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = <span class="built_in">Object</span>.create(person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 将原型设置为 dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Woof"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>对象原型的实际值被存储在一个内部属性[[Prototype]]上，Object.getPrototypeOf()方法会返回此属性存储的值，而Object.setPrototypeOf()方法能够修改该值。<br><strong>使用super引用的简单原型访问</strong><br>关于原型的另一项进步就是引入了super引用，这让在对象原型上的功能调用变得更加容易。例如若要覆盖对象实例的一个方法、但依然要调用原型上的同名方法，如下（以下代码为ES5的实现方案）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">	name: <span class="string">'daming'</span>,</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="comment">// return 'woof' + this.name</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'woof'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">	name: <span class="string">'friend'</span>,</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">', hi'</span>         <span class="comment">//这里的this指向friend，可以通过this.name验证</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person)</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting())                             <span class="comment">//hello, hi</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person)         <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog)</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting())                             <span class="comment">//woof, hi</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog)            <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>从代码中可以看出this的指向过于复杂。ES6中引入super。简单说，super是指向当前对象的原型的一个指针，实际上就是Object.getPrototypeOf(this)的值。由此简化friend中的getGreet()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">    <span class="comment">// 这相当于上个例子中的：</span></span><br><span class="line">    <span class="comment">// Object.getPrototypeOf(this).getGreeting.call(this)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处调用super.getGreeting()等用于在上例的环境中使用Object.getPrototypeOf(this).getGreeting.call(this).类似的，能使用super引用来调用对象原型上的任何方法，<strong>只要这个引用时位于简写的方法之内</strong>。试图在方法接卸之外的情况使用super会导致语法错误，<strong>在这种上下文中 super 是不可用的：错误信息（SyntaxError: ‘super’ keyword unexpected here）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">', hi'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在多继承时，super引用功能非常强大，因为这种情况下，Object.getPrototypeOf()不再适用于所有场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="comment">// console.log('%%%%%%%%%%%%%%%%')</span></span><br><span class="line">    	<span class="comment">// console.log(this === relative)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">',hi'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person)</span><br><span class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend)</span><br><span class="line"><span class="built_in">console</span>.log(person.getGreeting())                   <span class="comment">//hello</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting())                   <span class="comment">//hello, hi</span></span><br><span class="line"><span class="built_in">console</span>.log(relative.getGreeting())                 <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>调用 Object.getPrototypeOf() 时，在调用 relative.getGreeting() 处发生了错误。这是因为此时 this 的值是 relative ，而 relative 的原型是 friend 对象，这样<br>friend.getGreeting().call() 调用就会导致进程开始反复进行递归调用，直到发生堆栈错误。(原因在于this引用的一直都是relative)<br>在ES6中，利用super可以解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person)</span><br><span class="line"><span class="comment">// 原型为 friend</span></span><br><span class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend)</span><br><span class="line"><span class="built_in">console</span>.log(person.getGreeting()) <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()) <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(relative.getGreeting()) <span class="comment">// "Hello, hi!"</span></span><br></pre></td></tr></table></figure>
<p><strong>正式的“方法”定义</strong><br>在ES6之前，“方法”的概念从未被正式定义，此前禁止对象的函数属性（而非数据属性）。ES6中正事做出了定义：方法时一个拥有[[HomeObject]]内部属性的函数，此内部属性指向该方法所属的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shareGreeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何对 super 的引用都会使用 [[HomeObject]] 属性来判断要做什么。第一步是在[[HomeObject]] 上调用 Object.getPrototypeOf() 来获取对原型的引用；接下来，在该原型<br>上查找同名函数；最后，创建 this 绑定并调用该方法。这里有个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person)</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()) <span class="comment">// "Hello, hi!"</span></span><br></pre></td></tr></table></figure>
<p>调用 friend.getGreeting() 返回了一个字符串，也就是 person.getGreeting() 的返回值与”, hi!” 的合并结果。此时 friend.getGreeting() 的 [[HomeObject]] 值是 friend ，并且friend 的原型是 person ，因此 super.getGreeting() 就等价于person.getGreeting.call(this) 。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ECMAScript中描述了<strong>原型链</strong>的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。<br>实现原型链有一种基本模式，其代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue())         <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.constructor)             <span class="comment">//SuperType</span></span><br></pre></td></tr></table></figure>
<p>通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。即，当一度去模式访问一个实例属性是，首先会在实力上搜索改属性，果果没有找到改属性，则会继续搜索实例的原型，再通过原型链实现集成的请款西，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，条用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype；3）搜索SuperType.prototype，最后一步才会找到该方法。再找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。<br><strong>默认的原型</strong><br>之前的例子中展示的原型链还少一环。所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。所有函数的默认原型都是Object的实例。因此默认内源性都会包含一个内部指针，指向Object.prototype。这也是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。<br><strong>SubType继承了SuperType，而SuperType继承了Object。</strong><br><strong>确定原型和实例关系</strong><br>可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用instanceof操作符。只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就回返回true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>)                <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperType)             <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SubType)               <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>由于原型链的关系，可以说instance是Object、SuperType或SubType中任何一个类型的实例。<br>第二种方法是使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型。因此isPrototypeOf()方法也会返回true：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance))     <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance))  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(SubType.prototoye.insPrototypeOf(instance))   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>谨慎的定义方法</strong><br>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue())              <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个继承SuperType的对象对getSuperValue()的引用未发生改变</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anSubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.anSubProperty = <span class="string">'hhh'</span></span><br><span class="line">&#125;</span><br><span class="line">anSubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">anSubType.prototype.getanSubProperty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.anSubProperty</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anInstance = <span class="keyword">new</span> anSubType()</span><br><span class="line"><span class="built_in">console</span>.log(anInstance.getSuperValue())             <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>当通过SubType的实例调用getSuperValue()时，调用的就是这个重新定义的方法；但通过SuperType的实例调用getSuperValue()时，还会继续调用原来的那个方法。<br>这里要格外注意的时，<strong>必须在用SuperType的实例替换原型之后，再定义这两个方法。</strong><br>除默认原型外，其他实例中不包含指向构造函数的指针，这也就是图6-5中展现出的形式，即SubType.prototype不包含constructor属性，因为它是由SuperType生成的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(SubType.prototype.constructor)               <span class="comment">//SuperType</span></span><br></pre></td></tr></table></figure>
<p>还有一点要注意，即在通过原型链实现继承，不能使用对象字面量创建原型方法，因为这样做就会重写原型链:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    getSubValue: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">    &#125;,</span><br><span class="line">    getSuperValue: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue())               <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>以上代码展示了刚刚把SuperType的实例赋值给原型链，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，一次原型链已经被切断。<br><strong>此处继承和通过原型构造实例的对象字面量方式的区别与联系在于：</strong></p>
<p><strong>原型链的问题</strong><br>原型链虽然很强大，可以用它来实现继承，但也存在一些问题。其中最主要的问题来自包含引用类型值的原型。包含引用类型值的原型属性会被所有实例共享，这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType()</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)            <span class="comment">//red, blue, green, black</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)            <span class="comment">//red, blue, green, black</span></span><br></pre></td></tr></table></figure>
<p>原型链的第二个问题是：在创建i之类性的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>在解决原型中包含引用类型值所带来问题的过程中，开始使用一种叫做借用构造函数的技术。其基本思想为在子类型构造函数的内部调用超类型构造函数。**函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）创建的对象上执行构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType()</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)</span><br></pre></td></tr></table></figure>
<p>代码中注释”继承了SuperType”那一行代码借调了超类型的构造函数。通过使用call()方法和apply()方法，实际上是在新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就回在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码（实际上利用this绑定到新对象），由此，SubType的每个实例就都会具有自己的colors属性的副本。<br><strong>传递函数</strong><br>相对于原型链而言，借用构造函数有一个很大的优势： 即可以在子类型构造函数中向超类型构造函数传递参数，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>)</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.name)                   <span class="comment">//Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age)                    <span class="comment">//19</span></span><br></pre></td></tr></table></figure>
<p>以上代码中的SuperType只接收一个参数name，该参数会直接赋给一个属性，在SubType构造函数内部调用SuperType构造函数时，实际上是为SubType的实例设置了name属性。为保证SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。<br><strong>借用构造函数的问题</strong><br>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题————方法都在构造函数中定义，因此无法进行函数复用。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术结合到一起。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">19</span>)</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)</span><br><span class="line">instance1.sayName()</span><br><span class="line">instance1.sayAge()</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">17</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)</span><br><span class="line">instance2.sayName()</span><br><span class="line">instance2.sayAge()</span><br></pre></td></tr></table></figure>
<p>instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>该方式的基本想法为借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        F.prototype = o</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象左右这个构造函数的原型，最后返回了这个临时类型的新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'shelby'</span>, <span class="string">'court'</span>, <span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person)</span><br><span class="line">anotherPerson.name = <span class="string">'Greg'</span></span><br><span class="line">anotherPerson.friends.push(<span class="string">'rob'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person)</span><br><span class="line">yetAnotherPerson.name = <span class="string">'linda'</span></span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">'barbie'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.friends)                    <span class="comment">//'shelby', 'court', 'van', 'rob'</span></span><br></pre></td></tr></table></figure>
<p>实际上，上述代码相当于又创建了person的两个副本<br>ECMAScript5通过Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()和Object()方法的行为相同。(<strong>注意基本数据类型和引用类型的区别</strong>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'shelby'</span>, <span class="string">'count'</span>, <span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person)</span><br><span class="line">aontherPerson.name = <span class="string">'Greg'</span></span><br><span class="line">anotherPerson.friends.push(<span class="string">'Rob'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person)</span><br><span class="line">yetAnotherPerson.name = <span class="string">'Linda'</span></span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">'Barbie'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.friends)                <span class="comment">//'shelby', 'count', 'van', 'Rob', 'Barbie'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    name: <span class="string">'nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'shelby'</span>, <span class="string">'count'</span>, <span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">'greg'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name)                <span class="comment">//greg</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson)                     <span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person)                            <span class="comment">//&#123; name: 'nicholas', friends: [ 'shelby', 'count', 'van' ] &#125;</span></span><br></pre></td></tr></table></figure>
<p>在没必要使用构造函数，只想让一个对象与另一个对象保持类似的情况西，原型式继承完全可以胜任。不过，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承是与原型式继承相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即船舰一个仅用于封装击沉过程的函数，该函数在内部以某种愤怒时来增强对象，最后再像真的是他做了所有工作一样返回对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object(original)</span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'shelby'</span>, <span class="string">'courts'</span>, <span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person)</span><br><span class="line">anotherPerson.sayHi()</span><br></pre></td></tr></table></figure>
<p>使用寄生式继承来为对象添加函数会由于不饿能做到函数复用而降低效率；这一点与构造函数类似</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>前面说过，组合继承是javaScript最常用的集成模式；不过，也有不足。组合继承最大的问题就是无论什么请款下，都会调用两次超类型构造函数：一次实在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例，但不得不再调用子类型构造函数时重写这些属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Supertype</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name)                   <span class="comment">//调用第二次构造函数，重写SubType原型SuperType中的name和colors属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()              <span class="comment">//调用第一次构造函数</span></span><br><span class="line">SubType.prototype.constructor = SubType</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形成来继承方法。其背后的思路是：不必为了指定子类型的原型而调用超类型的构造函数，所需的无非是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.ptototype)</span><br><span class="line">    prototype.constructor = subType</span><br><span class="line">    subType.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/" data-id="ck9ghxop500117kr9diqbfjyg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-事件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/%E4%BA%8B%E4%BB%B6/" class="article-date">
  <time datetime="2020-04-26T02:04:36.937Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/%E4%BA%8B%E4%BB%B6/">事件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JavaScript与HTML之间的交互是通过事件实现的。<strong>事件，就是文档或浏览器窗口中发生的一些特定交互瞬间。</strong>可以使用侦听器（或处理程序）来订阅事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式。支持页面的行为与页面的外观之间的松散耦合。</p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>IE的事件流叫做事件冒泡（event bubbling），即事件开始时有最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>事件捕获的思想是不太具体的节点更早接收到事件，具体的节点最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。老版本的浏览器对事件捕获不支持。</p>
<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。</p>
<p>在DOM事件流中，实际的目标（<div>元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从document到<html>再到<body>后就停止了。下一个阶段是“处于目标阶段，于是事件在<div>上发生，并在事件处理中被看成冒泡阶段的一部分。然后冒泡阶段发生，事件又传回文档。</p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>事件就是用户或浏览器自身执行的某种动作。诸如click、load和mouseover，都是事件的名字。而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以“on”开头，因此click事件的处理程序就是onclick，load事件的处理程序就是onload。</p>
<h3 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h3><p>某个元素支持的每种事件，都可以使用一个与响应事件处理程序的同名HTML特性来指定。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">onclick</span>=<span class="string">"alert('Click')"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样指定时间处理程序有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"click me"</span> onclick=<span class="string">"alert(event.type)"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>通过event变量，可以直接访问事件对象，不用自己定义它，也不用从函数的参数列表中读取。<br>在这个函数内部，this值等于事件的目标元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(event.type)"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于这个动态函数，在它内部，可以像访问局部变量一样访问document及该元素本身的成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(<span class="built_in">document</span>) &#123;</span><br><span class="line">        <span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 元素属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是由JavaScript底层实现，不需要开发者编写。<br>由此，可以更便利的访问自己的属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(value)"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果当前元素是一个表单输入元素，则作用域中还会包含访问表单元素（父元素）的入口，这个函数就变成了如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(<span class="built_in">document</span>) &#123;</span><br><span class="line">        <span class="keyword">with</span>(<span class="keyword">this</span>.form) &#123;</span><br><span class="line">            <span class="keyword">with</span>(<span class="keyword">this</span>)</span><br><span class="line">            <span class="comment">// 元素属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这样扩展作用域的方式，无非就是想让事件处理程序无需引用表单元素就能访问其他表单字段</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Echo Username"</span> <span class="attr">onclick</span>=<span class="string">"alert(username.value)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不过在HTML中指定事件处理程序有两个缺点。首先，存在一个时间差问题。因为用户可能会在HTML元素已出现在页面上就触发相应的事件，但当时事件处理程序可能不具备执行条件（还没有被解析）<br>另一个缺点是，这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。<br>还有就是导致HTML和JavaScript代码紧密耦合。</p>
<h3 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h3><p>通过JavaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。要使用JavaScript指定事件处理程序，首先必须取得一个要操作的对象引用。<br>每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。这种属性的值设置为一个函数，就可以指定事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bin = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Clicked"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这段代码运行之前不会指定事件处理程序，因此如果这些代码在页面中位于按钮后面，就有可能在一段时间内单击没反应。<br><strong>使用DOM0级方法指定的事件处理程序被认为是元素的方法。</strong>因此，这时候的事件处理程序实在元素的作用域中运行；换句话说，程序中的this引用当前元素。<br>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。<br>也可以删除通过DOM0级方法指定的事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><p>“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。所有DOM节点中都包含这两个方法，并且它们都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。<br>要在按钮上click事件添加事件处理程序如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>同时可以添加多个事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>这里为按钮添加了两个事件处理程序，会按照添加它们的顺序触发。<strong>与DOM0级方法一样，这里添加的事件处理程序也是再其依附的元素的作用域中运行。</strong><br>通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；一出事传入的参数与添加处理程序时使用的参数相同。<strong>这也意味着通过addEventListener()添加的匿名函数将无法移除</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventlisterer(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">//无效</span></span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventlisterer(<span class="string">'click'</span>, handler, <span class="literal">false</span>)   <span class="comment">//有效</span></span><br></pre></td></tr></table></figure>

<h3 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h3><p>IE实现了与DOM中类似的两个方法：attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。attachEvent()添加的事件处理程序都会被添加到事件冒泡阶段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'clicked'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>在IE中使用attachEvent()与使用DOM0级方法的主要区别在于事件处理程序的作用域。在使用attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此this等于window。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span> === <span class="built_in">window</span>)   <span class="comment">//true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>attachEvent()方法也可以用来为一个元素添加多个事件处理程序。但执行顺序与DOM2方法相反。<br>使用attachEvent()添加的事件可以通过detachEvent()来移除，条件是必须提供相同的参数。</p>
<p><strong>跨浏览器的事件处理需要检查浏览器对事件的支持程度（DOM0、DOM2或IE）</strong></p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含这所有与事件有关的信息。包括导致事件的元素，事件的类型以及其他与特定事件相关的信息。所有浏览器都支持event对象，但支持方式不同。</p>
<h3 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h3><p>兼容DOM的浏览器会将一个event对象传入到事件处理程序中国。无论指定时间处理程序时使用什么方法（DOM0级或DOM2级），都会传入event对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.type)   <span class="comment">//click</span></span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.type)   <span class="comment">//click</span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>在通过HTML特定定义事件处理程序是，变量event中保存着event对象。以这种方式提供event对象，可以让HTML特性事件处理程序与JavaScript函数执行相同的操作。<br>要阻止特定事件的默认行为，可以使用preventDefault()方法。例如链接的默认行为就是在被单击是会导航到其href特性指定的URL。如果想阻止连接导航这一默认行为，那么通过链接的onclick事件处理程序可以取消它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">'myLink'</span>)</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。例如，直接添加到一个按钮的事件处理程序可以调用stopPropagation(),从而避免触发注册在document.body上面的事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'clicked'</span>)</span><br><span class="line">    event.stopPropagation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'body clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件对象的eventPhase属性，可以用来确定事件当前正位于事件流的那个阶段。如果是在捕获阶段调用的事件处理程序，那么eventPhase等于1；如果事件处理程序处于目标对象上，则eventPhase等于2；如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。尽管“处于目标”发生在冒泡阶段，但eventPhase仍然一直等于2；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.eventPhase)  <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.eventPhase) <span class="comment">//1</span></span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.eventPhase)   <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h3><p>访问DOM的event对象不同，要访问IE中的event对象有几种不同方式，取决于指定时间处理程序的方法。在使用DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> event = <span class="built_in">window</span>.event</span><br><span class="line">    alert(event.type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果事件处理程序时使用attachEvent()添加的，那么就会有一个event对象作为参数被传入事件处理程序函数中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.type)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用attachEvent()的情况下，也可以通过window对象来访问event对象，就像使用DOM0级方法一样。<br>如果是通过HTML特性指定的事件处理程序，那么可以通过一个名叫event的变量来访问event对象（与DOM中的事件模型相同）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(event.type)"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标。故而，最好还是使用event.srcElement比较保险。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>)  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.srcElement === <span class="keyword">this</span>)       <span class="comment">//false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在第一个事件处理程序中（使用DOM0级方法指定的），srcElement属性等于this，但在第二个事件处理程序中，这两者的值不相同。<br>returnValue属性相当于DOM中的preventDefault()方法，它们的作用都是取消给定事件的默认行为。只要将returnValue设置为false，就可以阻止默认行为。</p>
<h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有时间。例如，click事件会一直冒泡到document层次。也就是说，我们可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</p>
<h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><p>每当事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的JavaScript代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。可以使用事件委托技术，显示建立连接数量。另外，再不需要的时候移除事件处理程序，也是解决这个问题的一种方案。内存中留有那些过时不用的“空事件处理程序”，也是造成Web应用程序内存与性能问题的主要原因。<br>两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有时间处理程序的元素时。可能是通过纯粹的DOM操作，例如使用removeChild()和replaceChild()方法，但更多地是发生在使用innerHTML替换页面中某一部分。如果带有时间处理程序的元素被innerHTML删除了，那么原来添加到元素中的事件处理程序极有可能无法被当做垃圾回收。<br>这种情况下，当知道某个元素即将被移除，手动移除事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn")</span></span><br><span class="line"><span class="string">btn.onclick = function() &#123;</span></span><br><span class="line"><span class="string">    btn.onclick = null</span></span><br><span class="line"><span class="string">    document.getElementById('</span>myDiv<span class="string">').innerHTML = '</span>Processing...<span class="string">'</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>另一种情况就是卸载页面的时候。如果页面卸载之前没有清理干净事件处理程序，那么就会滞留在内存中。每次加载完页面再卸载页面时（可能是在两个页面间来回切换，也可以是单击了刷新按钮）内存中直流的对象数目就会增加，因为事件处理程序占用的内存并没有被释放。<br>这种情况最好的做法是在页面卸载之前，通过onunload事件处理程序移处所有事件处理程序。</p>
<h2 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h2><p>事件，就是网页中某个特别值得关注的瞬间。事件经常由用户操作或通过其他浏览器功能来触发。<br>事实上，可以使用JavaScript在任意时刻来触发特定的事件，而此时的事件就如同浏览器创建的事件一样。也就是所，这些事件通浏览器创建的事件一样可以冒泡，也可以指定事件处理程序。</p>
<h3 id="DOM中的事件模拟"><a href="#DOM中的事件模拟" class="headerlink" title="DOM中的事件模拟"></a>DOM中的事件模拟</h3><p>可以在document对象上使用creatEvent方法创建event对象。这个方法接收一个参数，即表示要创建的事件类型的字符串。在DOM2级中，所有这些字符串都使用英文复数形式，而在DOM3级中都变成了单数。<br>这个字符串可以是下列几个字符串之一。<br>1.UIEvents：一般化UI事件。鼠标事件和键盘事件都继承UI事件。<br>2.MouseEvents：一般化的鼠标事件。<br>3.MutationEvents：一般化的DOM变动事件<br>4.HTMLEvents：一般化的HTML事件 如focus…</p>
<p>模拟事件步骤：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domElement = <span class="built_in">document</span>.getElementById(<span class="string">'someId'</span>)</span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.creatEvent(<span class="string">"MouseEvents"</span>)</span><br><span class="line">event.initMouseEvent(<span class="string">'props...'</span>)  <span class="comment">//不同方法事件参数不一样</span></span><br><span class="line">domElement.dispatchEvent(event)   <span class="comment">//等同于触发了initMouseEvent中type设置的事件</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义DOM事件</strong><br>DOM3级还定义了“自定义事件”。自定义事件不是由DOM原生触发的，它的目的是让开发人员创建自己的事件。要创建新的自定义事件，可以调用createEvent(‘CustomEvent’)。返回的对象有一个名为initCustomEvent()的方法，接收如下4个参数。<br>1.type(字符串)：触发的事件类型，可入“keydown”<br>2.bubble(布尔值)：表示事件是否应该冒泡<br>3.cancelable(布尔值)：表示事件是否可以取消<br>4.detail(对象)：任意值，保存在event对象的detail属性中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"><span class="keyword">var</span> event;</span><br><span class="line">EventUtil.addHandler(div, <span class="string">'myevent'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'div:'</span> + event.detail)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">'myevent'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'document:'</span> + event.detail)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">'CustomEvents'</span>, <span class="string">'3.0'</span>)) &#123;</span><br><span class="line">    event = <span class="built_in">document</span>.createEvent(<span class="string">'CustomEvent'</span>)</span><br><span class="line">    event.initCustomEvent(<span class="string">'myevent'</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">'hello world'</span>)</span><br><span class="line">    div.dispatchEvent(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子创建了一个冒泡事件‘myevent’。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/%E4%BA%8B%E4%BB%B6/" data-id="ck9ghxooq000n7kr913yzfkhg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-跨域资源共享" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/" class="article-date">
  <time datetime="2020-04-26T02:04:36.923Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/">跨域资源共享</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通过XHR实现Ajax通信的一个主要限制，来源于跨域安全策略（同源策略）。</p>
<h2 id="同源的定义"><a href="#同源的定义" class="headerlink" title="同源的定义"></a>同源的定义</h2><p>如果两个URL的协议（protocol）、端口（port）（如果有指定的话）和域名（host）都相同的话，则这两个URL是同源。这个方案也被称为‘协议/主机/端口元组’，或者直接是‘元组’。（‘元组’是指一组项目构成的整体，‘三重/四重/五重/等的通用形式）。<br>一下给出了与URL <a href="http://store.company.com/dir/page.html的源进行对比的示例。" target="_blank" rel="noopener">http://store.company.com/dir/page.html的源进行对比的示例。</a></p>
<p>1.<a href="http://store.company.com/dir2/other.html" target="_blank" rel="noopener">http://store.company.com/dir2/other.html</a><br>同源，只有路径不同<br>2.<a href="http://store.company.com/dir/inner/another.html" target="_blank" rel="noopener">http://store.company.com/dir/inner/another.html</a><br>同源，只有路径不同<br>3.<a href="https://store.company.com/secure.html" target="_blank" rel="noopener">https://store.company.com/secure.html</a><br>不同源，协议不同<br>4.<a href="http://store.company.com:81/dir/etc.html" target="_blank" rel="noopener">http://store.company.com:81/dir/etc.html</a><br>不同源，端口不同（http默认是80端口）<br>5.<a href="http://news.company.com/dir/other.html" target="_blank" rel="noopener">http://news.company.com/dir/other.html</a><br>不同源，主机（域名）不同</p>
<h2 id="源的继承"><a href="#源的继承" class="headerlink" title="源的继承"></a>源的继承</h2><p>在页面中通过 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。</p>
<p>例如，about:blank 通常作为父脚本写入内容的新的空白弹出窗口的 URL（例如，通过  Window.open()  ）。 如果此弹出窗口也包含 JavaScript，则该脚本将从创建它的脚本那里继承对应的源。</p>
<p>注意：在Gecko 6.0之前，如果用户在位置栏中输入 data URLs，data URLs 将继承当前浏览器窗口中网页的安全上下文。</p>
<p>data：URLs 获得一个新的，空的安全上下文。</p>
<h2 id="源的更改"><a href="#源的更改" class="headerlink" title="源的更改"></a>源的更改</h2><p>满足某些限制条件的情况下，页面是可以修改它的源。脚本可以将documet.domain的值设置为其当前域的父域。如果将其设置为当前域的父域，则这个较短的父域将用于后续源检查。<br>例如，假设http://<strong>store.company.com</strong>/dir/other.html文档中的一个脚本执行以下语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">'company.com'</span></span><br></pre></td></tr></table></figure>
<p>这条语句执行以后，页面将会成功地通过与http://<strong>company.com</strong>/dir/page.html的同源检测（假设<a href="http://company.com.dir/page.html将其document设置为“company.com&quot;,已表明它希望允许这样做。然而，company.com" target="_blank" rel="noopener">http://company.com.dir/page.html将其document设置为“company.com&quot;,已表明它希望允许这样做。然而，company.com</a> 不能设置 document.domain 为 othercompany.com，因为它不是 company.com 的父域。</p>
<h2 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h2><p>通过XHR实现Ajax通信的一个主要限制，来源于跨域安全策略。默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。<br>CORS（Cross-Origin Resource Sharing，跨源资源共享），定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或相应应该是成功，还是失败。<br>比如一个简单的使用GET或POST发送的请求，它没有自定义的头部，而主体内容是text/plain。在发送请求时，需要给它附加一个额外的Origin头部，其中包含情感求页面的源信息（协议、域名和端口），以便服务器进行根据这个头部信息来决定是否给予响应。<br>  Origin: <a href="http://www.nczonline.net" target="_blank" rel="noopener">http://www.nczonline.net</a><br>如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发<strong><em>）<br>  Access-Control-Allow-Origin: <a href="http://www.nczonline.net" target="_blank" rel="noopener">http://www.nczonline.net</a><br>如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。*</em></strong>注意，请求和响应都不包含cookie信息。</p>
<h3 id="IE对CORS的实现"><a href="#IE对CORS的实现" class="headerlink" title="IE对CORS的实现"></a>IE对CORS的实现</h3><p>IE8中引入了XDR（XDomainRequest）类型。这个对象与XHR类似，但能实现安全可靠的跨域通信。XDR对象的安全机制部分实现了W3C的CORS规范。一下是XDR与XHR的一些不同之处。<br>1.cookie不会随请求发送，也不会随响应返回<br>2.只能设置请求头部信息的Content-Type字段<br>3.不能访问响应头部信息<br>4.只支持GET和POST请求。<br>这些变化使CSRF（Cross-Site Request Forgey，跨站点请求伪造）和XSS（Corss-Site Scripting，跨站点脚本）的问题得到了缓解。被请求的资源可以根据它认为合适的任意数据（用户代理、来源页面等）来决定是否设置Access-Control-Allow-Origin头部。作为请求的一部分，Origin头部的值表示请求的来源域，以便远程资源明确地识别XDR请求。<br>XDR对象的使用方法与XHR对象非常相似。也是创建一个XDomainRequest的实例，调用open()方法，再调用send()方法。但与XHR对象的open()方法不同，XDR对象的open()方法只接收两个参数：请求的类型和URL。<br>所有XDR请求都是异步执行的，不能用它来创建同步请求。请求返回后，会触发load事件，响应的数据也会保存在reponseText属性中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest()</span><br><span class="line">xdr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(xdr.responseText)</span><br><span class="line">&#125;</span><br><span class="line">xdr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xdr.open(<span class="string">'get'</span>, <span class="string">'http://www.somewhere-else.com/page/'</span>)</span><br><span class="line">xdr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>在请求返回前调用abort()方法可以终止请求：<br>xdr.abort()   //终止请求</p>
<p>与XHR一样XDR对象也支持timeout属性以及ontimeout事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest()</span><br><span class="line">xdr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(xdr.responseText)</span><br><span class="line">&#125;</span><br><span class="line">xdr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xdr.timeout = <span class="number">1000</span>;</span><br><span class="line">xdr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'timeout'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xdr.open(<span class="string">'get'</span>,<span class="string">'url'</span>)</span><br><span class="line">xdr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>为支持POST请求，XDR对象提供了contentType属性，用来表示发送数据的格式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest()</span><br><span class="line">xdr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(xdr.responseText)</span><br><span class="line">&#125;</span><br><span class="line">xdr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xdr.timeout = <span class="number">1000</span>;</span><br><span class="line">xdr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'timeout'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xdr.open(<span class="string">'post'</span>,<span class="string">'url'</span>)</span><br><span class="line">xdr.contentType = <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">xdr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>这个属性是通过XDR对象影响头部信息的唯一方式</p>
<h3 id="其他浏览器对CORS的实现"><a href="#其他浏览器对CORS的实现" class="headerlink" title="其他浏览器对CORS的实现"></a>其他浏览器对CORS的实现</h3><p>其他浏览器都通过XMLHttpRequest对象实现了对CORS的原生支持。在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。要请求位于另一个域中的资源，使用标准的XHR对象并在open()方法中传入绝对URL即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR()</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">'error'</span> + xhr.status)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.somewhere-else.com/page/'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>由于无论同源请求还是跨源请求都使用相同的接口，因此对于本地资源，最好使用相对URL，在访问远程资源时再使用绝对URL。这样做能消除歧义，避免出现限制访问头部或本地cookie信息等问题。</p>
<h3 id="Preflighted-Requests"><a href="#Preflighted-Requests" class="headerlink" title="Preflighted Requests"></a>Preflighted Requests</h3><p>CORS通过一种叫做Prefilghed Request的透明服务器验证机制支持开发人员使用自定义的头部、GET或POST之外的方法，以及不同类型的主体内容。在使用下列高级选项来发送请求时，就会像服务器发送一个Preflight请求。这种请求使用OPTIONS方法，发送下列头部。<br>1.Origin：与简单的请求相同<br>2.Access-Control-Request-Method：请求自身使用的方法。<br>3.Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号分隔。<br>以下是一个带有自定义头部NCZ的使用POST方法发送的请求。<br>Origin: <a href="http://www.nczonline.net" target="_blank" rel="noopener">http://www.nczonline.net</a><br>Access-Control-Request-Method: POST<br>Access-Control-Request-Headers: NCZ<br>发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通。<br>1.Access-Control-Allow-Origin：与简单的请求相同。<br>2.Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔<br>3.Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔<br>4.Access-Control-Max-Age：应该讲这个Preflight请求缓存多长时间</p>
<p>例如：<br>Access-Control-Allow-Origin: <a href="http://www.nczonline.net" target="_blank" rel="noopener">http://www.nczonline.net</a><br>Access-Control-Allow-Methods: POST, GET<br>Access-Control-Allow-Headers: NCZ<br>Access-Control-Max-Age: 172800<br>Preflight请求结束后，结果将按照响应中指定的时间缓存起来</p>
<h3 id="带凭据的请求"><a href="#带凭据的请求" class="headerlink" title="带凭据的请求"></a>带凭据的请求</h3><p>默认情况下，跨域请求不提供凭据（cookie、HTTP认证及客户端SSL证明等）。通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据。如果服务器接收带凭据的请求，就会用下面的HTTP头部来响应。<br>Access-Control-Allow-Credentials: true<br>如果发送的是带凭据的请求，单服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给JavaScript（于是，responseText中将是空字符串，status的值为0，而且会调用onerror()事件处理程序）。另外服务器还可以在Preflight响应中发送这个HTTP头部，表示允许源发送带凭据的请求。</p>
<h2 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h2><p>在CORS出现以前，要实现跨域Ajax通信破费一些周折。开发人员想出了一些办法，利用DOM中能够执行跨域请求的功能，在不依赖XHR对象的情况下也能发送某种请求。虽然CORS技术已经无处不在，但开发人员自己发明的技术仍然被广泛使用，因为不需要修改服务器端代码。</p>
<h3 id="子域和父域跨域"><a href="#子域和父域跨域" class="headerlink" title="子域和父域跨域"></a>子域和父域跨域</h3><p>修改脚本的documet.domain为同一域名实现跨域（必须在同一父域下）。</p>
<h3 id="图像Ping"><a href="#图像Ping" class="headerlink" title="图像Ping"></a>图像Ping</h3><p>上述第一种跨域请求技术是使用<img>标签。一个网页可以从任何网页中加载图像，不用担心跨域不跨域。这也是在线广告跟踪浏览量的主要方式。也可以动态地创建图像，使用它们的onload和onerror事件处理程序来确定是否接收到了响应。<br>动态创建图像经常用于图像Ping。图像Ping是服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符形式发送的，而响应可以是任意内容，但通常是像素图或204响应。通过图像Ping，浏览器得不到任何具体的数据，但通过真挺load和error事件，能知道响应是什么时候接收到的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'done'</span>)</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">'http://www.example.com/test?name=Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>这里创建了一个Image的实例，然后将onload和onerror事件吹程序指定为同一个函数。这样无论是什么响应，只要请求完成，就能得到通知。**请求从设置src属性那一刻开始，而这个例子在啊请求中发送了一个name参数。<br>图像Ping最常用于跟踪用户点击页面活动太广告曝光次数。图像Ping有两个主要的缺点，一是只能发送GET请求，二是无法访问服务器的响应文本。因此图像Ping只能用于浏览器与服务器之间额单向通信。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是JSON with padding（填充式JSON或参数式JSON）的简写，是应用JSON的一种新方法，再后来的Web服务中非常流行。JSONP看起来与JSON差不多，只不过是包含在函数调用中的JSON就像下面这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(&#123;<span class="string">'name'</span>: <span class="string">'Nicholas'</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。下面是一个典型的JSONP请求<br><a href="http://freegeoip.net/json/?callback=handleResponse" target="_blank" rel="noopener">http://freegeoip.net/json/?callback=handleResponse</a><br>这个URL是在请求一个JSONP地理定位服务。通过查询字符串来指定JSONP服务的回调函数，就像上面的URL所示，这里指定的回调函数的名字叫handlerResponse()<br>JSONP是通过动态script标签来使用，使用时可以为src属性指定一个跨域URL。这里的script元素与img元素类似，都有能力不受限制的从其他域中加载资源。因为JSONP是有效的JavaScript代码，所以在请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'you are at ip address'</span> + response.ip + <span class="string">'which is in'</span> resoponse.city + <span class="string">','</span> + response.region_name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">script.src = <span class="string">'http://freegeoip.net/json/?callback=handleResponse'</span></span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, documetn.body.firstChild)</span><br></pre></td></tr></table></figure>
<p>这个例子通过查询地理定位服务来显示IP地址和位置信息。<br>JSONP之所以在开发人员中极为流行，只要原因是它非常简单易用。与图像Ping相比，它的优点在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。不过，JSONP也有两点不足。<br>首先，JSONP是从其他域中加载代码执行。如果其他域不安全，很可能会在响应夹带一些恶意代码，而此时除了完全放弃JSONP调用之外，没有办法追究。<br>其次要确定JSONP请求是否失败并不容易。虽然HTML5给‘script’元素新增了一个onerror事件处理程序，但目前还没有得到任何浏览器支持。为此，开发人员不得不使用计时器检测指定时间内是否接收到了响应。但就算这样也不能尽如人意，毕竟不是每个用户上网的速度和带宽都一样。</p>
<h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>Comet值得是一种更高级的Ajax技术（经常也有人称为‘服务器推送’）。Ajax是一种从页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。Comet能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。<br>有两种实现Comet的方式：长轮询和流。长轮询是传统轮询（也称短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据。<br>长轮询把短轮询颠倒了一下。页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可以发送。发送完数据时候，浏览器关闭连接，随即又发起一个到服务器的新请求。<br>无论长轮询还是短轮询，浏览器都要在接收数据之前，先发起对服务器的链接。两者最大的区别在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询则是等待发送响应。轮询的优势是所有浏览器都支持，因为使用XHR对象和setTimeout()就能实现。<br>第二种流行的Comet实现是HTTP流。流不同于上述两种轮询方式，因为它在页面的整个生命周期内只是用一个HTTP链接。具体来说就是浏览器向服务器发送一个请求，而服务器保持链接打开，然后周期性的向浏览器发送数据。<br>在Firefox和Chorme中，通过侦听readystatechange事件及readyState的值是否为3，就可以利用XHR对象实现HTTP流。在上述这些浏览器中，随着不断从服务器接收数据，readyState的值会周期性地变为3.dangreadyState值变为3时，responseText属性中就会保存接收到的所有数据。此时，就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。使用XHR对象实现HTTP流的典型代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStreamingClinet</span>(<span class="params">url, progress, finished</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    <span class="keyword">var</span> received = <span class="number">0</span>;</span><br><span class="line">    xhr.open(<span class="string">'get'</span>, url, <span class="literal">true</span>)</span><br><span class="line">    xrh.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">3</span>) &#123;</span><br><span class="line">            result = xhr.responseText.substring(received)</span><br><span class="line">            received +=result.length</span><br><span class="line">            progress(result)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">            finished(xhr.responseText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> xhr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> client = creatStreamingClient(<span class="string">'streaming.php'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Received: '</span> + data)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'done'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个createStreamingClient()函数接收三个参数：要连接的URL、在接收到数据时调用的函数。有时候，当连接关闭时，很有可能需要重新建立，所以关注连接，所以关注连接什么时候关闭还是有必要的。<br>只要readystatechange事件发生，而且readyState值为3，就对responseText进行分割以取得最新数据。这里的received变量用于记录已经处理了多少个字符，每次readyState值为3时都递增。然后，通过process回调函数来处理传入的新数据。而当readyState值为4时则执行finished回调函数，传入响应返回的全部内容。</p>
<h3 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h3><p>SSE（Serve-Sent Events，服务器发送事件）是围绕只读Comet交互推出的API或者模式。SSEAPI用于创建到服务器的单向连接，服务器通过这个链接可以发送任意数量的数据。服务器响应的MIME类型必须是text/event-stream,而且是浏览器中的JavaScript API能解析格式输出。SSE支持短轮询、长轮询和HTTP流，而且能在断开连接时自动确定合适重新连接。有了这么简单实用的API，再实现Comet就容易多了。</p>
<p>1.SSE API<br>SSE的JavaScript API与其他传递消息的JavaScript API很相似。要预定新的事件流，首先要创建一个新的EventSource对象，并传进一个入口点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> EVENTSource(<span class="string">'myevents.php'</span>)</span><br></pre></td></tr></table></figure>
<p>注意，传入的URL必须与创建对象的页面同源（相同的URL模式、域以及端口）。EventSource的实例有一个readyState属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2表示关闭了连接。<br>另外，还有以下三个事件。<br>1.open：在建立连接时触发<br>2.message：在从服务器接收到新事件时触发。<br>3.error：在无法建立连接时触发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器发回的数据以字符串形式保存在event.data中。默认情况下，eventsource对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味着SSE社和长轮询和HTTP流。如果想强制立即断开连接并且不再重新连接，可以调用close()方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source.close()</span><br></pre></td></tr></table></figure>

<p>2.事件流<br>所谓的服务器事件会通过一个持久的HTTP响应发送，这个响应的MIME类型为text/event-stream。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀data：，例如<br>data: foo</p>
<p>data: bar</p>
<p>data: foo<br>data: bar<br>对于以上响应，事件流中的第一个message事件返回的event.data值为foo，第二个message事件返回的event.data值为bar，第三个message事件返回的event.data值为foo\nbar。对于多个连续的以data:开头的数据行，将作为多端数据解析，每个值之间以一个换行符分隔。只有在包含data:的数据行后面有空行时，才会触发message事件，因此在服务器上生成事件流时不能忘了多添加这一行。<br>通过id:前缀可以给特定的事件指定一个关联的ID，这个ID行位于data:行前面或后面<br>data: foo<br>id: 1<br>设置了ID后，EventSource对象上会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个包含名为Last-Event-ID的特殊HTTP头部的请求，以便服务器知道下次该触发哪个事件。再多次连接的事件流中，这种机制可以确保浏览器以正确的顺序接收到连接的数据段。</p>
<h3 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h3><p>Web Sockets的目标是在一个单独的持久连接上提供全双工、双向通信。在JavaScript中创建了Web Socket之后，会有一个HTTP请求发送到浏览器以发起连接。在取得服务器响应之后，建立的链接会使用HTTP升级从HTTP协议交换为Web Socket协议，就是说，使用标准的HTTP服务器无法实现Web Sockets，只有支持这种协议的专门服务器才能正常工作。<br>由于Web Sockets使用了自定义的协议，所以URL模式也略有不同。未加密的链接不再是http://,而是ws://。加密的链接也不是https://,而是wss://。在使用Web Socket URL时，必须带着这个模式，因为将来还有可能支持其他模式。<br>使用自定义协议而非HTTP协议的好处是，能够在客户端和服务器之间发送非常少量的数据，而不必担心HTTP那样的字节级的开销。由于传递的数据包很小，因此Web Sockets非常适合移动应用。毕竟对移动应用而言，带宽和网络延迟都是关键问题。使用自定义协议的缺点在于，指定协议的时间比指定JavaScript API的时间还要长。</p>
<p>1.Web Sockets API<br>要创建Web Socket，先实例化一个WebSocket对象并传入要连接的URL</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://www.example.com/server.php'</span>)</span><br></pre></td></tr></table></figure>
<p>注意必须给WebSocket构造函数传入绝对URL。同源策略对Web Sockets不适用，因此可以通过它打开到任何站点的链接。至于是否会与某个域中的页面通信，则完全取决于服务器。（通过握手信息就可以知道请求来自何方）</p>
<p>实例化了WebSocket对象后，浏览器就会马上尝试创建连接。与XHR类似，WebSocket也有一个表示当前状态的readyState属性，取值如下：<br>WebSocket.OPENING(0):正在建立连接<br>WebSocket.OPEN(1)：已经建立连接<br>WebSocket.CLOSING(2)：正在关闭连接<br>WebSocket.CLOSE(3)：已经关闭连接</p>
<p>WebSocket没有readystatechange事件，步步哦有其他事件，对应着不同的状态。readyState的值永远从0开始。<br>要关闭Web Socket连接，可以任何时候调用close()方法。<br>socket.close()<br>调用了close()之后，readyState的值立即变为2（正在关闭），而在关闭连接后就会变为3.</p>
<p>2.发送和接收数据<br>Web Socket打开之后，就可以通过链接发送和接收数据。要向服务器发送数据，使用send()方法并传入任意字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://www.example.com/server.php'</span>)</span><br><span class="line">socket.send(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>
<p>因为Web Socket只能通过连接发送纯文本数据，所以对于复杂的数据结构，在通过连接发送之前，必须进行序列化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> Data(),</span><br><span class="line">    text: <span class="string">'hello world'</span>,</span><br><span class="line">    clientId: <span class="string">'asdfp'</span></span><br><span class="line">&#125;</span><br><span class="line">socket.send(<span class="built_in">JSON</span>.stringify(message))</span><br></pre></td></tr></table></figure>
<p>接下来，服务器要读取其中的数据，就要解析接收到的JSON字符串。<br>当服务器向客户端发来消息时，WebSocket对象就会触发message事件。这个message事件与掐他产地消息的协议类似，也是吧返回的数据保存在event.data属性中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与通过send()发送到服务器的数据一样，event.data中返回的数据也是字符串，需要手工解析。</p>
<p>3.其他事件<br>WebSocket对象还有其他三个事件，在连接声明追的不同阶段触发<br>open：在成功建立连接时触发<br>error：在发生错误时触发，连接不能持续<br>close：在连接关闭时触发。<br>WevScket对象不支持DOM2级事件侦听器，因此必须使用DOM0级语法分别定义每个事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'wsurl'</span>)</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'connect on'</span>)</span><br><span class="line">&#125;</span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'close'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vue开发模式和生产模式下跨域"><a href="#vue开发模式和生产模式下跨域" class="headerlink" title="vue开发模式和生产模式下跨域"></a>vue开发模式和生产模式下跨域</h3><p>开发模式<br>找到并打开config文件夹下的index.js,做如下配置proxyTable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">  <span class="string">'/api'</span>: &#123;</span><br><span class="line">    target: <span class="string">'http://xxxxxxxx.com/api'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">'^/api'</span>: <span class="string">'/api'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明配置中的target后面内容为后端人员提供的数据接口。</span></span><br><span class="line"><span class="comment">//原理就是类似vpn做了一个中转，Node替你去接口请求数据而已</span></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">this</span>.$http.get(<span class="string">'/api/login'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>生产模式<br>将项目部署到nginx服务器，利用nginx做反向代理进行跨域，只需配置nginx文件<br>参考链接 <a href="https://www.cnblogs.com/web-record/p/9467258.html" target="_blank" rel="noopener">https://www.cnblogs.com/web-record/p/9467258.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/" data-id="ck9ghxooz000x7kr90s75b44g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-防抖与节流" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/" class="article-date">
  <time datetime="2020-04-26T02:04:36.865Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/">防抖与节流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>有些情况下前端事件触发的函数执行过于频繁，将浪费浏览器性能由此引出防抖。<br><strong>防抖</strong><br>定义：<br>对于短时间内连续触发的事件，防抖的含义是让某个时间期限内，时间处理函数只执行一次。</p>
<p>思路1：<br>在第一次触发事件时，不利己执行函数，而是给出一个期限例如200ms，<br>当200ms内没有在此触发该事件，那么就执行函数<br>当200ms内再次触发该事件，当前计时取消，重新开始计时</p>
<p><strong>效果</strong> 短时间大量触发同一事件只会执行一次函数。</p>
<p><strong>实现</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非立即实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">        </span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;, wait)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait,immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showTop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop</span><br><span class="line">    <span class="built_in">console</span>.log(scrollTop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onscroll = debounce(showTop, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>此代码实现停止滚动1秒后，才会打印滚动条位置。<br><strong>防抖函数的代码使用这两行代码来获取 this 和 参数，是为了让 debounce 函数最终返回的函数 this 指向不变以及依旧能接受到 e 参数。</strong></p>
<p><strong>节流</strong><br>防抖存在的问题在于，当在规定时间间隔内，某事件一直被触发，则其绑定的函数将无法执行。</p>
<p>效果： 如果短时间内大量触发同一事件，在函数执行一次后，该函数在指定的事件期限内不再工作，直至过了这段时间才重新生效。</p>
<p>实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间戳版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showTop</span>  (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">　　<span class="built_in">console</span>.log(scrollTop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle(showTop,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>


<p><strong>时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</strong><br>以上代码结果，一直拖动滚动条进行滚动，就会以1秒的时间间隔，持续输出当前位置和顶部的距离。</p>
<p><strong>其他应用场景</strong><br>1.搜索框input事件，例如要支持输入试试搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或实现输入间隔大于某个值，就当做用户输入完成。<br>2.页面resize事件，常见于要做页面适配的时候，需要根据最终呈现的页面进行dom渲染，这种情况一般是使用防抖，因为只需要判断最后一次变化情况）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/" data-id="ck9ghxop1000z7kr9aaqsdxwr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-定位元素" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0/" class="article-date">
  <time datetime="2020-04-26T02:04:36.845Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0/">定位元素</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这部分介绍盒模型，position和display属性以及如何浮动（float）和清除（clear）元素。以及flex属性。<br>所谓盒模型，就是浏览器为页面中的每个HTML元素生成的矩形盒子。这些盒子都要按照课件版式模型（visual formatting model）在页面上排布。可见的页面版式主要由三个属性控制：position属性、display属性和float属性。其中position属性控制页面上元素间的位置关系，display属性控制元素是堆叠并排还是根本不在页面上出现，float属性提供控制的方式，以便把元素组成成多栏布局。</p>
<h2 id="理解盒模型"><a href="#理解盒模型" class="headerlink" title="理解盒模型"></a>理解盒模型</h2><p>每个元素都会在页面上生成一个盒子。因此HTML页面实际上就是由一堆盒子组成的。<br>默认情况下，每个盒子的边框不可见，背景也是透明的，所以我们不能直接看到页面中盒子的结构。<br>每个元素盒子的属性可以分成三组：<br>1.边框（border）：可以设置边框的宽窄，样式和颜色。<br>2.内边框（padding）：可以设置盒子内容区与边框的间距。<br>3.外边距（margin）：可以设置盒子与相邻元素的间距。<br>盒子的边框内边距和外边距相关的属性有4个，分别是上（top），右（right），下（bottom），左（left）。</p>
<h3 id="盒子边框"><a href="#盒子边框" class="headerlink" title="盒子边框"></a>盒子边框</h3><p>边框（border）有三个相关属性<br>1.宽度（border-width）：可以使用thin、medium、和thick等文本值，也可以使用除百分比和负值之外的任何绝对值。<br>2.样式（border-style）：有none、hidder、dashed、solid、double、groove、ridge、inset和outset等文本值。<br>3.颜色（border-color）：可以使用任意颜色值，包括RGB、HSL、十六进制颜色值和颜色关键字。</p>
<h3 id="盒子内边距"><a href="#盒子内边距" class="headerlink" title="盒子内边距"></a>盒子内边距</h3><p>内边距（padding）是盒子内容区和盒子边框之间的距离。</p>
<h3 id="盒子外边距"><a href="#盒子外边距" class="headerlink" title="盒子外边距"></a>盒子外边距</h3><p>外边距（margin）是盒子之间的距离。</p>
<h3 id="叠加外边距"><a href="#叠加外边距" class="headerlink" title="叠加外边距"></a>叠加外边距</h3><p><strong>垂直方向上的外边距会叠加</strong>，假设有三个段落，前后相接，而且都应用以下规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">height</span>:<span class="number">50px</span>; <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#000</span>; <span class="attribute">backgroundcolor</span>:<span class="number">#fff</span>; <span class="attribute">margin-top</span>:<span class="number">50px</span>; <span class="attribute">margin-bottom</span>:<span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>第一段和第二段之间的实际间距是50px。像这样上下外边距相遇时，就会相互重叠，直至一个外边距碰到另一个元素的边框。<br><strong>注意，叠加的只是垂直外边距，水平外边距不叠加。对于水平相邻的元素，它们的水平间距是相邻外边距之和。</strong></p>
<h2 id="盒子有多大"><a href="#盒子有多大" class="headerlink" title="盒子有多大"></a>盒子有多大</h2><p>1.没有宽度的盒子<br>所谓没有宽度的盒子就是指没有显示地设置元素的width属性。如果不设置块级元素的width属性，那么这个属性的默认值是auto，结果会让元素的宽度扩展到与父元素同宽。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>This element's width property is not set…<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-family</span>:helvetica, arial, sans-serif; <span class="attribute">font-size</span>:<span class="number">1em</span>; <span class="attribute">margin</span>:<span class="number">0px</span>; </span><br><span class="line"><span class="attribute">background-color</span>:<span class="number">#caebff</span>;&#125; </span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">background-color</span>:<span class="number">#fff</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>body元素会填满浏览器窗口，而段落会填满body元素。<br>接下来用内边距给文本两侧添加一些空白：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">background-color</span>:<span class="number">#fff</span>; <span class="attribute">padding</span>:<span class="number">0</span> <span class="number">20px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>添加了内边距后，文本块的宽度变成了 360 像素（两边各加了 20 像素内边距）。<br>接下来，我们再给段落左右两边各添加 6 像素宽的边框</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">background-color</span>:<span class="number">#fff</span>; <span class="attribute">padding</span>:<span class="number">0</span> <span class="number">20px</span>; </span><br><span class="line"><span class="attribute">border</span>:solid red; <span class="attribute">border-width</span>:<span class="number">0</span> <span class="number">6px</span> <span class="number">0</span> <span class="number">6px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>为两边各添加 6 像素的边框和 20 像素的内边距后，内容区变成了 348 像素<br>最后，再给左右两边各加一些外边距</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">margin</span>:<span class="number">0</span> <span class="number">30px</span>; <span class="attribute">background-color</span>:<span class="number">#fff</span>; <span class="attribute">padding</span>:<span class="number">0</span> <span class="number">20px</span>; <span class="attribute">border</span>:solid red; <span class="attribute">border-width</span>:<span class="number">0</span> <span class="number">6px</span> <span class="number">0</span> <span class="number">6px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>外边距在元素盒子与窗口之间创造了空白，此时内容宽度变成了 288像素（400 – ( (20 + 6 + 30)× 2)）。而元素声明的总宽度并没有变，仍然是400像素。<br><strong>盒模型结论一：没有（就是没有设置 width 的）宽度的元素始终会扩展到填满其父元素的宽度为止。添加水平边框、内边距和外边距，会导致内容宽度减少，减少量等于水平边框、内边距和外边距的和。</strong><br>2.有宽度的盒子</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">width</span>:<span class="number">400px</span>; <span class="attribute">background-color</span>:<span class="number">#fff</span>; <span class="attribute">margin</span>:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>段落有了固定的宽度400像素。在没有内边距的情况下，内容区也是生命的宽度，因此文本与盒子接触。下面给这个元素添加20像素的内边距：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">width</span>:<span class="number">400px</span>; <span class="attribute">background-color</span>:<span class="number">#fff</span>; <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span> <span class="number">20px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>在给盒子设定宽度后，添加内边距会导致元素比原来宽了 40 像素<br>再给盒子两边各添加 6 像素的边框</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">width</span>:<span class="number">400px</span>; <span class="attribute">background-color</span>:<span class="number">#fff</span>; <span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span> <span class="number">20px</span>; <span class="attribute">border</span>:solid red; <span class="attribute">border-width</span>:<span class="number">0</span> <span class="number">6px</span> <span class="number">0</span> <span class="number">6px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>盒子比刚才又宽了 12 像素<br>最后，再给元素左、右两边添加一些外边距</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">width</span>:<span class="number">400px</span>; <span class="attribute">background-color</span>:<span class="number">#fff</span>; <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">30px</span>; <span class="attribute">padding</span>:<span class="number">0</span> <span class="number">20px</span>; <span class="attribute">border</span>:solid red; <span class="attribute">border-width</span>:<span class="number">0</span> <span class="number">6px</span> <span class="number">0</span> <span class="number">6px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>添加的这 30 像素外边距，进一步增大了元素占据的空间，目前总宽度已达到 512 像素（30 + 6 + 20 + 400 + 20 + 6 + 30 = 512）。<br><strong>盒模型结论二：为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展得更宽。实际上，盒子的 width 属性设定的只是盒子内容区的宽度，而非盒子要占据的水平宽度。</strong></p>
<h2 id="浮动与清除"><a href="#浮动与清除" class="headerlink" title="浮动与清除"></a>浮动与清除</h2><p>浮动就是把元素从常规文档流中拿出来。浮动元素脱离了常规文档流之后，原来紧跟其后的元素就会在空间允许的情况下，向上提升到与浮动元素平起平坐。<br>如果浮动元素后面有两个段落，而之乡让第一段与浮动元素并列。这时候使用clear属性来“清除”第二段，然后钙元素就在浮动元素下面。</p>
<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>CSS设计float属性的主要目的，是为了实现文本绕排图片的效果。然而，这个属性也成了创建多兰布局最简单的方式。<br>1.文本绕排图片<br>为了实现文本绕排图片的浮动效果，必须在标记中先写图片，然后在写环绕它的文本。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">...</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>the paragraph text ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">border</span>: <span class="number">1px</span> solid red;&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;<span class="attribute">float</span>:left; <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">4px</span> <span class="number">4px</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>以上规则会让图片浮动到左侧，而让文本绕排到右侧。<br>2.创建分栏<br>在上一部分的基础上创建多栏，只要再用一次float属性，只要给段落设定宽度然后也浮动它即可。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">weidth</span>: <span class="number">200px</span>; <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;<span class="attribute">margin</span>: <span class="number">0</span> <span class="number">4px</span> <span class="number">4px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>这样同时浮动图片和“有宽度的”段落，会导致段落的文本绕排效果消失，而浮动的段落也会尽可能向左向上移动。就这样，这个段落就构成了紧挨着图片的一栏。这就是使用 float 属性创建多栏布局的原理。换句话说，如果几个相邻的元素都具有设定的宽度，都是浮动的，而且水平空间也足以容纳它们，它们就会并列排在一行。</em></p>
<h4 id="围住浮动元素的三种方法"><a href="#围住浮动元素的三种方法" class="headerlink" title="围住浮动元素的三种方法"></a>围住浮动元素的三种方法</h4><p>浮动元素脱离了文档流，其父元素也看不到它，因而也不会包围它。这种情况有时候并非我们想要的。<br>为了演示浮动元素的行为，这种行为对布局会产生什么影响，以及解决这个问题的三种方法，我们首先要从一张带标题的图片开始。图片和标签包含在一个 section元素中，而 section 元素后面跟着一个 footer 元素。可以把这个 footer 元素想象成很多网页底部都会有的与页面同宽的页脚。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/rubber_duck2.jpg"</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>It's fun to float.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> Here is the footer element that runs across the bottom of the </span><br><span class="line">page.<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid blue; <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">0</span>;&#125;</span><br><span class="line">p &#123;margin 0;&#125;</span><br><span class="line"><span class="selector-tag">footer</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们看到的是常规文档流，即块级元素包围着所有子元素，而且在页面中自上而下相互堆叠在一起。<br>使用浮动属性应用于图片</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid blue; <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">0</span>;&#125; </span><br><span class="line"><span class="selector-tag">img</span> &#123;<span class="attribute">float</span>:left;&#125; </span><br><span class="line"><span class="selector-tag">footer</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125;</span><br></pre></td></tr></table></figure>
<p>这将会导致图片脱离section的包围，父元素section收缩到只包含文本的高度。为解决此问题，有三种方式：<br>方法一：为父元素添加overflow：hidden<br>这个方法很简单，缺点是不太直观，即为父元素应用overflow：hidden，以强制它包围浮动元素。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid blue; <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">0</span>; <span class="attribute">overflow</span>:hidden;&#125; </span><br><span class="line"><span class="selector-tag">img</span> &#123;<span class="attribute">float</span>:left;&#125; </span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，overflow:hidden 声明的真正用途是防止包含元素被超大内容撑大。应用overflow:hidden 之后，包含元素依然保持其设定的宽度，而超大的子内容则会被容器剪切掉。除此之外，overflow:hidden 还有另一个作用，即它能可靠地迫使父元素包含其浮动的子元素。<br>方法二：同时浮动父元素<br>第二种方法促使父元素包围其浮动元素的方法，是让父元素也浮动起来。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid blue; <span class="attribute">float</span>:left; <span class="attribute">width</span>:<span class="number">100%</span>;&#125; </span><br><span class="line"><span class="selector-tag">img</span> &#123;<span class="attribute">float</span>:left;&#125; </span><br><span class="line"><span class="selector-tag">footer</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid red; <span class="attribute">clear</span>:left;&#125;</span><br></pre></td></tr></table></figure>
<p>浮动section以后，不管其子元素是否浮动，他都会仅仅地包围（也称收缩包裹）住它的子元素。因此需要用width:100%再让section和浏览器容器同宽。另外由于section现在也浮动了。所以footer会努力挤到它旁边去。为了强制footer依然待在section下方，要给footer应用clear:left。被清除的元素不会提升到浮动元素的旁边。<br>方法三：添加飞浮动的清楚元素<br>第三种强制父元素包含其浮动子元素的方法就是给父元素的最后添加一个非浮动的子元素，然后清除该子元素。由于包含元素一定会包围非浮动的子元素，而且清除会让这个子元素位于（清除一侧）附送元素的下方，因此包含元素一定会包含这个子元素-以及前民的浮动元素。包含元素最后添加子元素作为清除元素的方式有两种。<br>第一种方式:在 HTML 标记中添加一个子元素，并给它应用<br>clear 属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/rubber_duck.jpg"</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>It's fun to float.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clear_me"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> Here is the footer element…<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid blue;&#125; </span><br><span class="line"><span class="selector-tag">img</span> &#123;<span class="attribute">float</span>:left;&#125; </span><br><span class="line"><span class="selector-class">.clear_me</span> &#123;<span class="attribute">clear</span>:left;&#125; </span><br><span class="line"><span class="selector-tag">footer</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方式:用 CSS 来添加这个清除元素的方法,使用clearfix 规则</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/rubber_duck.jpg"</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>It's fun to float.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> Here is the footer element…<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line"> <span class="attribute">content</span>:<span class="string">"."</span>; </span><br><span class="line"> <span class="attribute">display</span>:block; </span><br><span class="line"> <span class="attribute">height</span>:<span class="number">0</span>; </span><br><span class="line"> <span class="attribute">visibility</span>:hidden; </span><br><span class="line"> <span class="attribute">clear</span>:both; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>CSS布局的核心是position属性，对元素盒子应用这个属性，可以相对于它常规文档六中的位置重新定位。position属性有四个值：static、relative、absolute、fixed，默认值为static。</p>
<h3 id="静态定位"><a href="#静态定位" class="headerlink" title="静态定位"></a>静态定位</h3><p>position:static。静态定位的情况下，每个元素处在常规文档流中。它们都是块级元素，所以酒会在页面中自上而下地堆叠起来。</p>
<h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>position:relative。相对是相对的它原来在文档流中的位置（或者默认位置）。通过设置top和left就可以实现位置的移动。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-id">#specialpara</span> &#123;<span class="attribute">position</span>:relative; <span class="attribute">top</span>:<span class="number">25px</span>; <span class="attribute">left</span>:<span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>position: absolute。绝对定位跟静态定位和相对定位比，绝对不一样。因为绝对定位会把元素彻底从文档流中拿出来。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-id">#specialpara</span> &#123;<span class="attribute">position</span>:absolute; <span class="attribute">top</span>:<span class="number">25px</span>; <span class="attribute">left</span>:<span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>关于定位上下文，首先我们要知道绝对定位元素默认的定位上下文是 body 元素。通过 top 和 left 设定的偏移值，决定了元素相对于 body 元素（标记层次中的祖先容器），而不是相对于它在文档流中的位置偏移多远——这一点与相对<br>定位的元素不同。<br>由于绝对定位元素的定位上下文是 body，所以在页面滚动的时候，为了维护与 body元素的相对位置关系，它也会相应地移动。</p>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>position: fixed。从完全移出文档流的角度说，固定定位与绝对定位类似。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-id">#specialpara</span> &#123;<span class="attribute">position</span>:fixed; <span class="attribute">top</span>:<span class="number">30px</span>; <span class="attribute">left</span>:<span class="number">20px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>但不同之处在于，固定定位元素的定位上下文是视口（浏览器窗口或手持设备的屏幕），因此它不会随页面滚动而移动。</p>
<h3 id="定位上下文"><a href="#定位上下文" class="headerlink" title="定位上下文"></a>定位上下文</h3><p>把元素的 position 属性设定为 relative、absolute 或 fixed 后，继而可以使用 top、right、bottom 和 left 属性，相对于另一个元素移动该元素的位置。这里的“另一个元素”，就是该元素的定位上下文。<br>在讲绝对定位的时候，我们知道绝对定位元素默认的定位上下文是 body。这是因为body 是标记中所有元素唯一的祖先元素。而实际上，绝对定位元素的任何祖先元素都可以成为它的定位上下文，只要你把相应祖先元素的 position 设定为 relative 即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span>This is text…<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-id">#outer</span> &#123;<span class="attribute">position</span>:relative; <span class="attribute">width</span>:<span class="number">250px</span>; <span class="attribute">margin</span>:<span class="number">50px</span> <span class="number">40px</span>; <span class="attribute">border-top</span>:<span class="number">3px</span> solid red;&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#inner</span> &#123;<span class="attribute">top</span>:<span class="number">10px</span>; <span class="attribute">left</span>:<span class="number">20px</span>; <span class="attribute">background</span>:<span class="number">#ccc</span>;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显示属性"><a href="#显示属性" class="headerlink" title="显示属性"></a>显示属性</h2><p>正如所有元素都有position属性，所有元素也都有display属性。尽管display属性的值有很多，但大多数元素display属性的默认值不是block，就是inline。<br>块级元素（block），比如段落，标题，列表等在浏览器中上下堆叠显示。<br>行内元素（inline），比如a、span和img，在浏览器中做鱼并排显示，只有前一行没有空间时才会显示到下一行。<br>把块级元素变成行内元素（或者相反）的方式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*默认是block  */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">display</span>: inline&#125;</span><br><span class="line"><span class="comment">/*默认是inline  */</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;<span class="attribute">display</span>: block&#125;</span><br></pre></td></tr></table></figure>
<p>display 属性还有一个值有必要提一下，就是 none。把元素的 display 设定为 none，该元素及所有包含在其中的元素，都不会在页面中显示。它们原先占据的所有空间也都会被“回收”，就好像相关的标记根本不存在一样。与此相对的是 visibility属性，这个属性最常用的两个相对的值是 visible（默认值）和 hidden。把元素的visibility 设定为 hidden，元素会隐藏，但它占据的页面空间仍然“虚位以待”。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>背景支持为元素添加背景颜色和背景图片。CSS里每个元素盒子都可以想象成由两个图层组成。元素的前景层包含内容（如文本或图片）和边框，元素的背景层可以用试色填充（使用background-color属性），也可以包含任意多个背景图片（使用background-image属性），背景图片叠加在背景颜色之上。<br>在CSS3被浏览器实现之前，只能在背景颜色上添加一张背景图片。而现在，我们可以为背景图层添加多张图片（以及CSS3渐变）。</p>
<h3 id="CSS背景属性"><a href="#CSS背景属性" class="headerlink" title="CSS背景属性"></a>CSS背景属性</h3><p>css规定一下与背景相关属性。<br>background-color、background-image、background-repeat、background-position、background-size、background-attachment、background（简写属性）以及未被广泛支持的background-clip、background-origin、background-break。</p>
<h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p>background-color是北京属性中最简单的，通过它可以设定元素的颜色。然后元素就会以设定的颜色填充背景图层。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:<span class="number">#caebff</span>;&#125; </span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="comment">/*盒子布局样式*/</span> </span><br><span class="line"> <span class="attribute">font-family</span>:helvetica, arial, sans-serif; <span class="attribute">font-size</span>:<span class="number">18px</span>; </span><br><span class="line"> <span class="attribute">width</span>:<span class="number">350px</span>; <span class="attribute">margin</span>:<span class="number">20px</span> auto; <span class="attribute">padding</span>:<span class="number">10px</span>; </span><br><span class="line"> <span class="comment">/*这个例子中讨论背景和前景样式*/</span> </span><br><span class="line"> <span class="attribute">background-color</span>:<span class="number">#fff</span>; <span class="attribute">color</span>:<span class="number">#666</span>; <span class="attribute">border</span>:<span class="number">4px</span> solid; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子除了演示怎么给元素添加背景色，还演示了前景色的作用范围，也就是前景色会影响元素的内容和边框。当然，有一个前提条件，就是在使用 border 设定边框的样式和宽度，而没有设定边框颜色（或者没有使用 border-color 单独设定边框颜色）的情况下，边框会使用 color 属性设定的字体颜色。默认颜色是黑色。如果你想让边框的颜色有别于文本，就需要单独设定。</p>
<h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>默认情况下背景图片会以元素左上角为起点，沿水平和垂直方向重复出现，最终填满整个背景区域。正是因为以元素左上角为原点，所以元素盒子底部和右侧的圆形图案都只显示了一部分。要注意的是，指定背景图片来源的方式，与 img标签中的方式不同，要这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image:url(图片路径/图片文件名)</span><br></pre></td></tr></table></figure>
<p>图片地址两边不用加引号，当然加了也没问题。<br>要改变默认的水平和垂直重复效果，可以修改 background-repeat 属性；要改变背景图片的起点，可以修改 background-position 属性。</p>
<h3 id="背景重复"><a href="#背景重复" class="headerlink" title="背景重复"></a>背景重复</h3><p>控制背景重复的方式background-repeat属性有四个值。默认值是repeat，效果就是按水平和垂直方向都重复，直至填满元素的背景区域为止。另外三个值分别是只在水平方向重复的repeat-x、只在垂直方向上重复的repeat-y和在任意方向上都不重复（或者说只让背景图片显示一次）的no-repeat。<br>，CSS3 还规定另外两个值（但尚未得到浏览器支持），以<br>控制背景图片重复确切的次数，即所有图片都是完整的，不会出现半张图片的现象。<br> background-repeat:round：为确保图片不被剪切，通过调整图片大小来适应背景<br>区域。<br> background-repeat:space，为确保图片不被剪切，通过在图片间添加空白来适应<br>背景区域。</p>
<h3 id="背景位置"><a href="#背景位置" class="headerlink" title="背景位置"></a>背景位置</h3><p>用于控制背景位置的background-position属性，是所有背景属性中最复杂的。bancground-position属性有5个关键值，分别是top、left、bottom、right和center，这些关键字中的任意恋歌组合起来都可以作为该属性的值。比如，top right 表示把图片放在元素的右上角位置，center center 把图片放在元素的中心位置。<br>千万要注意，background-position 属性同时设定元素和图片的原点。原点决定了元素和图片中某一点的水平和垂直坐标。默认情况下，background-position 的原点位于左上角。换句话说，元素的左上角和图片的左上角是对齐的，随后图片向各个方向重复，都是以左上角为起点。</p>
<p>背景位置的值<br>设定背景位置时可以使用三种值：关键字、百分比、绝对或相对单位的数值。可以使用两个值分别设定水平和垂直位置。<br>关键字指的顺序不重要，left bottom 和 bottom left 意思相同。为了设定的值在所有浏览器中都有效，最好不要混用关键字值与数字值。<br>使用数值（比如 40% 30%）时，第一个值表示水平位置，第二个值表示垂直位置。要是只设定一个值，则将其用来设定水平位置，而垂直位置会被设为 center。<br>在使用关键字和百分比值的情况下，设定的值同时应用于元素和图片。换句话说，如果设定了33% 33%，则图片水平 33%的位置与元素水平 33%的位置对齐。垂直方面也一样。图 3-37 所示也是一个例子，那是通过 center center 把图片的中心点定位在了元素的中心点。<br>像素之类的绝对单位数值就不一样了。要是用像素单位来设定位置，那么图片的左上角会被放在距离元素左上角指定位置的地方。<br>有意思的是，还可以使用负值。这样就可以把图片的左上角定位到元素外部，从而在元素中只能看到部分图片。当然，给图片设定足够大的正值，也可以把图片的右下角推到元素外部，从而在元素中也只能看到部分图片。位于元素外部的那部分图片不会显示。</p>
<h3 id="背景尺寸"><a href="#背景尺寸" class="headerlink" title="背景尺寸"></a>背景尺寸</h3><p>background-size是CSS3规定的属性，但却得到了浏览器很好的支持。这个属性用来控制背景图片的尺寸，可以给他设定的值及含义如下。<br> 50%：缩放图片，使其填充背景区的一半。<br> 100px 50px：把图片调整到 100 像素宽，50 像素高。<br> cover：拉大图片，使其完全填满背景区；保持宽高比。<br> contain：缩放图片，使其恰好适合背景区；保持宽高比。</p>
<h3 id="背景粘附"><a href="#背景粘附" class="headerlink" title="背景粘附"></a>背景粘附</h3><p>background-attachment 属性控制滚动元素内的背景图片是否随元素滚动而移动。这个属性的默认值是 scroll，即背景图片随元素移动。如果把它的值改为 fixed，那么背景图片不会随元素滚动而移动。<br>background-attachment:fixed 最常用于给 body 元素中心位置添加淡色水印，让水印不随页面滚动而移动。</p>
<h3 id="简写背景属性"><a href="#简写背景属性" class="headerlink" title="简写背景属性"></a>简写背景属性</h3><p>background 属性可以用来设定所有背景相关的值。比如，前面那个 backgroundattachment 的例子使用简写的 background 属性，可以写成这样一条规则：body {background:url(images/watermark.png) center #fff no-repeat contain fixed;} 声明中少写了哪个属性的值（比如没写 no-repeat），就会使用相应属性的默认值（repeat）。</p>
<h3 id="多背景图片"><a href="#多背景图片" class="headerlink" title="多背景图片"></a>多背景图片</h3><p>CSS3还可以给元素背景添加多个背景图片</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; </span><br><span class="line"> <span class="attribute">height</span>:<span class="number">150px</span>; </span><br><span class="line"> <span class="attribute">width</span>:<span class="number">348px</span>; </span><br><span class="line"> <span class="attribute">border</span>:<span class="number">2px</span> solid <span class="number">#aaa</span>; </span><br><span class="line"> <span class="attribute">margin</span>:<span class="number">20px</span> auto; </span><br><span class="line"> <span class="attribute">font</span>:<span class="number">24px</span>/<span class="number">150px</span> helvetica, arial, sansserif; </span><br><span class="line"> <span class="attribute">text-align</span>:center; </span><br><span class="line"> <span class="attribute">background</span>: </span><br><span class="line"> <span class="built_in">url</span>(images/turq_spiral.png) <span class="number">30px</span> -<span class="number">10px</span> no-repeat, </span><br><span class="line"> <span class="built_in">url</span>(images/pink_spiral.png) <span class="number">145px</span> <span class="number">0px</span> no-repeat, </span><br><span class="line"> <span class="built_in">url</span>(images/gray_spiral.png) <span class="number">140px</span> -<span class="number">30px</span> no-repeat, <span class="number">#ffbd75</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 CSS 中，我把每张图片的声明都单独放在了一行里，以逗号分隔，以便看清它们的位置、重复的设定值。为了防止图片加载失败时元素背景处于默认的透明状态，这里也在最后一条声明中加上了背景颜色（加粗的值）。要注意的是，代码中先列出的图片显示在上方，或者说，更接近前景。</p>
<h3 id="背景渐变"><a href="#背景渐变" class="headerlink" title="背景渐变"></a>背景渐变</h3><p>渐变就是在一定长度内两种或多种颜色之间自然的过渡。渐变分两种，一种线性渐变，一种放射性渐变。线性渐变从元素的一端延伸到另一端，放射性渐变则从元素内一点向四周发散。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'gradient1'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'gradient2'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'gradient3'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*为元素盒子添加样式*/</span> </span><br><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line"> <span class="attribute">height</span>:<span class="number">150px</span>; </span><br><span class="line"> <span class="attribute">width</span>:<span class="number">200px</span>; </span><br><span class="line"> <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ccc</span>; </span><br><span class="line"> <span class="attribute">float</span>:left; </span><br><span class="line"> <span class="attribute">margin</span>:<span class="number">16px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*例 1：默认为从上到下*/</span> </span><br><span class="line"><span class="selector-class">.gradient1</span> &#123; </span><br><span class="line"> <span class="attribute">background</span>:<span class="built_in">linear-gradient</span>(#e86a43, #fff); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*例 2：从左到右*/</span></span><br><span class="line"><span class="selector-class">.gradient2</span> &#123; </span><br><span class="line"> <span class="attribute">background</span>:<span class="built_in">linear-gradient</span>(left, #<span class="number">64</span>d1dd, #fff); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*例 3：左上到右下*/</span> </span><br><span class="line"><span class="selector-class">.gradient3</span> &#123; </span><br><span class="line"> <span class="attribute">background</span>:<span class="built_in">linear-gradient</span>(-<span class="number">45deg</span>, #e86a43, #fff); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.渐变点<br>渐变点就是渐变方向上的点，可以在这些点上设定颜色和不透明度。通过设定下一个渐变点的颜色值，就可以控制渐变的效果。可以添加任意多个渐变点。渐变点的位置一般使用整个渐变宽度的百分比来表示。图 3-41 展示了使用渐变点后的四种渐变效果。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例 1：50%处有一个渐变点*/</span> </span><br><span class="line"><span class="selector-class">.gradient1</span> &#123; </span><br><span class="line"> <span class="attribute">background</span>:<span class="built_in">linear-gradient</span>(#<span class="number">64</span>d1dd, #fff <span class="number">50%</span>, #<span class="number">64</span>d1dd); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*例 2：20%和 80%处有两个渐变点*/</span> </span><br><span class="line"><span class="selector-class">.gradient2</span> &#123; </span><br><span class="line"> <span class="attribute">background</span>:<span class="built_in">linear-gradient</span>(#e86a43 <span class="number">20%</span>, #fff <span class="number">50%</span>, #e86a43 <span class="number">80%</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*例 3：25%、50%、75%处有三个渐变点*/</span> </span><br><span class="line"><span class="selector-class">.gradient3</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">linear-gradient</span>(#<span class="number">64</span>d1dd, #fff <span class="number">25%</span>, #<span class="number">64</span>d1dd <span class="number">50%</span>, #fff <span class="number">75%</span>, </span><br><span class="line">#<span class="number">64</span>d1dd); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*例 4：为同一个渐变点设定两种颜色可以得到突变效果*/</span> </span><br><span class="line"><span class="selector-class">.gradient4</span> &#123; </span><br><span class="line"> <span class="attribute">background</span>:<span class="built_in">linear-gradient</span>(#e86a43, #fff <span class="number">25%</span>, #<span class="number">64</span>d1dd <span class="number">25%</span>, #<span class="number">64</span>d1dd <span class="number">75%</span>, </span><br><span class="line">#fff <span class="number">75%</span>, #e86a43); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图 3-41 中的例 1 在 50%处包含一个渐变点，因此渐变效果是从开始颜色到渐变点颜色（白色），然后再从渐变点颜色到结束颜色。注意，开始和结束位置如果没有声明，则默认为 0%和 100%。<br>如果不是使用百分比或其他值声明渐变点的位置，则三种颜色会均匀分布于整个渐变，其实际位置是 0%、50%和 100%。<br>例 2 演示了起点和终点不是 0%和 100%时的情形。此时，在第一个渐变点（20%）之前，是第一个渐变点声明的实色，而在该点之后，则是从该颜色到下一个渐变点颜色的过渡。同样，在最后一个渐变点（80%）之后，该渐变点的颜色会以实色扩展到元素结束。<br>例 3 简单展示了相同颜色在几个渐变点之间变来变去的效果。例 4 展示了在同一个渐变点声明两种不同的颜色，能实现一种突变的效果。</p>
<p>2.放射性渐变<br>放射性渐变比线性渐变复杂那么一点点，因为可用的控制点多一些。如果你写过程序，从属性值中的括号就可以看出，渐变属性其实是函数。什么是函数？函数可以接收参数，然后根据这些参数来生成渐变。在创建放射性渐变时，可以使用参数指定形状、位置、尺寸、颜色和不透明度。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.gradient1</span> &#123; </span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">-webkit-radial-gradient</span>(#fff, #<span class="number">64</span>d1dd, #<span class="number">70</span>aa25); </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.gradient2</span> &#123; </span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">-webkit-radial-gradient</span>(circle, #fff, #<span class="number">64</span>d1dd, #e86a43); </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.gradient3</span> &#123; </span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">-webkit-radial-gradient</span>(<span class="number">50px</span> <span class="number">30px</span>, circle, #fff, #<span class="number">64</span>d1dd, </span><br><span class="line">#<span class="number">4947</span>ba); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例 2 设定了形状关键字 circle，于是渐变的形状变得均匀，并在元素最近的边达到了终点，形成了圆形渐变。而长边剩下的区域则填充了终点的颜色。例 3 中的位置参数 50px 30px 把渐变的圆心放到了靠近左上角的位置。</p>
<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>flex是flexible box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。热和一个容器都可以指定为flex布局。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>行内元素也可以使用flex布局。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>webkit内核的浏览器，必须加上-webkit前缀。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，设为flex布局以后，子元素float、clear和veritical-align属性将失效。</strong></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用flex布局的元素，成为flex容器（flex container），简称“容器”。它所有子元素自动成为容器成员，称为flex项目（flex item），简称“项目”。<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><p>一下6个属性设置在容器上：<br>1.flex-direction<br>2.flex-wrap<br>3.flex-flow<br>4.justify-content<br>5.align-items<br>6.align-content</p>
<h4 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h4><p>flex-direction属性决定株洲的方向（即项目的排列方向）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可能有四个值<br>1.row（默认值）：主轴为水平方向，起点在左端。<br>2.row-reverse：主轴为水平方向，起点在右端。<br>3.column：主轴为垂直方向，起点在上沿。<br>4.column-reverse：主轴为垂直方向，起点在下沿。</p>
<h4 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h4><p>默认情况下，项目都排在一条线（又称“轴线”上）。flex-wrap属性定义，如果一条轴线排不下，如何换行</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可能取三个值：<br>1.nowrap（默认）：不换行。<br>2.wrap：换行，第一行在上方。<br>3.wrap-reverse：换行，第一行在下方。</p>
<h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h4><p>justify-content属性定义了项目在主轴上的对齐方式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。<br>1.flex-start（默认值）：左对齐<br>2.flex-end：右对齐<br>3.center： 居中<br>4.space-between：两端对齐，项目之间的间隔都相等。<br>5.space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p>
<h4 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h4><p>align-items属性定义项目在交叉轴上如何对齐。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<p>1.flex-start：交叉轴的起点对齐。<br>2.flex-end：交叉轴的终点对齐。<br>3.center：交叉轴的中点对齐。<br>4.baseline: 项目的第一行文字的基线对齐。<br>5.stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</p>
<h4 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h4><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该属性可能取6个值。</p>
<p>1.flex-start：与交叉轴的起点对齐。<br>2.flex-end：与交叉轴的终点对齐。<br>3.center：与交叉轴的中点对齐。<br>4.space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>5.space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>6.stretch（默认值）：轴线占满整个交叉轴。</p>
<h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><p>以下6个属性设置在项目上<br>1.order<br>2.flex-grow<br>3.flex-shrink<br>4.flex-basis<br>5.flex<br>6.align-self</p>
<h4 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h4><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h4><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h4 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h4><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</p>
<h4 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h4><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目本来的大小。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可以设为跟width或height属性一样的值，则项目将占据固定空间。</p>
<h4 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h4><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Basic values */</span></span><br><span class="line"><span class="selector-tag">flex</span>: <span class="selector-tag">auto</span>;</span><br><span class="line"><span class="selector-tag">flex</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">flex</span>: <span class="selector-tag">none</span>;</span><br><span class="line"><span class="selector-tag">flex</span>: 2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* One value, unitless number: flex-grow */</span></span><br><span class="line"><span class="selector-tag">flex</span>: 2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* One value, width/height: flex-basis */</span></span><br><span class="line"><span class="selector-tag">flex</span>: 10<span class="selector-tag">em</span>;</span><br><span class="line"><span class="selector-tag">flex</span>: 30<span class="selector-tag">px</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Two values: flex-grow| flex-basis */</span></span><br><span class="line"><span class="selector-tag">flex</span>: 1 30<span class="selector-tag">px</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tow values: flex-grow| flex-shrink */</span></span><br><span class="line"><span class="selector-tag">flex</span>: 2 2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Three values: flex-grow| flex-shrink| flex-basis */</span></span><br><span class="line"><span class="selector-tag">flex</span>: 2 2 10%;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="selector-tag">flex</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">flex</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">flex</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure>
<p>flex属性可以指定1个，2个或3个值。<br><strong>单值语法</strong>:<br>值必须为以下其中之一：<br>1.一个无单位数（<number>):它会被当做<flex-grow>的值。<br>2.一个有效的宽度（width）值：它会被当做<flex-basis>的值<br>3.关键字none，auto或initial</p>
<p><strong>双值语法</strong>:<br>第一个值必须为一个无单位数，并且它会被当作 <flex-grow> 的值。第二个值必须为以下之一：<br>1.一个无单位数：它会被当作 <flex-shrink> 的值。<br>2.一个有效的宽度值: 它会被当作 <flex-basis> 的值。</p>
<p><strong>三值语法</strong>:<br>1.第一个值必须为一个无单位数，并且它会被当作 <flex-grow> 的值。<br>2.第二个值必须为一个无单位数，并且它会被当作  <flex-shrink> 的值。<br>3.第三个值必须为一个有效的宽度值， 并且它会被当作 <flex-basis> 的值。</p>
<h4 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h4><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: auto | flex-start | flex-end | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0/" data-id="ck9ghxoou000r7kr9ey4w5p6j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-迭代器和生成器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" class="article-date">
  <time datetime="2020-04-26T02:04:36.823Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/">迭代器和生成器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="循环的问题"><a href="#循环的问题" class="headerlink" title="循环的问题"></a>循环的问题</h4><p>考虑如下代码区：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = colors.length; i &lt;len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(color[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个循环非常直观，然而当它被嵌套使用并要追踪多个变量时，情况就会变得非常复杂。额外的复杂度会引发错误，而for循环的样板性也增加了自身出错的可能性，因为相似的代码会被卸载多个地方。迭代器正式用来解决此问题的。</p>
<h4 id="何为迭代器"><a href="#何为迭代器" class="headerlink" title="何为迭代器"></a>何为迭代器</h4><p>迭代器是被设计专用于迭代的对象，带有特定接口。所有迭代器对象都拥有next()方法，会返回一个结果对象。该结果对象有两个属性，对应下一个值的value，一集一个布尔类型的done，其值为true时表示没有更多值可供使用。迭代器持有一个指向集合位置的内部指针，每当调用了next()方法，迭代器就会返回相应的下一个值。<br>若在最后一个值返回后再调用next()，所返回的done属性值回事true，并且value属性值会是迭代器自身的返回值(return value，及时使用return语句明确返回值)。该“返回值”不是原数据集的一部分，去会成为相关数据的最后一个片段，或在迭代器未提供返回值时使用undefined。迭代器自身的返回值类似于函数的返回值，事项调用者返回信息的最后手段。<br>在ES5中床加一个迭代器代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> done = (i &gt;= items.length)</span><br><span class="line">            <span class="keyword">var</span> value = !done?items[i++] : <span class="literal">undefined</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: done,</span><br><span class="line">                valued: value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<h4 id="何为生成器"><a href="#何为生成器" class="headerlink" title="何为生成器"></a>何为生成器</h4><p><strong>生成器（generator）是能返回一个迭代器的函数。</strong>生成器函数由放在function关键字之后的一个星号（*)来表示，并能使用心得yield关键字。将星号紧跟在function关键字之后，或是在中间留出空格，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成器能想正规函数那样被调用，但会返回一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p>createIterator()前面的星号让此函数变成一个生成器。yield关键字也是ES6新增的。<br>生成器函数最有意思的方面是在每个yield语句后停止执行。例如，此代码中yield 1执行后，该函数将不会再执行任何操作，直到迭代器的next()方法被调用，此时才继续执行yield 2。<br>yield关键字可以和值或是表达式一起使用，因此可以通过生成器给迭代器添加项目，而不是机械化地讲项目一个个列出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p>生成器函数是ES6的一个重要特性，并且因为它就是函数，就能被用于所有可以使用函数的位置。<br>yield关键字只能用在生成器内部，用于其他任意位置都是语法错误，即使在生成器内部函数中也不行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 语法错误</span></span><br><span class="line">        <span class="keyword">yield</span> item + i</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管yield严格位于createIterator()内部，此代码仍然有语法错误，因为yield无法穿越函数边界。<strong>从这一点来说，yield和return非常相似，在一个被浅套的函数中无法将值返回给包含它的函数。</strong></p>
<h4 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h4><p>可以使用函数表达式来创建一个生成器，只要在function官架子与圆括号之间使用一个星号（*）即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createIterator = <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;items.length; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> itertor = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p>此例子中，createIterator()是一个生成器函数表达式，而不是一个函数声明。<br>**不能讲箭头函数创建为生成器。</p>
<h4 id="生成器对象方法"><a href="#生成器对象方法" class="headerlink" title="生成器对象方法"></a>生成器对象方法</h4><p>由于生成器就是函数，因此也可以被添加到对象中。例如，可以在ES5风格的对象字面量中使用函数表达式来创建一个生成器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    createIterator: <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为ES6中语法</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    *createIterator(items) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h4 id="可迭代对象与for循环"><a href="#可迭代对象与for循环" class="headerlink" title="可迭代对象与for循环"></a>可迭代对象与for循环</h4><p>与迭代器紧密相关的是可迭代对象（iterable）是包含Symbol.iterator属性的对象。这个Symbol.iterator知名符号定义了未指定对象返回迭代器的函数。在ES6中，所有的集合对象（数组，Set和Map）一字符串都是可迭代对象。因此他们都被指定了默认的迭代器<br>之前提到过在for循环中追踪索引的问题。迭代器是解决此问题的第一部分；for-of循环则是第二部分：它完全删除了追踪集合索引的需要。代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> values) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在不可迭代对象、null、或者undefined上使用for-of语句会抛出错误TypeError: Cannot read property ‘Symbol(Symbol.iterator)’ of null。</p>
<h4 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h4><p>可以使用Symbol.iterator来访问对象上的默认迭代器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>

<p>既然Symbol.iterator指定了默认的迭代器，就可以使用它来检测一个对象是否能进行迭代：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">'hello'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakMap</span>()))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakSet</span>()))</span><br></pre></td></tr></table></figure>

<p>创建可迭代对象<br>利用Symbol.iterator属性， 让自定义的对象成为可迭代对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">    items: [],</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collection.items.push(<span class="number">1</span>)</span><br><span class="line">collection.items.push(<span class="number">2</span>)</span><br><span class="line">collection.items.push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内置迭代器"><a href="#内置迭代器" class="headerlink" title="内置迭代器"></a>内置迭代器</h4><p>迭代器是ES6的一个重要部分，因此，无需为许多内置类型创建自己的迭代器。</p>
<h5 id="集合的迭代器"><a href="#集合的迭代器" class="headerlink" title="集合的迭代器"></a>集合的迭代器</h5><p>ES6具有三种集合对象类型：数组，Map与Set。这三种类型都拥有如下迭代器，有助于探索它们的内容：<br>entries(): 返回一个包含键值对的迭代器；<br>values(): 返回一个包含集合中的值得迭代器；<br>keys(): 返回一个包含集合中的键的迭代器</p>
<p>entries()迭代器<br>entries()迭代器会在每次next()被调用时返回一个双项数组，次数组代表了集合中每个元素的键与值：对于数组来说，第一项是数值索引；对于Set，第一项也是值（因为它的值也会被视为键）；对于Map，第一项就是键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>])</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'understanding es6'</span>)</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'ebook'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> colors.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> tracking.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> data.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用console.log()输出一下内容：<br>[0, “red”]<br>[1, “green”]<br>[2, “blue”]<br>[1234, 1234]<br>[5678, 5678]<br>[9012, 9012]<br>[“title”, “Understanding ES6”]<br>[“format”, “ebook”]<br>values()迭代器<br>values()迭代器仅仅能返回存储在集合内的值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>])</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'understanding es6'</span>)</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'ebook'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> colors.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> tracking.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> data.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：<br>“red”<br>“green”<br>“blue”<br>12<br>34<br>56<br>“Understanding ES6”<br>“ebook”</p>
<p>keys()迭代器<br>keys()迭代器能返回集合中的每个键。对于数组来说，只返回数值类型的键，不返回数组的其他自有属性；Set的键与值是相同的，因此它的keys()与values()返回了相同的迭代器；对于Map，keys()迭代器返回了每个不重复的键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>])</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> Mpa()</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'understanding es6'</span>)</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'ebook'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> colors.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> tracking.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> data.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：<br>0<br>1<br>2<br>12<br>34<br>56<br>“title”<br>“format”</p>
<p>集合类型的默认迭代器<br>当for-of循环没有显示指定迭代器时，每种集合类型都有一个默认的迭代器供循环使用。values()方法是数组与Set的默认迭代器，而entries()方法则是Map的默认迭代器。在for-of循环中使用集合对象时，这些默认迭代器会让处理更容易一些。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>])</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'understanding es6'</span>)</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'print'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> colors) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> tracking) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> data) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：<br>“red”<br>“green”<br>“blue”<br>1234<br>5678<br>9012<br>[“title”, “Understanding ES6”]<br>[“format”, “print”]</p>
<h4 id="字符串的迭代器"><a href="#字符串的迭代器" class="headerlink" title="字符串的迭代器"></a>字符串的迭代器</h4><p>从ES5发布开始，JS的字符串就慢慢变得越来越像数组。例如ES5标准化了字符串的方括号表示法，用于访问其中的字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">'A B'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;message.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(message[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：<br>A</p>
<p>B</p>
<h4 id="NodeList的迭代器"><a href="#NodeList的迭代器" class="headerlink" title="NodeList的迭代器"></a>NodeList的迭代器</h4><p>文档对象模型（DOM）具有一种NodeList类型，用于表示页面文档中元素的集合。对于需要书写在浏览器中运行的JS代码的开发者，要理解NodeList对象与数组之间的差异总是稍有困难。NodeList对象与数组都使用了length属性来表明项的数量，并且都使用方括号表示法来访问各个项。然而本质上来说，NodeList与数组的行为是完全不同的，这回引发许多混乱。<br>随着默认迭代器被附加到ES6，DOM关于NodeList的规定也包含了一个默认迭代器（此规定在HTML规范而非ES6规范中），其表现方式与数组的默认迭代器一致。这意味着你可以讲NodeList用于for-of循环，或用于其他使用对象默认迭代器的场合。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> div <span class="keyword">of</span> divs) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(div.id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩展运算符与非数组的可迭代对象"><a href="#扩展运算符与非数组的可迭代对象" class="headerlink" title="扩展运算符与非数组的可迭代对象"></a>扩展运算符与非数组的可迭代对象</h4><p>扩展运算符（…)能作用于所有可迭代对象，并且会使用默认迭代器来判断需要哪些值。<strong>所有的值都从迭代器中被读取出来并插入数组</strong>，遵循迭代器返回值的顺序。(利用扩展运算符还可以进行深度复制)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4])</span><br><span class="line">let array = [...<span class="keyword">set</span>]</span><br><span class="line">console.log(array)</span><br><span class="line">let map = new Map([['name', 'daming'], ['age', 25]])</span><br><span class="line">let array2 = [...map]</span><br><span class="line">console.log(array2)</span><br></pre></td></tr></table></figure>
<p>可以不限次数的在数组字面量中使用扩展运算符，而且可以在任意位置使用扩展运算符将可迭代对象的多个项插入数组，这些项在新数组中将会出现在扩展运算符对应的位置，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> smallNumbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">bigNumbers = [<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>],</span><br><span class="line">allNumbers = [<span class="number">0</span>, ...smallNumbers, ...bigNumbers]</span><br><span class="line"><span class="built_in">console</span>.log(allNumbers.length)</span><br><span class="line"><span class="built_in">console</span>.log(allNumbers)</span><br></pre></td></tr></table></figure>
<h4 id="迭代器的高级功能"><a href="#迭代器的高级功能" class="headerlink" title="迭代器的高级功能"></a>迭代器的高级功能</h4><p>使用迭代器的基本功能，并使用生成器来方便地创建迭代器，就可以完成很多工作了。然而，在单纯迭代集合的值之外的任务中，迭代器会显得更加强大。在ES6的开发过程中，许多独特的思想与模式出现了，激励着规定者去添加更多的功能。</p>
<h4 id="传递参数给迭代器"><a href="#传递参数给迭代器" class="headerlink" title="传递参数给迭代器"></a>传递参数给迭代器</h4><p>本章中的范例已经展示了迭代器能够将值传递出来，通过next()方法或者在生成器中使用yield都可以。但还可以通过next()方法向迭代器传递参数。当一个参数被传递给next()方法时，该参数就会成为生成器内部yield语句的值。这种能力对于更多高级功能（例如异步编程）来说是非常重要的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> zero = <span class="number">6</span></span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> zero + <span class="number">1</span>     <span class="comment">//6 + 1</span></span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>   <span class="comment">//4 + 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(second)            <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">yield</span> second + <span class="number">3</span>               <span class="comment">//5 + 3</span></span><br><span class="line">    <span class="built_in">console</span>.log(second)            <span class="comment">//5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">8</span>))   <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>))  <span class="comment">//&#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">5</span>))  <span class="comment">//&#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>对于next()的首次调用是一个特殊情况，传给它的任意参数都会被忽略。由于传递给next()的参数会成为yield语句的值，该yield语句指的是上次生成器中断执行处的语句；而next()方法第一次被调用时生成器函数才刚刚开始执行，没有所谓的上一次中断处的yield语句”可供赋值。因此在第一次调用next()时，不存在任何向其传递参数的理由。</p>
<h4 id="在迭代器中抛出错误"><a href="#在迭代器中抛出错误" class="headerlink" title="在迭代器中抛出错误"></a>在迭代器中抛出错误</h4><p>能传递给迭代器的不仅是数据，还可以是错误条件。迭代器可以选择实现一个throw()方法，用于指示迭代器应在恢复执行时抛出一个错误。这是对异步变成来说很重要的一个能力。同事也会增加生成器内部的灵活度，能够既模仿返回一个值，又模仿抛出错误（也就是退出函数的两种方式）。可以传递一个错误对象给throw()方法，当迭代器继续进行处理时应当抛出此错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> second + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Boom'</span>)))</span><br></pre></td></tr></table></figure>
<p>输出如下：<br>{ value: 1, done: false }<br>{ value: 6, done: false }<br>C:\Users\Administrator\Desktop\atHome.js:116<br>    let second = yield first + 2<br>                 ^<br>Error: Boom<br>    at Object.<anonymous> (C:\Users\Administrator\Desktop\atHome.js:124:28)<br>    at Module._compile (module.js:569:30)<br>    at Object.Module._extensions..js (module.js:580:10)<br>    at Module.load (module.js:503:32)<br>    at tryModuleLoad (module.js:466:12)<br>    at Function.Module._load (module.js:458:3)<br>    at Function.Module.runMain (module.js:605:10)<br>    at startup (bootstrap_node.js:158:16)<br>    at bootstrap_node.js:575:3<br>[Finished in 0.4s]<br>利用这些，可以在生成器内部使用一个try-catch块来捕捉这种错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> second</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        second = <span class="keyword">yield</span> first + <span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        second = <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> second + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>)); <span class="comment">// "&#123; value: 6, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom"</span>))); <span class="comment">// "&#123; value: 9, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<h4 id="生成器的return语句"><a href="#生成器的return语句" class="headerlink" title="生成器的return语句"></a>生成器的return语句</h4><p>由于生成器是函数，可以在内部使用return语句，既可以让生成器早一点退出执行，也可以指定在next()的最后一次调用时的返回值。之前大多数例子中，对迭代器上的next的最后一次调用都返回了undefined，但还可以像其他函数中那样，使用return来指定另一个返回值。生成器内，return表明所有的处理已经完成，因此done属性会被设定为true，而如果提供了返回值，就会被用于value字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>
<p>也可以指定一个返回值，会被用于最终返回的结果对象中的value字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())      <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())      <span class="comment">// "&#123; value: 42, done: true &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())      <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<h4 id="生成器委托"><a href="#生成器委托" class="headerlink" title="生成器委托"></a>生成器委托</h4><p>在某些情况下，将两个迭代器的值合并器一起会更有用。<strong>生成器可以用星号（*）配合yield这一特殊形式来委托其他的迭代器。</strong>正如生成器的定义，星号出现在何处是不重要的，只要落在yield关键字与生成器函数名之间即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNuberIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createColorIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'red'</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'green'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> *createNumberIterator()</span><br><span class="line">    <span class="keyword">yield</span> *createColorIterator()</span><br><span class="line">    <span class="keyword">yield</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">// "&#123; value: "red", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">// "&#123; value: "green", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">// "&#123; value: true, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<p>生成器委托也能让你进一步使用生成器的返回值。这是访问这些返回值的最简单方式，并且<br>在执行复杂任务时会非常有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createRepeatingIterator</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"repeat"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> *createNumberIterator()</span><br><span class="line">    <span class="keyword">yield</span> *createRepeatingIterator(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>
<p>注意值 3 从未在对于 next() 方法的任何调用中被输出。当前它仅仅存在于<br>createCombinedIterator() 生成器内部。但你也可以通过添加另一个 yield 语句来输出这个<br>值，正如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createRepeatingIterator</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"repeat"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> *createNumberIterator()</span><br><span class="line">    <span class="keyword">yield</span> result</span><br><span class="line">    <span class="keyword">yield</span> *createRepeatingIterator(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<h4 id="异步任务运行"><a href="#异步任务运行" class="headerlink" title="异步任务运行"></a>异步任务运行</h4><p>JS的异步编程是一把双刃剑：简单任务很容易用异步实现，但复杂任务就会变成代码组织方面的苦差事。由于生成器能让你在执行过程中有效的暂停代码操作，它就开启了与异步编程相关的许多可能性。<br>执行一步操作的传统铜方式是调用一个包含回调的函数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(<span class="string">'config.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, contents</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    doSomethingWith(contents)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Done'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能使用文件名与一个回调函数去调用fs.readFile()方法，在读取操作结束之后，回调函数就会被调用。此回调函数查看是否存在错误，若否则处理返回的contents数据。当拥有数量少而有限的任务需要完成时，这么做很有效；然而当需要嵌套回调函数，或者要按顺序处理一系列异步任务时，此方式就会非常麻烦了。这种场合下生成器与yield会很有用。</p>
<h4 id="一个简单的任务运行器"><a href="#一个简单的任务运行器" class="headerlink" title="一个简单的任务运行器"></a>一个简单的任务运行器</h4><p>由于yield能停止运行，并且在重新开始运行前等待next()方法被调用，就可以在没有回调函数的情况下实现异步调用。首先，需要一个能够调用生成器并且启用迭代器的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建迭代器，让它在别处可用</span></span><br><span class="line">    <span class="keyword">let</span> task = taskDef()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归使用函数来保持对next()的调用</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">            result = task.next()</span><br><span class="line">            setp()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>run()函数接受一个任务定义（即一个生成器函数）作为参数，它会调用生成器来创建一个迭代器，并将迭代器放在task变量上。task变量放在函数的外层，因此它可以被函数内的其他函数访问到。第一次对next()的调用启动了迭代器，结果存储下以便稍后使用。step()函数查看result.done是否为false，如果是就在递归调用自身之前调用next()方法。每次调用next()都会把返回的结果保存在result变量上，它总是会被最新的信息所重写。对于step()的出事调用启动了处理过程就，该过程会查看result.done来判断是否还有更多要做的工作。</p>
<p>配合这个已实现的 run() 函数，你就可以运行一个包含多条 yield 语句的生成器，就像这<br>样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此例只是将三个数值输出到控制台，单纯用于表明对 next() 的所有调用都已被执行。然<br>而，仅仅使用几次 yield 并不太有意义，下一步是要把值传进迭代器并获取返回数据。</p>
<h4 id="带数据的任务运行"><a href="#带数据的任务运行" class="headerlink" title="带数据的任务运行"></a>带数据的任务运行</h4><p>传递数据给任务运行器最简单的方式，就是把yield返回的值传入下一次的next()调用。为此，仅需传递result.value,正如一下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> task = taskDef()</span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">            result = task.next(result.value)</span><br><span class="line">            step()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 result.value 作为参数被传递给了 next() ，这样就能在 yield 调用之间传递数据<br>了，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 1</span></span><br><span class="line">    value = <span class="keyword">yield</span> value + <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 4</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="异步任务运行器"><a href="#异步任务运行器" class="headerlink" title="异步任务运行器"></a>异步任务运行器</h4><p>上个例子只是在yield之间来回传递静态数据，但等待一个异步处理与此稍微有点差异。任务运行器需要了解回调函数，并了解如何使用它们。并且由于yield表达式将它们的值传递给了任务运行器，这就意味着函数调用都必须返回一个值，并以某种方式标明改返回值是个异步操作调用，二人舞运行器应当等待此操作。<br>此处是将返回值标明为异步操作的一种方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码的目的是：任何打算让人物运行器调用的函数，都应当返回一个能够执行回调函数的函数。fetchData()函数所返回的函数能接受一个回调函数作为其参数，当返回的函数被调用时，它会执行回调函数并附加一点额外数据（即“hi”字符串）。该回调函数需要由任务运行器提供，以确保回调函数能与当前的迭代其正确交互。虽然fetchData()函数是同步的，但能延迟对回调函数的调用，从而轻易地将它改造为异步函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            callback(<span class="literal">null</span>, <span class="string">'hi'</span>)</span><br><span class="line">        &#125;, <span class="number">50</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此版本的fetchData()再调用回调函数之前引入了50毫秒的延迟，说明此模式在同步或一部代码上都能良好运作。<strong>只要保证每个需要被yield调用的函数都遵循此模式。</strong><br>此版本的 fetchData() 在调用回调函数之前引入了 50 毫秒的延迟，说明此模式在同步或异<br>步代码上都能同样良好运作。你只要保证每个需要被 yield 调用的函数都遵循此模式。<br>在深入理解函数如何标注自己是一个异步处理后，你就可以结合这种模式来改造任务运行<br>器。只要 result.value 是一个函数，任务运行器就应当执行它，而不是仅仅将它传递给<br>next() 方法。此处有更新后的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> task = taskDef()</span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value === <span class="string">'function'</span>) &#123;</span><br><span class="line">                result.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        result = task.throw(err)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    result = task.next(data)</span><br><span class="line">                    step()</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = task.next(result.value)</span><br><span class="line">                step()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 result.value 是个函数时（使用 === 运算符来判断），它会被使用一个回调函数进行调<br>用。该回调函数遵循了 Node.js 的惯例，将任何潜在错误作为第一个参数（ err ）传入，而<br>处理结果则作为第二个参数。若 err 非空，也就表示有错误发生，需要使用该错误对象去调<br>用 task.throw() ，而不是调用 task.next() ，这样错误就会在恰当的位置被抛出；若不存<br>在错误， data 参数将会被传入 task.next() ，而其调用结果也会被保存下来。接下来，调<br>用 step() 来继续处理过程。若 result.value 并非函数，它就会被直接传递给 next() 方<br>法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(filename, callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 readFile() 方法接受单个参数，即文件名，并返回一个能执行回调函数的函数。此回<br>调函数会被直接传递给 fs.readFile() 方法，后者会在操作完成后执行回调。接下来你就可<br>以使用 yield 来运行这个任务，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">"config.json"</span>)</span><br><span class="line">    doSomethingWith(contents)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" data-id="ck9ghxop300107kr91272eksz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-代理和反射接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84%E6%8E%A5%E5%8F%A3/" class="article-date">
  <time datetime="2020-04-26T02:04:36.812Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84%E6%8E%A5%E5%8F%A3/">代理和反射接口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ES5和ES6都推进了JS功能的公开。例如，JS运行环境包含一些不可枚举、不可写入的对象属性。ES5引入了Object.defineProperty()方法以便开发者在这方面能够像JS引擎那样做。<br>SE6让开发者能进一步接近JS引擎的能力，这些能力原先只存在于内置对象上。语言通过代理（proxy）暴露在对象上的内部工作，代理是一种封装，能够拦截并改变JS引擎的底层操作。</p>
<h2 id="数组问题"><a href="#数组问题" class="headerlink" title="数组问题"></a>数组问题</h2><p>在ES6之前，JS的数组对象拥有特定的行为方式，无法被开发者在自定义对象中进行模拟。当你给数组元素赋值时，数组的length属性会受到影响，同时也可以通过修改length属性来变更数组的元素。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(colors.length)       <span class="comment">//3</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">'black'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)       <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>])           <span class="comment">//black</span></span><br><span class="line">colors.length = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)       <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>])           <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>])           <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>])           <span class="comment">//green</span></span><br></pre></td></tr></table></figure>
<h2 id="代理与反射是什么"><a href="#代理与反射是什么" class="headerlink" title="代理与反射是什么"></a>代理与反射是什么</h2><p>通过调用new Proxy()，可以创建一个代理用来替代另一个对象（被称为目标），这个代理对目标对象进行了虚拟，因此该代理与该目标对象表面上可以被当作同一个对象来对待。<br>代理允许拦截在目标对象上的底层操作。拦截行为使用了一个能够响应特定操作的函数（被称为陷阱）。<br>被Reflect对象所代表的反射接口，是给底层操作提供默认行为的方法的集合，这些操作是能够被代理重写的。每个代理陷阱都有一个对应的反射方法，每个方法都与对应的陷阱函数重名，并且接受的参数也与之一致。下表总结了这些行为：<br>每个陷阱函数都可以重写 JS 对象的一个特定内置行为，允许你拦截并修改它。如果你仍然需要使用原先的内置行为，则可使用对应的反射接口方法。一旦创建了代理，你就能清晰了解代理与反射接口之间的关系，因此我们最好通过一些例子来进行深入研究。</p>
<h2 id="创建一个简单的代理"><a href="#创建一个简单的代理" class="headerlink" title="创建一个简单的代理"></a>创建一个简单的代理</h2><p>当你使用 Proxy 构造器来创建一个代理时，需要传递两个参数：目标对象以及一个处理器（handler），后者是定义了一个或多个陷阱函数的对象。如果未提供陷阱函数，代理会对所有操作采取默认行为。为了创建一个仅进行传递的代理，你需要使用不包含任何陷阱函数的处理器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line">proxy.name = <span class="string">"proxy"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name); <span class="comment">// "proxy"</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name); <span class="comment">// "proxy"</span></span><br><span class="line">target.name = <span class="string">"target"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name); <span class="comment">// "target"</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name); <span class="comment">// "target"</span></span><br></pre></td></tr></table></figure>
<p>该例中的 proxy 对象将所有操作直接传递给 target 对象。当 proxy.name 属性被赋值为字符串 “proxy” 的时候， target.name 属性也同时被创建，代理对象 proxy 自身其实并没有存储该属性，它只是简单将值传递给 target 对象。同样， proxy.name 与 target.name 的属性值总是相等，因为它们都指向 target.name ，这就意味着：为 target.name 设置一个新值会在 proxy.name 上反映出相同的改变。当然，缺少陷阱函数的代理没什么用，那么若为其定义一个陷阱函数，又会如何？</p>
<h2 id="使用set陷阱函数验证属性值"><a href="#使用set陷阱函数验证属性值" class="headerlink" title="使用set陷阱函数验证属性值"></a>使用set陷阱函数验证属性值</h2><p>假设你想要创建一个对象，并要求其属性值只能是数值，这就意味着该对象的每个新增属性都要被验证，并且在属性值不为数值类型时应当抛出错误。为此你需要定义 set 陷阱函数来重写设置属性值时的默认行为，该陷阱函数能接受四个参数：</p>
<ol>
<li>trapTarget ：将接收属性的对象（即代理的目标对象）；</li>
<li>key ：需要写入的属性的键（字符串类型或符号类型）；</li>
<li>value ：将被写入属性的值；</li>
<li>receiver ：操作发生的对象（通常是代理对象）。<br>Reflect.set() 是 set 陷阱函数对应的反射方法，同时也是 set 操作的默认行为。<br>Reflect.set() 方法与 set 陷阱函数一样，能接受这四个参数，让该方法能在陷阱函数内部被方便使用。该陷阱函数需要在属性被设置完成的情况下返回 true ，否则就要返回 false，而 Reflect.set() 也会基于操作是否成功而返回相应的结果。你需要使用 set 陷阱函数来拦截传入的 value 值，以便对属性值进行验证。这里有个例子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">"target"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">set</span>(trapTarget, key, value, receiver) &#123;</span><br><span class="line">    <span class="comment">// 忽略已有属性，避免影响它们</span></span><br><span class="line">        <span class="keyword">if</span> (!trapTarget.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isNaN</span>(value)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Property must be a number."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 添加一个新属性</span></span><br><span class="line">proxy.count = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.count) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(target.count) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 你可以为 name 赋一个非数值类型的值，因为该属性已经存在</span></span><br><span class="line">proxy.name = <span class="string">"proxy"</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// "proxy"</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// "proxy"</span></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">proxy.anotherName = <span class="string">"proxy"</span></span><br></pre></td></tr></table></figure>
这段代码定义了一个代理陷阱，用于对 target 对象新增属性的值进行验证。当执行proxy.count = 1 时， set 陷阱函数被调用，此时 trapTarget 的值等于 target 对象，key 的值是字符串 “count” ， value 的值是 1 ，而 receiver 的值是 proxy （该参数在本例中并没有被使用）。 target 对象上尚不存在名为 count 的属性，因此代理将value 参数传递给 isNaN() 方法进行验证；如果验证结果是 NaN ，表示传入的属性值不是一个数值，需要抛出错误；但由于这段代码将 count 参数设置为 1 ，验证通过，代理使用一致的四个参数去调用 Reflect.set() 方法，从而创建了一个新的属性。<br>当 proxy.name 被赋值为字符串时，操作成功完成。这是因为 target 对象已经拥有一个name 属性，因此验证时通过调用 trapTarget.hasOwnProperty() 会忽略该属性，这就确保允许在该对象的已有属性上使用非数值的属性值。<br>当 proxy.anotherName 被赋值为字符串时，抛出了一个错误。这是因为该对象上并不存在anotherName 属性，因此该属性的值必须被验证，而因为提供的值不是一个数值，验证过程就会抛出错误。<br>set 代理陷阱允许你在写入属性值的时候进行拦截，而 get 代理陷阱则允许你在读取属性<br>值的时候进行拦截。<h2 id="使用get陷阱函数进行对象外形验证"><a href="#使用get陷阱函数进行对象外形验证" class="headerlink" title="使用get陷阱函数进行对象外形验证"></a>使用get陷阱函数进行对象外形验证</h2></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84%E6%8E%A5%E5%8F%A3/" data-id="ck9ghxoor000p7kr95qlu5cy6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Promise与异步编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/Promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2020-04-26T02:04:36.749Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/Promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">Promise与异步编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JS最强大的一方面就是它能极其轻易地处理异步编程。作为因为互联网而生的语言，JS从一开始就必须能够响应点击或按键之类的用户交互行为。Node.js通过使用回调函数来代替事件，进一步推动了JS中的异步编程。随着越来越多的程序开始使用异步编程，事件与回调函数已不足以支持开发者的所有需求。Promise正是为了解决这方面的问题。<br>Promise是异步编程的另一种选择，它的工作方式类似于在其他语言中延迟并在将来执行作业。一个Promise指定一些要稍后执行的代码（就像事件与回调函数一样），并且也明确标示了作业的代码是否执行成功。能以成功处理或失败处理为基准，将Promise串联在一起，让代码更容易理解，更易调试。</p>
<h2 id="异步编程的背景"><a href="#异步编程的背景" class="headerlink" title="异步编程的背景"></a>异步编程的背景</h2><p>JS引擎建立在单线程事件循环的概念上。单线程（Single-threaded）意味着同一时刻只能执行一段代码，与Java或C++这种允许同时执行多段不同代码的多线程语言形成了反差。多段代码可以同时访问或修改状态，委会并保护这些状态就变成了难题，这也是基于多线程的软件中出现bug的常见根源之一。<br>JS引擎在同一时刻只能执行一段代码，所以引擎无需留意那些“可能”运行的代码。代码会被放置在作业队列（job queue）中，每当一段代码准备执行，它就会被添加到作业队列。当JS引擎结束当前代码的执行后，事件循环就会执行队列中的写一个作业。事件循环（event loop）是JS引擎的一个内部处理线程，能监视代码的执行并管理作业队列。要记住，既然是一个队列，作业就会从队列中的第一个开始，一次运行到最后一个。</p>
<h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><p>当用户点击一个按钮或按下键盘上的一个键时，一个事件（event）–例如 onclick –就被触发了。该事件可能会对此交互进行响应，从而将一个新的作业添加到作业队列的尾部。这就是JS关于异步编程的最基本形式。时间处理程序代码直到事件发生后才会被执行，此时它会拥有合适的上下文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = documet.getElementById(<span class="string">'my-btn'</span>)</span><br><span class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码中，console.log(‘Clicked’)直到button被点击后才会被执行。当button被点击，赋值给onclick的函数就被添加到作业队列的尾部，并在队列前部所有任务结束之后再执行。<br>事件可以很好地工作于简单的交互，但将多个分离的异步调用串联在一起却会很麻烦，因为必须追踪每个事件的事件对象（例如上例中的button）。此外，还须确保所有的事件处理程序都能在事件第一次触发之前被绑定完毕。例如，若button在onclick被绑定之前就被点击，那就不会有任何事发生。因此虽然在响应用户交互或类似的低频功能时。事件很有用，但它在面对更复杂的需求时仍然不够灵活。</p>
<h3 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h3><p>当Node.js被创建时，它通过普及回调函数编程模式提升了异步编程模型。回调函数模式类似于事件模型，因为衣不带吗也会在会面的一个时间点才执行。不同之处在于需要调用的函数（即回调函数）时作为参数传入的，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readFile(<span class="string">'example.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br></pre></td></tr></table></figure>
<p>此例中使用了Node.js惯例，即错误优先（error-first）的回调函数风格。readFile()函数用于读取磁盘中的文件（由第一个参数指定），并在读取完成后执行回调函数（即第二个参数）。如果存在错误，回调函数的err参数回事一个错误对象；否则contents擦书就会以字符串形式包含文件内容。<br>使用回调函数模式，readFile()会立即开始执行，并在开始读取磁盘时暂停。这意味着console.log(‘hi’)会在readFile()被调用后立即进行输出，要早于console.log(contents)的打印操作。当readFile()结束操作后，它会将回调函数以及相关参数作为一个新的作业添加到作业队列的尾部。在之前的作业全部结束后，改作业才会执行。<br>回调函数模式要比事件模型灵活得多，因为使用回调函数串联多个调用会相对容易。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">readFile(<span class="string">'example.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writeFile(<span class="string">'example.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'File was written'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此代码中，对于readFile()的第一次成功调用引出了另一个异步调用，即调用writeFile()函数。注意这两个函数都使用了检查err的统一基本模式。当readFile()执行结束后，它添加一个作业到作业队列，从而导致writeFIle()在之后被调用（假设没有出现错误）。接下来，writeFile()也会在执行结束后项队列添加一个作业。<br>这种模式运作得相当好，但你可能会迅速察觉陷入了回调地狱（ callback hell ），这会在嵌<br>套过多回调函数时发生，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">method1(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    method2(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        method3(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">throw</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            method4(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> err</span><br><span class="line">                &#125;</span><br><span class="line">                method5(result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Promise基础"><a href="#Promise基础" class="headerlink" title="Promise基础"></a>Promise基础</h2><p><strong>Promise是为异步操作的结果所准备的占位符。</strong>函数可以返回一个Promise，而不必订阅一个事件或向函数传递一个回调参数，形式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">'example.txt'</span>)</span><br></pre></td></tr></table></figure>
<p>在此代码中，readFile()实际上并未立即开始读取文件，这将会在稍后发生。此函数反而会返回一个Promise对象仪表室异步读取操作，因此可以在奖励啊再操作它。能对结果进行操作的确切时刻，完全取决于Promise的声明周期是如何进行的。</p>
<h3 id="Promise的声明周期"><a href="#Promise的声明周期" class="headerlink" title="Promise的声明周期"></a>Promise的声明周期</h3><p>每个Promise都会经历一个短暂的声明周期，出事为挂起态（pending state)，这表示异步操作尚未结束。一个挂起的Promise也被认为是未决的（unsettled）。上个例子中的Promise在readFile()函数返回它的时候就是出于挂起态。一旦异步操作结束，Promise就会被认为是已决的（settled），并进入两种可能状态之一。<br>1.已完成（fulfilled）：Promise的异步操作已成功结束；<br>2.已拒绝（rejected）：Promise的异步操作未成功结束，可能是一个错误，或有其他原因导致。<br>内部的[[PromiseState]]属性会被设置为”pending”,”fulfilled”或”rejected”，以反映Promise的状态。该属性并未在Promise对象上被暴露出来，因此无法已变成方式判断Promise到底处于哪种状态。不过可以使用then方法在Promise的状态改变时执行一些特定操作。<br>以下为Promise相关词汇的翻译：</p>
<ol>
<li>pending ：挂起，表示未结束的 Promise 状态。相关词汇“挂起态”。</li>
<li>fulfilled ：已完成，表示已成功结束的 Promise 状态，可以理解为“成功完成”。相关<br>词汇“完成”、“被完成”、“完成态”。</li>
<li>rejected ：已拒绝，表示已结束但失败的 Promise 状态。相关词汇“拒绝”、“被拒<br>绝”、“拒绝态”。</li>
<li>resolve ：决议，表示将 Promise 推向成功态，可以理解为“决议通过”，在 Promise<br>概念中与“完成”是近义词。相关词汇“决议态”、“已决议”、“被决议”。</li>
<li>unsettled ：未决，或者称为“未解决”，表示 Promise 尚未被完成或拒绝，与“挂<br>起”是近义词。</li>
<li>settled ：已决，或者称为“已解决”，表示 Promise 已被完成或拒绝。注意这与“已完<br>成”或“已决议”不同，“已决”的状态也可能是“拒绝态”（已失败）。</li>
<li>fulfillment handler ：完成处理函数，表示 Promise 为完成态时会被调用的函数。</li>
<li>rejection handler ：拒绝处理函数，表示 Promise 为拒绝态时会被调用的函数。</li>
</ol>
<p>then()方法在所有的Promise上都存在，并且接受两个参数。第一个参数是Promise被完成时要调用的函数，与异步操作关联的任何附加数据都会被传入这个完成函数。第二个参数则是Promise被拒绝时要调用的函数，与完成函数相似，拒绝函数会被传入与拒绝相关联的任何附加数据。<br>这种方式实现then()防范的任何对象都被称为一个thenable。所有的Promise都是thenable，繁殖则未必成立。<br>传递个then()的两个参数都是可选的，因此你可以监听完成与拒绝的任意组合形式。例如研究这组then()调用： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">'exapmle.txt'</span>)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 完成</span></span><br><span class="line">    <span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 拒绝</span></span><br><span class="line">    <span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 完成</span></span><br><span class="line">    <span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 拒绝</span></span><br><span class="line">    <span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这三个then()调用都操作在同一个Promise上。第一个调用同时监听了完成与失败；第二个调用只监听了完成，错误不会被报告；第三个则只监听了拒绝，并不报告成功信息。<br>Promise也具有一个catch()方法，其行为等同于值传递拒绝函数给then()。例如，以下的catch()与then()调用时功能等效的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>then()与catch()背后的意图是能组合使用来正确处理异步操作的结果。此系统要优于事件与回调函数，因为它让操作是成功还是失败变得完全清晰（事件模式倾向于在出错时不被触发，而在回调函数模式中你必须始终记得检查错误参数）。只需知道若未给出Promise附加拒绝处理函数，所有的错误就会静默发生。建议始终附加一个拒绝处理函数，及时该程序只是用于打印错误日志。<br>及时完成或拒绝处理函数在Promise已经被解决之后才添加到作业队列，它们仍然会被执行。这允许你随时添加新的完成或拒绝处理函数，并保证它们会被调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">'example,txt'</span>)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(contents)</span><br><span class="line">    promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(contents)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此代码中，完成处理函数又为同一个Promise添加了另一个完成处理函数。这个Promise此刻已经完成了，因此新的处理程序就被添加到任务队列，并在就绪时（前面的作业执行完毕后）被调用。拒绝处理函数使用同样方式工作。</p>
<p>每次调用then()或catch()都会创建一个新的作业，它会在Promise已决议时被执行。但这些作业最终会进入一个完全为Promise保留的作业队列。</p>
<h3 id="创建未决的Promise"><a href="#创建未决的Promise" class="headerlink" title="创建未决的Promise"></a>创建未决的Promise</h3><p>新的Promise使用Promise构造器来创建。此构造器接受单个参数：一个被称为执行器（executor）的函数，包含初始化Promise的代码。该执行器挥别传递两个名为resolve与reject()的函数作为参数。resolve()函数在执行器成功结束时被调用，由于示意该Promise已经准备好被决议（resolved），而reject()函数则表明执行器的操作已失败。下为范例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fs.readFile(fileName, &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            resolve(contents)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>);</span><br><span class="line"><span class="comment">// 同时监听完成与拒绝</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 完成</span></span><br><span class="line"><span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 拒绝</span></span><br><span class="line"><span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此例中，Node.js原生的fs.readFile()异步调用被包装在一个Promise中。执行器要么传递错误对象给reject()函数，要么传递文件内容给resoleve()函数。<br>要记住执行器会在readFile()被调用时立即运行。当resolve()或reject()在执行器内部被调用时，一个作业被添加到作业队列中，以便决议（resolve）这个Promeise。这被称为作业调度（job scheduling）。作业调度中，添加新作业到队列中时表示：“不要立刻执行这个作业，但要在稍后执行它”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过以下代码理解promise的执行顺序</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hhh'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'lll'</span>)</span><br><span class="line">        <span class="comment">// fs.readFile(fileName, &#123;encoding: 'utf8'&#125;, function(err, contents) &#123;</span></span><br><span class="line">        <span class="comment">//     console.log('%%%%%%%%%%%%%%%%%')</span></span><br><span class="line">        <span class="comment">//     if(err) &#123;</span></span><br><span class="line">        <span class="comment">//         reject(err)</span></span><br><span class="line">        <span class="comment">//         return</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     resolve(contents)</span></span><br><span class="line">        <span class="comment">// &#125;)</span></span><br><span class="line">        resolve(<span class="number">123</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">456</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'mimashiduoshao'</span>)</span><br><span class="line"><span class="comment">// 同时监听完成与拒绝</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 完成</span></span><br><span class="line"><span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 拒绝</span></span><br><span class="line"><span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'woshimima'</span>)</span><br></pre></td></tr></table></figure>
<p>输出为：<br>hhh<br>lll<br>456<br>mimashiduoshao<br>woshimima<br>123</p>
<h3 id="创建已决的Promise"><a href="#创建已决的Promise" class="headerlink" title="创建已决的Promise"></a>创建已决的Promise</h3><p>基于Promise执行器行为的动态本质，Promise构造器就是创建未决的Promise的最好方法。但若想让一个Promise代表一个一直的值，那额安排一个淡出传值给resolve()函数的作业并没有意义。相反，有两种方法可以使用指定值来创建已决的Promise</p>
<h4 id="使用Promise-resolve"><a href="#使用Promise-resolve" class="headerlink" title="使用Promise.resolve()"></a>使用Promise.resolve()</h4><p>Promise.resolve()方法接受单个参数并会返回一个处于完成态的Promise。这意味着没有任何作业调度会发生，并且需要向PRomise添加一个或更多的完成处理函数来提取这个参数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此代码创建了一个已完成的Promise，因此完成处理函数就接收到42作为value参数。若一个拒绝处理函数被添加到此Promise，该拒绝处理函数将永不会被调用，因为此Promise绝不可能时拒绝态</p>
<h4 id="使用Promise-reject"><a href="#使用Promise-reject" class="headerlink" title="使用Promise.reject()"></a>使用Promise.reject()</h4><p>可以使用Promise.reject()方法来创建一个已拒绝的Promise。此方法向Promise.resolve()一样工作，区别是被创建的Promise处于拒绝态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="number">420</span>)</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>任何附加到这个Promise的拒绝处理函数都将会被调用，而完成处理函数则不会执行。</p>
<p>若你传递一个 Promise 给 Promise.resolve() 或 Promise.reject() 方法，该 Promise<br>会不作修改原样返回。<br>译注： 经过测试，在几大浏览器中都存在与上一句话不符的情况。</p>
<ol>
<li>若传入的 Promise 为挂起态，则 Promise.resolve() 调用会将该 Promise 原样返<br>回。此后，若决议原 Promise ，在 then() 中可以接收到原例中的参数 42 ；而若<br>拒绝原 Promise ，则在 catch() 中可以接收到参数 42 。 但 Promise.reject()<br>调用则会对原先的 Promise 重新进行包装，对其使用 catch() 可以捕捉到错误，<br>处理函数中的 value 参数不会是数值 42 ，而是原先处于挂起态的 Promise 。</li>
<li>若传入的 Promise 为完成态，则 Promise.resolve() 调用会将该 Promise 原样返<br>回，在 then() 中可以接收到原例中的参数 42 。 但 Promise.reject() 调用则会<br>对原先的 Promise 重新进行包装，对其使用 catch() 可以捕捉到错误，处理函数<br>中的 value 参数不会是数值 42 ，而是原先处于完成态的 Promise 。</li>
<li>若传入的 Promise 为拒绝态，则 Promise.reject() 调用会将该 Promise 原样返<br>回，在 catch() 中可以接收到参数 42 。 但 Promise.resolve() 调用则会对原先<br>的 Promise 重新进行包装，对其使用 then() 可以进行完成处理，处理函数中的<br>value 参数不是 42 ，而是原先处于拒绝态的 Promise 。也就是说此时的情况与<br>上一种情况相反。<br>总结：对挂起态或完成态的 Promise 使用 Promise.resolve() 没问题，会返回原<br>Promise ；对拒绝态的 Promise 使用 Promise.reject() 也没问题。而除此之外的情况全<br>都会在原 Promise 上包装出一个新的 Promise 。</li>
</ol>
<p>非Promise的Thenable<br>Promise.resolve()与Promise.reject()都能接受非Promise的thenable作为参数。当传入了非Promise的thenable时，这些方法会创建一个新的Promise，此Promise会在then函数之后被调用。<br>当一个对象拥有一个能接受resolve与reject参数的then()方法，该对象就会被认为是一个非Promise的thenable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">42</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="执行器错误"><a href="#执行器错误" class="headerlink" title="执行器错误"></a>执行器错误</h4><p>如果在执行器内部抛出了错误，那么Promise的拒绝处理函数就会被调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'explosion!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message)       <span class="comment">//'explosion'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        reject(ex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message); <span class="comment">// "Explosion!"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>执行器处理程序捕捉了抛出的任何错误，以简化这种常见处理。但在执行器内抛出的错误仅<br>当存在拒绝处理函数时才会被报告，否则这个错误就会被隐瞒。这在开发者早期使用<br>Promise 的时候是一个问题，但 JS 环境通过提供钩子（ hook ）来捕捉被拒绝的 Promise ，<br>从而解决了此问题。</p>
<h3 id="全局的Promise拒绝处理"><a href="#全局的Promise拒绝处理" class="headerlink" title="全局的Promise拒绝处理"></a>全局的Promise拒绝处理</h3><p>Promise最有争议的方面之一就是：当一个Promise被拒绝时若缺少拒绝处理函数，就会静默失败。有人认为这是规范中最大的缺陷，因为这是JS语言左右组成部分中唯一不让错误清晰可见的。<br>由于Promise的本质，判断一个Promise的拒绝是否已被处理并不直观。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reject = <span class="built_in">Promise</span>.reject(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此刻rejected不会被处理</span></span><br><span class="line"><span class="comment">// 一段时间后</span></span><br><span class="line">reject.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>无论Promise是否已被解决，都可以在任何时候调用then()或catch()并使它们正确工作，这导致很难准确知道一个Promise合适会被处理。此例中的Promise被立刻拒绝，但它后来才被处理。<br>虽然下个版本的 ES 可能会处理此问题，不过浏览器与 Node.js 已经实施了变更来解决开发者<br>的这个痛点。这些变更不是 ES6 规范的一部分，但却是使用 Promise 时的宝贵工具。</p>
<h3 id="Node-js的拒绝处理"><a href="#Node-js的拒绝处理" class="headerlink" title="Node.js的拒绝处理"></a>Node.js的拒绝处理</h3><p>在Node.js中，process对象上存在两个关联到Promise的拒绝处理事件：<br>unhandledRejection：当一个Promise被拒绝，而在事件循环的一个轮次中没有任何拒绝处理函数被调用，改时间就会被触发；<br>rejectionHandled：若一个Promise被拒绝、并在时间循环的一个轮次之后再有拒绝处理函数被调用，该事件就会被触发。<br>这两个事件旨在共同帮助识别已被拒绝但未曾处理promise。<br>unhandledRejection 事件处理函数接受的参数是拒绝原因（常常是一个错误对象）以及已被<br>拒绝的 Promise 。以下代码展示了 unhandledRejection 的应用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line">process.on(<span class="string">"unhandledRejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason.message); <span class="comment">// "Explosion!"</span></span><br><span class="line">    <span class="built_in">console</span>.log(rejected === promise); <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>))</span><br></pre></td></tr></table></figure>

<p>此例创建了一个带有错误对象的已被拒绝的 Promise ，并监听了 unhandledRejection 事件。事件处理函数接收了该错误对象作为第一个参数，原 Promise 则是第二个参数。rejectionHandled 事件处理函数则只有一个参数，即已被拒绝的 Promise 。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line">process.on(<span class="string">"rejectionHandled"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rejected === promise) <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>))</span><br><span class="line"><span class="comment">// 延迟添加拒绝处理函数</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value.message); <span class="comment">// "Explosion!"</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>此处的 rejectionHandled 事件在拒绝处理函数最终被调用时触发。若在 rejected 被创建后直接将拒绝处理函数附加到它上面，那么此事件就不会被触发。因为立即附加的拒绝处理函数在 rejected 被创建的事件循环的同一个轮次内就会被调用，这样 rejectionHandled 就不会起作用。为了正确追踪潜在的未被处理的拒绝，使用 rejectionHandled 与 unhandledRejection 事件就能保持包含这些 Promise 的一个列表，之后等待一段时间再检查此列表。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="comment">// 当一个拒绝未被处理，将其添加到 map</span></span><br><span class="line">process.on(<span class="string">"unhandledRejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.set(promise, reason)</span><br><span class="line">&#125;)</span><br><span class="line">process.on(<span class="string">"rejectionHandled"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.delete(promise)</span><br><span class="line">&#125;)</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reason.message ? reason.message : reason)</span><br><span class="line">        <span class="comment">// 做点事来处理这些拒绝</span></span><br><span class="line">        handleRejection(promise, reason)</span><br><span class="line">    &#125;)</span><br><span class="line">    possiblyUnhandledRejections.clear()</span><br><span class="line">&#125;, <span class="number">60000</span>)</span><br></pre></td></tr></table></figure>
<p>对于未处理的拒绝，这只是个简单追踪器。它使用了一个 Map 来储存 Promise 及其拒绝原因，每个 Promise 都是键，而它的拒绝原因就是相关的值。每当 unhandledRejection 被触发， Promise 及其拒绝原因就会被添加到此 Map 中。而每当 rejectionHandled 被触发，已被处理的 Promise 就会从这个 Map 中被移除。这样一来， possiblyUnhandledRejections 就会随着事件的调用而扩展或收缩。 setInterval() 的调用会定期检查这个列表，查看可能未被处理的拒绝，并将其信息输出到控制台（在现实情况下，你可能会想做点别的事情，以便记录或处理该拒绝）。此例使用了一个 Map 而不是 Weak Map ，这是因为你需要定期检查此Map 来查看哪些 Promise 存在，而这是使用 Weak Map 所无法做到的。尽管此例仅针对 Node.js ，但浏览器也实现了类似的机制来将未处理的拒绝通知给开发者。</p>
<h3 id="浏览器的拒绝处理"><a href="#浏览器的拒绝处理" class="headerlink" title="浏览器的拒绝处理"></a>浏览器的拒绝处理</h3><p>浏览器同样能触发两个事件，来帮助识别未处理的拒绝。这两个事件会被 window 对象触发，并完全等效于 Node.js 的相关事件：<br>unhandledrejection ：当一个 Promise 被拒绝、而在事件循环的一个轮次中没有任何拒绝处理函数被调用，该事件就会被触发；<br>rejectionHandled ：若一个 Promise 被拒绝、并在事件循环的一个轮次之后再有拒绝处理函数被调用，该事件就会被触发。<br>Node.js 的实现会传递分离的参数给事件处理函数，而浏览器事件的处理函数则只会接收到包含下列属性的一个对象：<br>type ： 事件的名称（ “unhandledrejection” 或 “rejectionhandled” ）；<br>promise ：被拒绝的 Promise 对象；<br>reason ： Promise 中的拒绝值（拒绝原因）。<br>浏览器的实现中存在的另一个差异就是：拒绝值（ reason ）在两种事件中都可用。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.type) <span class="comment">// "unhandledrejection"</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.reason.message) <span class="comment">// "Explosion!"</span></span><br><span class="line">    <span class="built_in">console</span>.log(rejected === event.promise) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.type) <span class="comment">// "rejectionhandled"</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.reason.message) <span class="comment">// "Explosion!"</span></span><br><span class="line">    <span class="built_in">console</span>.log(rejected === event.promise) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rejected = Promise.reject(new Error(“Explosion!”));<br>此代码使用了 DOM 0 级写法的 onunhandledrejection 与 onrejectionhandled ，对两个事件处理函数都进行了赋值（若你喜欢，也可以使用 addEventListener(“unhandledrejection”) 与addEventListener(“rejectionhandled”) ）。每个事件处理函数都接收一个事件对象，其中包含与被拒绝的 Promise 有关的信息， type 、 promise 与 reason 属性都可用。以下代码在浏览器中追踪未被处理的拒绝，与 Node.js 的代码非常相似：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="comment">// 当一个拒绝未被处理，将其添加到 map</span></span><br><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.set(event.promise, event.reason);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.delete(event.promise)</span><br><span class="line">&#125;</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reason.message ? reason.message : reason)</span><br><span class="line">        <span class="comment">// 做点事来处理这些拒绝</span></span><br><span class="line">        handleRejection(promise, reason)</span><br><span class="line">    &#125;)</span><br><span class="line">    possiblyUnhandledRejections.clear()</span><br><span class="line">&#125;, <span class="number">60000</span>)</span><br></pre></td></tr></table></figure>
<p>这个实现与 Node.js 的实现几乎一模一样。使用了相同方法在 Map 中存储 Promise 及其拒绝值，并在此后进行检查。唯一真正的区别就是在事件处理函数中信息是从何处被提取出来<br>的。<br>处理 Promise 的拒绝可能很麻烦，但你才刚开始见识 Promise 实际上到底有多强大。现在是时候更进一步了——把几个 promises 串联在一起使用。</p>
<h3 id="串联Promise"><a href="#串联Promise" class="headerlink" title="串联Promise"></a>串联Promise</h3><p>到此为止， Promise 貌似不过是个对组合使用回调函数与 setTimeout() 函数的增量改进，<br>然而 Promise 的内容远比表面上所看到的更多。更确切地说，存在多种方式来将 Promise 串<br>联在一起，以完成更复杂的异步行为。<br><strong>每次对 then() 或 catch() 的调用实际上创建并返回了另一个 Promise ，仅当前一个Promise 被完成或拒绝时，后一个 Promise 才会被决议。研究以下例子：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finished'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此代码输出：<br>42<br>finished<br>对 p1.then() 的调用返回了第二个 Promise ，又在这之上调用了 then() 。仅当第一个Promise 已被决议后，第二个 then() 的完成处理函数才会被调用。假若你在此例中不使用<br>串联，它看起来就会是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Finished"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在这个无串联版本的代码中， p1.then() 的结果被存储在 p2 中，并且随后 p2.then() 被调用，以添加最终的完成处理函数。正如你可能已经猜到的，对于 p2.then() 的调用也返回了一个 Promise ，本例只是未使用此 Promise 。</p>
<h4 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h4><p>Promise链允许捕获前一个Promise的完成或拒绝处理函数中发生的错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'boom'</span> + value)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message)  <span class="comment">//boom42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此代码中，p1的完成处理函数抛出了一个错误，链式调用指向了第二个Promise上的catch()方法，能通过此拒绝处理函数接受前面的错误。若是一个拒绝处理函数抛出了错误，情况也一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> newError(<span class="string">'Explosion'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message)  <span class="comment">//Explosion</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'boom'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    console.log(error.message</span>)   //<span class="title">boom</span></span></span><br><span class="line"><span class="function">))</span></span><br></pre></td></tr></table></figure>
<p>此处的执行器抛出了一个错误，就触发了 p1 这个 Promise 的拒绝处理函数，该处理函数随后抛出了另一个错误，并被第二个 Promise 的拒绝处理函数所捕获。链式 Promise 调用能察觉到链中其他 Promise 中的错误。<br>为了确保能正确处理任意可能发生的错误，应当始终在 Promise 链尾部添加拒绝处理函数。</p>
<h4 id="在Promise链中返回值"><a href="#在Promise链中返回值" class="headerlink" title="在Promise链中返回值"></a>在Promise链中返回值</h4><p>Promise链的另一种药方面是能从一个Promise传递数据给下一个Promise的能力。传递给执行器中的resolve()处理函数的参数，会被传递给对应Promise的完成处理函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)      <span class="comment">//42</span></span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)      <span class="comment">//43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>p1 的完成处理函数在被执行时返回了 value + 1 。由于 value 的值为 42 （来自执行器），此完成处理函数就返回了 43 。这个值随后被传递给第二个 Promise 的完成处理函数，并被其输出到控制台。<br>可以对拒绝处理函数做相同的事。当一个拒绝处理函数被调用时，它也能返回一个值。如果这么做，该值会被用于完成下一个 Promise：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// "42"</span></span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第二个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// "43"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此处的执行器使用 42 调用了 reject() ，该值被传递到这个 Promise 的拒绝处理函数中，从中又返回了 value + 1 。尽管后一个返回值是来自拒绝处理函数，它仍然被用于链中下一个Promise 的完成处理函数。若有必要，一个 Promise 的失败可以通过传递返回值来恢复整个Promise 链。</p>
<h3 id="在Promise链中返回Promise"><a href="#在Promise链中返回Promise" class="headerlink" title="在Promise链中返回Promise"></a>在Promise链中返回Promise</h3><p>从完成或拒绝处理函数中返回一个基本类型值，能够在Promise之间传递数据，但若返回的是一个对象呢？若该对象是一个Promise，那么需要采取一个额外步骤来决定如何处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Promsise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)   <span class="comment">//42</span></span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第二个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)   <span class="comment">//43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此代码中， p1 安排了一个决议 42 的作业， p1 的完成处理函数返回了一个已处于决议态的 Promise ： p2 。由于 p2 已被完成，第二个完成处理函数就被调用了。而若 p2 被拒绝，会调用拒绝处理函数（如果存在的话），而不调用第二个完成处理函数。<br>关于此模式需认识的首要重点是第二个完成处理函数并未被添加到 p2 上，而是被添加到第三个 Promise 。正因为此，上个例子就等价于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)   <span class="comment">//42</span></span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">&#125;)</span><br><span class="line">p3.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第二个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)   <span class="comment">//43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此处清楚说明了第二个完成处理函数被附加给 p3 而不是 p2 。这是一个细微但重要的区<br>别，因为若 p2 被拒绝，则第二个完成处理函数就不会被调用。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 第一个完成处理函数</span></span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 第二个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 永不被调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此例中，由于 p2 被拒绝了，第二个完成处理函数就永不被调用。不过你可以改为对其附加一个拒绝处理函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="number">43</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 拒绝处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此处 p2 被拒绝，导致拒绝处理函数被调用，来自 p2 的拒绝值 43 会被传递给拒绝处理函数。从完成或拒绝处理函数中返回 thenable ，不会对 Promise 执行器何时被执行有所改变。第一个被定义的 Promise 将会首先运行它的执行器，接下来才轮到第二个 Promise 的执行器执行，以此类推。返回 thenable 只是让你能在 Promise 结果之外定义附加响应。你能通过在完成处理函数中创建一个新的 Promise ，来推迟完成处理函数的执行。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// 42</span></span><br><span class="line">    <span class="comment">// 创建一个新的 promise</span></span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">43</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此例中，一个新的 Promise 在 p1 的完成处理函数中被创建。这意味着直到 p2 被完成之后，第二个完成处理函数才会执行。若你想等待前面的 Promise 被解决，之后才去触发另一个 Promise ，那么这种模式就非常有用。</p>
<h3 id="响应多个Promise"><a href="#响应多个Promise" class="headerlink" title="响应多个Promise"></a>响应多个Promise</h3><p>至今的每个例子在同一时刻都只响应一个 Promise 。然而有时会想监视多个 Promise的进程，以便决定下一步行动。 ES6 提供了能监视多个 Promise 的两个方法：Promise.all() 与 Promise.race()。</p>
<h4 id="Promise-all-方法"><a href="#Promise-all-方法" class="headerlink" title="Promise.all()方法"></a>Promise.all()方法</h4><p>Promise.all()方法接收单个可迭代对象（如数组）作为参数，并返回一个Promise。这个可迭代对象的元素都是Promise，只有在它们都完成后，所返回的Promise才会被完成。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">44</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value))  <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此处前面的每个Promise都用一个数值进行了决议，对Promise.all()的调用创建了新的Promise p4，在p1，p2和p3都被完成后，p4最终也会被完成。传递给p4的完成处理函数的结果是一个包含每个决议值（42，42，43）的数组，这些值得存储顺序保持了待决议的Promise的顺序（**与完成的先后顺序无关），因此可以将结果匹配到每个Promise。<br>若传递给Promise.all()的任意Promise被拒绝了，那么方法所返回的Promise就会立即被拒绝，而不必等待其他的Promise结束：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">44</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line">p4.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value))   <span class="comment">//false</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)                  <span class="comment">//43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此例中，p2被使用数值43进行了拒绝，则p4的拒绝处理函数就立刻被调用，而不会等待p1或p3结束执行（它们任然会各自结束执行，只是p4不等它们）。<br>拒绝处理函数总会接收到单个值，而不是一个数组，该值就是被拒绝的Promise所返回的拒绝值。本例中的决绝处理函数被传入了43，反映了来自p2的拒绝。</p>
<h4 id="Promise-race-方法"><a href="#Promise-race-方法" class="headerlink" title="Promise.race()方法"></a>Promise.race()方法</h4><p>Promise.race()提供了监视多个Promise的一个稍微不同的方法。此方法也接受一个包含需要监视的Promise的可迭代对象，并返回一个新的Promise，但一旦来源Promise中有一个被解决，所返回的Promise就会立刻被解决。等待所有Promise完成的Promise.all()方法不同，来自源Promise中任意一个被完成时，Promise.race()方法所返回的Promise就能作出响应。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">44</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1, p2, p3])</span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log()     <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此代码中， p1 被创建为一个已完成的 Promise ，而其他的 Promise 则需要调度作业。p4 的完成处理函数被使用数值 42 进行了调用，并忽略了其他的 Promise 。传递给Promise.race() 的 Promise 确实在进行赛跑，看哪一个首先被解决。若胜出的 Promise 是被完成，则返回的新 Promise 也会被完成；而胜出的 Promise 若是被拒绝，则新 Promise 也会被拒绝。此处有个使用拒绝的范例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="number">43</span>)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">44</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1, p2, p3])</span><br><span class="line">p4.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此处的 p4 被拒绝了，因为 p2 在 Promise.race() 被调用时已经处于拒绝态。尽管 p1 与p3 都被完成，其结果仍然被忽略，因为这发生在 p2 被拒绝之后。</p>
<h3 id="继承Promise"><a href="#继承Promise" class="headerlink" title="继承Promise"></a>继承Promise</h3><p>正像其他内置类型，可将一个Promise用作派生类的基类。这允许你自定义变异的Promise，在内置Promise的基础上扩展功能，例如假设想创建一个可以使用succss()和failure()方法的Promise，对常规的then()和catch()方法进行扩展，可以像下面这样创建该Promise类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    success(resolve, reject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    failure(reject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.catch(reject)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.success(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;).failure(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此例中， MyPromise 从 Promise 上派生出来，并拥有两个附加方法。 success() 方法模拟了 resolve() ， failure() 方法则模拟了 reject() 。<br>每个附加方法都使用了 this 来调用它所模拟的方法。派生的 Promise 函数与内置的Promise 几乎一样，除了可以随你需要调用 success() 与 failure() 。<br>由于静态方法被继承了， MyPromise.resolve() 方法、 MyPromise.reject() 方法、MyPromise.race() 方法与 MyPromise.all() 方法在派生的 Promise 上都可用。后两个方法的行为等同于内置的方法，但前两个方法则有轻微的不同。<br>MyPromise.resolve() 与 MyPromise.reject() 都会返回 MyPromise 的一个实例，无视传递进来的值的类型，这是由于这两个方法使用了 Symbol.species 属性（详见第九章）来决定需要返回的 Promise 的类型。若传递内置 Promise 给这两个方法，将会被决议或被拒绝，并且会返回一个新的 MyPromise ，以便绑定完成或拒绝处理函数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = MyPromise.resolve(p1)</span><br><span class="line">p2.MyPromise.resolve(p1)</span><br><span class="line">p2.success(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)  <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> MyPromise)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>此处的p1是一个内置的Promise，被传递给了MyPromise.resolve()方法。作为结果的p2是MyPromise的一个实例，来自p1的决议值被传递给了p2的完成处理函数。<br>若MyPromise的一个实例被传递给了MyPromise.resolve()或MyPromise.reject()方法，它会在未被决议的情况下就被直接返回。其他情况下，这两个方法的行为都会等同于Promise.resolve()与Promise.reject()</p>
<h3 id="异步任务运行"><a href="#异步任务运行" class="headerlink" title="异步任务运行"></a>异步任务运行</h3><p>可以像如下方案进行异步任务运行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建迭代器，让它在别处可用</span></span><br><span class="line">    <span class="keyword">let</span> task = taskDef()</span><br><span class="line">    <span class="comment">// 开始任务</span></span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line">    <span class="comment">// 递归使用函数来保持对next()的调用</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.done) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> result.value === <span class="string">'function'</span>) &#123;</span><br><span class="line">                result.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        result = task.throw(err)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    result = task.next(data)</span><br><span class="line">                    step()</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = task.next(result.value)</span><br><span class="line">                step()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始处理过程</span></span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个函数来配合任务运行器使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(filename, callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">'config.json'</span>)</span><br><span class="line">    doSomethingWith(contents)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此实现存在一些痛点。首先，将每个函数包裹在另一个函数内，再返回一个新函数，这是有点令人困惑的。其次，返回值为函数的情况下，没有任何方法可以区分它是否应当被作为任务运行器的回调函数。<br>借助Promise，可以确保每个异步操作都返回一个Promise，从而大幅度简化并一般化异步处理，通过接口也意味着可以大大减少异步代码。此处有一个简化异步任务运行器的方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建迭代器</span></span><br><span class="line">    <span class="keyword">let</span> task = taskDef()</span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line">    <span class="comment">// 递归使用函数来进行迭代</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">            <span class="comment">// 决议一个Promise，让任务处理变简单</span></span><br><span class="line">            <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(result.value)</span><br><span class="line">            promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                result = task.next(value)</span><br><span class="line">                step()</span><br><span class="line">            &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">                result = task.throw(error)</span><br><span class="line">                step()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数来配合任务运行器使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fs.readFile(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(contents)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行一个任务</span></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">'config.json'</span>)</span><br><span class="line">    doSomethingWith(contents)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此版本的代码中，一个通用的 run() 函数执行了生成器来创建一个迭代器。它调用了task.next() 来启动任务，并递归调用 step() 直到迭代完成。<br>在 step() 函数内部，如果还有更多工作要做，那么 result.done 的值会是 false ，此时result.value 应当是一个 Promise ，不过调用 Promise.resolve() 只为预防未正确返回Promise 的函数（记住： Promise.resolve() 在被传入任意 Promise 时只会直接将其传递回来，而不是 Promise 的参数则会被包装为 Promise ）。接下来，一个完成处理函数被添加以便提取该 Promise 值，并将该值传回迭代器。此后，在 step() 函数调用自身之前，result 被赋值为下一个 yield 的结果。<br>一个拒绝处理函数将任意拒绝结果存储在一个错误对象中。 task.throw() 方法将这个错误对象传回给迭代器，而若一个错误在任务中被捕获， result 也会被赋值为下一个 yield 的结果，这样 step() 最终在 catch() 内部就会被调用，以便继续任务执行。run() 函数能运行任意使用 yield 来实现异步代码的生成器，而不会将 Promise （或回调函数）暴露给开发者。事实上，由于函数调用后的返回值总是会被转换为一个 Promise ，该函数甚至允许返回 Promise 之外的类型。这意味着同步与异步方法在使用 yield 时都会正常工作，并且你永不需要检查返回值是否为一个 Promise 。唯一需要担心的是，要确保诸如 readFile() 的异步方法能返回一个正确标记其状态的Promise 。对于 Node.js 内置的方法来说，这意味着你必须转换这些方法，让它们返回Promise 而不是使用回调函数。<br>未来的异步任务运行<br>在我写这本书的时候，针对 JS 中的异步任务运行，为之引入简单语法的一项工作正在进行。此工作开展在 await 语法上，极度借鉴了上述以 Promise 为基础的例子。其基本理念是使用一个被 async 标记的函数（而非生成器），并在调用另一个函数时使用await 而非 yield ，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> contents = <span class="keyword">await</span> readFile(<span class="string">"config.json"</span>);</span><br><span class="line">doSomethingWith(contents)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在 function 之前的 async 关键字标明了此函数使用异步方式运行。 await 关键字则表示对于 readFile(“config.json”) 的函数调用应返回一个 Promise ，若返回类型不对，则会将其包装为 Promise 。与上述 run() 的实现一致， await 会在 Promise 被拒绝的情况下抛出错误，否则它将返回该 Promise 被决议的值。最终结果是你可以将异步代码当作同步代码来书写，而无须为管理基于迭代器的状态机而付出额外开销。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/Promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" data-id="ck9ghxoo300087kr91c99es9b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS的类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/JS%E7%9A%84%E7%B1%BB/" class="article-date">
  <time datetime="2020-04-26T02:04:36.723Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/JS%E7%9A%84%E7%B1%BB/">JS的类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>与大多数正规的面向对象编程语言不同，JS从创建之初就不支持类，也没有把类继承作为定义相似对象以及关联对象的主要方式。而从ES1诞生之前知道ES5时期，很多库都创建了一些工具，让JS显得貌似能支持类。</p>
<h3 id="ES5中仿类结构"><a href="#ES5中仿类结构" class="headerlink" title="ES5中仿类结构"></a>ES5中仿类结构</h3><p>JS在ES5以及更早版本中都不存在类。与类最接近的是：创建一个构造器，然后将方法指派到该构造起的原型上。这种方式通常被称为创建一个自定义类型。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonType(<span class="string">'Nicholas'</span>)</span><br><span class="line">person.sayName()  <span class="comment">//Nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonType)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)      <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>此代码中的 PersonType 是一个构造器函数，并创建了单个属性 name 。 sayName() 方法被指派到原型上，因此在 PersonType 对象的所有实例上都共享了此方法。接下来，使用 new运算符创建了 PersonType 的一个新实例 person ，此对象会被认为是一个通过原型继承了PersonType 与 Object 的实例。</p>
<h3 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h3><p>类在ES6中最简单的形式就是类声明，看起来向其他语言中的类</p>
<h4 id="基本的类声明"><a href="#基本的类声明" class="headerlink" title="基本的类声明"></a>基本的类声明</h4><p>类声明以class关键字开始，其后是类的名称；其余部分的语法看起来就像对象字面量中的方法简写，并且在方法之间不需要使用逗号。下为简单类声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonCladd</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于PersonType构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'Nicholas'</span>)</span><br><span class="line">person.sayName()   <span class="comment">//输出Nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass)     <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName)  <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<p>这个PersonClass类声明的行为非常类似上个例子中的PersonType。类声明允许在其中使用特殊的constructor方法名称直接定义一个构造器，而不需要先定义一个函数再把它当做构造器使用。由于累的方法使用类间歇语法，于是就不再需要使用function关键字。constructor之外的方法名称则没有特别的含义。<br>自有属性（Own properties）：该属性出现在实力上而不是原型上，只能在类的构造器或方法内部进行创建。在本例中，name就是一个自有属性。建议应在构造器函数内创建所有可能出现的自有属性，这样在类中声明变量就会被限制在单一位置（有助于代码检查）<br>相对于已有的<strong>自定义类型声明方式</strong>来说，<strong>类声明</strong>仅仅是以它为基础的一个语法糖。PersonClass声明实际上创建了一个拥有constructor方法以及其行为的函数，这也是typeof PersonClass会得到“function”结果的原因。此例中的sayName()方法最终也成为PersonClass.prorotype上的一个方法，类似于上个例子中的sayName()与PersonType。prototype之间的关系。这些相似处允许把自定义类型与类混合使用，而不必考虑该使用哪一个。</p>
<h4 id="为何要使用类的语法"><a href="#为何要使用类的语法" class="headerlink" title="为何要使用类的语法"></a>为何要使用类的语法</h4><p>尽管类与自定义类型之间有相似性，但仍然要记住一些重要的区别：<br>1.类声明不会被提升，这与函数定义不同。类声明的行为与let相似，因此在程序执行到达声明处之前，类会存在于暂时性死区内。<br>2.类声明中的所有代码会自动运行在严格模式下，并且也无法退出严格模式。<br>3.类的所有方法都是不可枚举的，这是对于自定义类型的显著变化，后者必须用Object.defineProperty()才能将方法改变为不可枚举。<br>4.类的所有方法内部都没有[[Construct]]，因此使用new来调用它们会抛出错误。<br>5.调用类构造器时不使用new，会抛出错误。<br>6.试图在类的方法内部重写类名，会抛出错误。<br>这样看来，上例中的PersonClass声明实际上就直接等价于一下未使用类语法的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接等价于PersonClass</span></span><br><span class="line"><span class="keyword">let</span> PersonType2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line">    <span class="keyword">const</span> PersonType = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 确认函数被调用时使用了new</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'constructor must be called with new'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(PersonType2.prototype, <span class="string">'sayName'</span>, &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 确认函数被调用时没有使用new</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'method cannot be called with new'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="keyword">return</span> PersonType2</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<p>首先要注意这里有两个PersonType2声明：一个在外部作用的let声明，一个在IIFE内部的const声明。这就是为何类的方法不能对类名进行重写、而类外部的代码则被允许。构造器函数检查了new.target，以保证被调用时使用了new，否则就抛出错误。接下来，sayName()方法被定义为不可枚举，并且此方法也检查了new.target，它则要保证在被调用时没有使用new。最后一步是将构造器函数返回出去。<br>此例说明了尽管不使用新语法也能实现类的任何特性，但类语法显著简化了所有功能的代码。<br>不变的类名<br>只有在类的内部，类名才被视为是使用const声明的。这意味着你可以在外部重写类名但不能再累的方法内部这么做。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        Foo = <span class="string">'bar'</span> <span class="comment">//执行时抛出错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但在类声明之后没问题</span></span><br><span class="line">Foo = <span class="string">'baz'</span></span><br></pre></td></tr></table></figure>

<p>在此代码中，类构造器内部的 Foo 与在类外部的 Foo 是不同的绑定。内部的 Foo 就像是用 const 定义的，不能被重写，当构造器尝试使用任何值重写 Foo 时，都会抛出错误。但由于外部的 Foo 就像是用 let 声明的，你可以随时重写类名。</p>
<h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p>类与函数有相似之处，即它们都有两种形式：声明与表达式。函数声明与类声明都以适当的关键词为起始分别是（function与class），随后是标识符（即函数名或类名）。函数具有一种表达式形式，无需在function后面使用表示；类似的，类也有不需要表示符的表达式形式。类表达式被设计用于变量声明，或可作为参数传递给函数。<br>基本的类表达式<br>此处是与上例中的PersonCladd等效的类表达式，随后的代码使用了它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于PersonType构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'nicholas'</span>)</span><br><span class="line">person.sayName()  <span class="comment">//输出nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass)   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)        <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass)              <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName) <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<p>正如磁力所示，类表达式不需要再class关键字后使用标识符。除了语法差异，类表达式的功能等价于类声明。<br>使用类声明还是类表达式，主要是代码风格的问题。相对于函数声明与函数表达式之间的区别，类声明与类表达式都不会被提升，因此对代码运行时的行为影响甚微。</p>
<h4 id="具名类表达式"><a href="#具名类表达式" class="headerlink" title="具名类表达式"></a>具名类表达式</h4><p>上一节的示例使用了一个匿名的类表达式，不过就像函数表达式那样，也可以为类表达式明明。为此需要在class关键字后添加标识符，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = calss PersonClass2 &#123;</span><br><span class="line">    <span class="comment">// 等价于PersonType构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass)   <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2)  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>此例中的类表达式被命名为PersonClass2。PersonClass2标识符只在类定义内部存在，因此只能用在类方法内部（例如本例中的sayName()内）。在类的外部，typeof PersonClass2的结果为undefined，这是因为外部不存在PersonClass2绑定。要理解为何如此，请查看未使用类语法的等价声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接等价于PersonClass具名的类表达式</span></span><br><span class="line"><span class="keyword">let</span> PersonClass = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="keyword">const</span> = PersonClass2 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 确认函数被调用时使用了new</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'constructor must be called with new'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    object.defineProperty(PersonClass2.prototype, <span class="string">'sayName'</span>, &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 确认函数被调用时没有使用new</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'method cannot be called with new'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> PersonClass2</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<p>创建具名的类表达式稍微改变了在JS引擎内部发生的事。对于类声明来说，外部绑定（用let定义）与内部绑定（用const定义）有着相同的名称。而类表达式可在内部使用const来定义它的不同名称，因此此处的PersonClass2只能在类的内部使用。<br>尽管具名类表达式的行为已于具名函数表达式，但它们之间仍有许多相似点。二者都能被当做值来使用，这开启了许多可能性。</p>
<h3 id="作为一级公民的类"><a href="#作为一级公民的类" class="headerlink" title="作为一级公民的类"></a>作为一级公民的类</h3><p>在编程中，能被当做值来使用的就称为一级公民（first-class citizen），意味着它能作为参数给函数、能作为函数返回值、能用来给变量赋值。JS的函数就是一级公民（它们有时又被称为一级函数），此特性让JS独一无二。<br>ES6延续了传统，让类同样成为一级公民。这就使得类可以被多种方式所使用。例如，它能作为参数传入函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crateObject</span>(<span class="params">classDef</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> classDef()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = createObject(<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.sayHi()      <span class="comment">//hi</span></span><br></pre></td></tr></table></figure>
<p>此例中的createObject()函数被调用时接收了一个匿名函数表达式作为参数，使用new创建了该类的一个实例，并将其返回出来。随后变量obj储存了所返回的实例。<br>类表达式的另一个又去用途是立即调用类构造器，以创建单例（Singleton）。为此，必须使用new来配合类表达式，并在表达式后面添加括号。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">'nicholas'</span>)</span><br><span class="line">person.sayName()   <span class="comment">//nicholas</span></span><br></pre></td></tr></table></figure>
<p>此处创建了一个匿名类表达式，并立即执行了它。此模式允许你使用类语法来创建单例类，从而不留下任何可被探查的类引用（回忆一下PersonClass的例子，匿名类表达式只在类的内部创建了绑定，而外部无绑定）。<strong>类表达式后面的圆括号表示要调用前面的函数，并且还允许传入参数。</strong></p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>自有属性需要在类构造器中创建，而类还允许在原型上定义访问器属性。为了创建一个getter，需要使用get关键字，并要与后方标识符之间留出空格；创建setter用相同方式，只是要换用set关键字。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> html() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> html(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(CustomHTMLElement.prototype, <span class="string">'html'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'get'</span> <span class="keyword">in</span> descriptor)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'set'</span> <span class="keyword">in</span> descriptor)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor,enumerable) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>此代码中的CustomHTMLElement类用于包装一个已存在的DOM元素，它的属性html拥有getter与setter，委托了元素自身的innerHTML方法。该访问器属性被创建在CUnstmHTMLElement.prototype上，并且像其他类属性那样被创建为不可枚举属性。非类的等价表示如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接等价于上个范例</span></span><br><span class="line"><span class="keyword">let</span> CustomHTMLElement = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="keyword">const</span> CustomHTMLElement = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 确认函数被调用时使用了new</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'constructor must be called with new'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.element = element</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(CustomHTMLElement.prototype, <span class="string">'html'</span>, &#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function(value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> CunstomHTMLElement</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<h3 id="需计算的成员名"><a href="#需计算的成员名" class="headerlink" title="需计算的成员名"></a>需计算的成员名</h3><p>对象字面量与类之间的相似点还不仅前面那些。类方法与访问器属性也都能使用需计算的名称。㞏相同于对象字面量中的需计算名称：无需使用标识符，而是用方括号来包裹一个表达式。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">'sayName'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> </span>= PersonClass &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    [methodName]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> PersonClass(<span class="string">'nicholas'</span>)</span><br><span class="line">me.sayName()                  <span class="comment">//'nicholas'</span></span><br></pre></td></tr></table></figure>
<p>此版本的PersonClass使用了一个变量来命名类定义内的方法。字符串”sayName“被赋值给了methodName变量，而methodName变量则被用于声明方法。sayName()方法在此后能被直接访问。<br>访问器属性能以相同方式使用需计算的名称，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">'html'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> [propertyName]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> [propertyName](value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处html的getter与setter被设置为需使用propertyName变量，使用.html依然能访问此属性，这里影响的只有定义方式。</p>
<h3 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    *createIterator() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Myclass()</span><br><span class="line"><span class="keyword">let</span> iterator = instance.createIterator()</span><br></pre></td></tr></table></figure>
<p>此处代码创建了一个拥有createIterator()生成器的MyClass类。该方法返回了一个迭代器，它的值在生成器内部用硬编码提供。当使用一个对象来表示值的集合、并要求能简单迭代这些值，那么生成器方法就非常有用。数组、Set与Map都拥有多个生成器方法，负责让开发者用多种方式来操作它们的项。<br>既然生成器方法很有用，那么在表示集合的自定义类中定义一个默认迭代器，那就更好。可以使用 Symbol.iterator 来定义生成器方法，从而定义出类的默认迭代器，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = []</span><br><span class="line">    &#125;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> *<span class="keyword">this</span>.items.values()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> Collection()</span><br><span class="line">collection.items.push(<span class="number">1</span>)</span><br><span class="line">collection.items.push(<span class="number">2</span>)</span><br><span class="line">collection.items.push(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此例为生成器方法使用了一个需计算名称，并将此方法委托到this.items数组的values()迭代器上。任意管理集合的类都包含一个默认迭代器，这是因为一些集合专用的操作都要求目标集合具有迭代器。现在，Collection的任意实例都可以在for-of循环内被直接使用，也能配合扩展运算符使用。<br>当你想让方法与访问器属性在对象实例上出现时，把它们添加到类的原型上就会对此目的有帮助。而另一方面，若想让方法与访问器属性只存在于类自身，那么你就需要使用静态成员。</p>
<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>直接在构造器上添加额外方法来模拟静态成员，这在ES5及更早版本中是另一个通用的模式。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">PersonType.create = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PersonType(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = PersonType.create(<span class="string">'nicholas'</span>)</span><br></pre></td></tr></table></figure>
<p>在其他编程语言中，工厂方法PersonType.create()会被认定为一个静态方法，它的数据不依赖PersonType的任何势力。ES6的类简化了静态成员的创建，只要在方法与访问器属性的名称前添加正式的static标注。作为一个例子，此处有个与上例等价的类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于PersonType构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于PersonType.create</span></span><br><span class="line">    <span class="keyword">static</span> create(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonClass(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = PersonClass.create(<span class="string">'nicholas'</span>)</span><br></pre></td></tr></table></figure>
<p>PersonClass 的定义拥有名为 create() 的单个静态方法，此语法与 sayName() 基本相同，只多了一个 static 关键字。你能在类中的任何方法与访问器属性上使用 static 关键字，唯一限制是不能将它用于 constructor 方法的定义。<br><strong>静态成员不能用实例来访问，始终需要直接用类自身来访问它们</strong></p>
<h3 id="使用派生类进行继承"><a href="#使用派生类进行继承" class="headerlink" title="使用派生类进行继承"></a>使用派生类进行继承</h3><p>ES6之前，实现自定义类型的继承是个繁琐的过程。严格的继承要求有多个步骤。例如，研究一下范例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length*<span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">    Rectangle.call(<span class="keyword">this</span>, length, length)</span><br><span class="line">&#125;</span><br><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: Square,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea())    <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Square继承了Rectangle，为此它必须使用Rectangle.prototype所创建的一个新对象来重写Square.prototype，并且还要调用Rectangle.call()方法。<br>类让继承工作变得更轻易，使用熟悉的extends关键字来指定当给钱类所需要的继承的函数即可。生成的类的原型会被自动调整，而你还能调用super()方法来访问基类的构造器。此处是与上个例子等价的ES6代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="comment">// 与Rectangle.call(this, length, length)相同</span></span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square = Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea)       <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square)   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>此次Square类使用了extends关键字继承了Rectangle。Square构造器使用了super()配合指定参数调用了Rectangle构造器。注意与ES5版本的代码不同，Rectangle标识符尽在类定义时被使用了（在extends之后）。<br>继承了其他类的类被称为派生类（derived classes）。如果派生类指定了构造器，就需要使用super(),否则就会造成错误。若不使用构造器，super()方法会被自动调用，并会使用创建新实例时提供的所有参数。例如，下列两个类是完全相同的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有构造器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此例中的第二个类展示了与所有派生类默认构造器等价的写法，所有的参数都按顺序传递给了基类的构造器。在当前需求下，郑重做法并不完全准确，因为Square构造器只需要单个参数，因此最好手动定义构造器。<br>使用 super() 时需牢记以下几点：</p>
<ol>
<li>你只能在派生类中使用 super() 。若尝试在非派生的类（即：没有使用 extends关键字的类）或函数中使用它，就会抛出错误。</li>
<li>在构造器中，你必须在访问 this 之前调用 super() 。由于 super() 负责初始化this ，因此试图先访问 this 自然就会造成错误。</li>
<li>唯一能避免调用 super() 的办法，是从类构造器中返回一个对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name</span><br><span class="line">		<span class="keyword">this</span>.age = age</span><br><span class="line">	&#125;</span><br><span class="line">	sayAge() &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name, age, classNum) &#123;</span><br><span class="line">		<span class="keyword">super</span>(name, age)  <span class="comment">//注释之后报错，没有this</span></span><br><span class="line">		<span class="keyword">this</span>.classNum = classNum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xiaoHong = <span class="keyword">new</span> Student(<span class="string">'xiaohong'</span>, <span class="string">'12'</span>, <span class="string">'class3'</span>)</span><br><span class="line">xiaoHong.sayAge()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="屏蔽类方法"><a href="#屏蔽类方法" class="headerlink" title="屏蔽类方法"></a>屏蔽类方法</h4><p>派生类中的方法总是会屏蔽基类的同名方法。例如，可以将getArea()方法添加到Super类，以便重定义它的功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于getArea()已经被定义为Square的一部分，Rectangle.prototype.getArea()方法就不能再Square的任何实例上被调用。当然，总可以使用super.getArea()方法来调用基类中的同名方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getArea()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承静态成员"><a href="#继承静态成员" class="headerlink" title="继承静态成员"></a>继承静态成员</h4><p>如果基类包含静态成员，那么这些静态成员在派生类中也是可用的。继承的工作方式类似于其他语言。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> create(length, width) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rectangle(length, width)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="comment">// 与Rectangle.call(this, length, length)相同</span></span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rect = Square.create(<span class="number">3</span>, <span class="number">4</span>)   </span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(rect.getArea())             <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Square)     <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>在此代码中，一个新的静态方法 create() 被添加到 Rectangle 类中。通过继承，该方法会以 Square.create() 的形式存在，并且其行为方式与 Rectangle.create() 一样。</p>
<h4 id="从表达式中派生类"><a href="#从表达式中派生类" class="headerlink" title="从表达式中派生类"></a>从表达式中派生类</h4><p>在ES6中派生类的最强大能力，或许就是能够从表达式中派生类。只要一个表达式能够返回一个具有[[Construct]]属性以及原型的函数，就可以对其使用extends。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(x.getArea())             <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Rectangle被定义为ES5风格的构造器，而Square则是一个类。由于Rectangle具有[[Construct]]以及原型，Square类就能直接继承它。<br>extends后面能接受任意类型的表达式，这带来了巨大可能性，例如动态地决定所要继承的类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Rectangle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">getBase</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(x.getArea())   <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>getBase()函数作为类声明的一部分被直接调用，它返回了Rectangle，是的此例的功能等价于前一个例子。并且由于可以动态地决定基类，就能创建不同的继承方式。例如可以有效地创建混入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> SerializableMixin = &#123;</span><br><span class="line">    serialize() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> AreaMixin = &#123;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.assign(base.prototype, ...mixins)</span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">mixin</span>(<span class="title">AreaMixin</span>, <span class="title">SerializableMixin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(x.getArea())</span><br><span class="line"><span class="built_in">console</span>.log(x.serialize())  <span class="comment">//&#123;length: 3, width: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>此例使用了混入（mixin）而不是传统继承。mixin()函数接受代表混入对象的任意数量的参数，它创建了一个名为base的函数，并将每个混入对象的属性都赋值到新函数的原型上。阐述随后返回，于是Square就能够对其使用extends关键字了。注意由于仍然使用了extends，就必须在构造器内调用super().<br>Square的实例既有来自AreaMixin的getArea()方法，又有来自SerilaizableMixin的serialize()方法，这是通过原型继承实现的。mixin()函数使用了混入对象的所有自有属性，动态地填充了新函数的原型（注意：若多个混入对象拥有相同的属性，则只有最后添加的属性会被保留）。<br>任意表达式都能在extends关键字后使用，但并非所有表达式的结果都是一个有效的类。特别的，下列表达式类型会导致错误：<br>null;<br>生成器函数<br>试图使用结果为上述值得表达式来创建一个新的类实例，都会抛出错误，因为不存在[[Construct]]可供调用。</p>
<h4 id="继承内置对象"><a href="#继承内置对象" class="headerlink" title="继承内置对象"></a>继承内置对象</h4><p>几乎从JS数组出现那天开始，开发者就像通过继承机制来创建它们自己的特殊数组类型。在ES5及早期版本中，这是不可能做到的。试图使用传统继承并不能产生功能正确的代码，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置数组的行为</span></span><br><span class="line"><span class="keyword">var</span> colors = []</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])  <span class="comment">//undefined</span></span><br><span class="line"><span class="comment">// 在ES5中尝试继承数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">myArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: MyArray,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray()</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)  <span class="comment">//0</span></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])      <span class="comment">//red</span></span><br></pre></td></tr></table></figure>
<p>console.log()在此代码尾部的输出说明：对数组使用传统形式的JS继承，产生了预期外的行为。MyArray实例上的length属性以数值属性，其行为与内置数组并不一致，因为这些功能并未被涵盖在Array.apply()或数组原型中。<br>在ES6中的类，其设计目的之一就是允许从内置对象上进行继承。为了达成这个目的，类的继承模型与ES5或更早版本的传统继承模型有轻微差异：<br>在ES5的传统继承中，this的值会先被派生类（例如MyArray）创建，随后基类构造器（例如Array.apply()方法）才被调用。这意味着this一开始就是MyArray的实例，之后才使用了Array的附加属性对其进行了装饰。<br>在ES6基于类的继承中，this的值会先被基类（Array）创建，随后才被派生类的构造器（MyArray）所修改。结果是this初始就拥有作为基类的内置对象的所有功能，并能正确接收与之关联的所有功能。<br>一下范例实际展示了基于类的特殊数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray()</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)    <span class="comment">//1</span></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])    <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>MyArray直接继承了Array，因此工作方式与正规数组一致。与数值索引属性额互动更新了length属性，而操纵length属性也能更新索引属性。这意味着既能适当地继承Array来创建自己的派生数组类，也同样能继承其他的内置对象。</p>
<h4 id="Symbol-species属性"><a href="#Symbol-species属性" class="headerlink" title="Symbol.species属性"></a>Symbol.species属性</h4><p>继承内置对象一个有趣的方面是：任意能返回内置对象实例的方法，在派生类的实例。因此，若拥有类一个继承了Array的派生类MyArray，注入slice()之类的方法都会返回MyArray的实例。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">    subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在此代码中，slice()方法返回了MyArray的一个实例。slice()方法是从Array上继承的，原本应当返回Array的一个实例。而Symbol.species属性在后台造成了这种变化。<br>Symbol.species是名符号被用于定义一个能返回函数的静态访问器属性。每当类实例的方法（构造器除外）必须常建一个实例时，前面返回的函数就被用为新实例的构造器。下列内置类型都定义了Symbol.species:<br>Array<br>ArrayBuffer<br>Map<br>Promise<br>RegExp<br>Set<br>类型化数组<br>以上每个类型都拥有默认的Symol.species属性，其返回值为this，意味着该属性总会返回自身的构造器函数。若准备在一个自定义类上实现此功能，代码就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 几个内置类型使用species的方式类似于此</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    clone() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再此例中，Symbol.species知名符号被用于定义MyClass的一个静态访问器属性。注意此处只有getter而没有setter，这是因为修改累的species是不允许的。任何对this.constructor[Symbol.species]的调用都会返回MyClass，clone()方法使用了该定义来返回一个新的实例，而没有直接使用MyClass，这就允许派生类重写这个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    clone() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDerivedClass1</span> <span class="keyword">extends</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"><span class="comment">// 空代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDerivedClass2</span> <span class="keyword">extends</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyClass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> MyDerivedClass1(<span class="string">"foo"</span>),</span><br><span class="line">clone1 = instance1.clone(),</span><br><span class="line">instance2 = <span class="keyword">new</span> MyDerivedClass2(<span class="string">"bar"</span>),</span><br><span class="line">clone2 = instance2.clone();</span><br><span class="line"><span class="built_in">console</span>.log(clone1 <span class="keyword">instanceof</span> MyClass); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(clone1 <span class="keyword">instanceof</span> MyDerivedClass1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(clone2 <span class="keyword">instanceof</span> MyClass); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(clone2 <span class="keyword">instanceof</span> MyDerivedClass2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>此处, MyDerivedClass1 继承了 MyClass ，并且未修改 Symbol.species 属性。由于this.constructor[Symbol.species] 会返回 MyDerivedClass1 ，当 clone() 被调用时，它就返回了 MyDerivedClass1 的一个实例。 MyDerivedClass2 类也继承了 MyClass ，但重写了Symbol.species ，让其返回 MyClass 。当 clone() 在 MyDerivedClass2 的一个实例上被调用时，返回值就变成 MyClass 的一个实例。使用 Symbol.species ，任意派生类在调用应当返回实例的方法时，都可以判断出需要返回什么类型的值。<br>例如， Array 使用了 Symbol.species 来指定方法所使用的类，让其返回值为一个数组。在Array 派生出的类中，你可以决定这些继承的方法应返回何种类型的对象，正如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>此代码重写了从 Array 派生的 MyArray 类上的 Symbol.species 。所有返回数组的继承方法现在都会使用 Array 的实例，而不是 MyArray 的实例。<br>一般而言，每当想在类方法中使用 this.constructor 时，你就应当设置类的Symbol.species 属性。这么做允许派生类轻易地重写方法的返回类型。此外，若你从一个拥有 Symbol.species 定义的类创建了派生类，要保证使用此属性，而不是直接使用构造器。</p>
<h4 id="在类构造器中使用new-target"><a href="#在类构造器中使用new-target" class="headerlink" title="在类构造器中使用new.target"></a>在类构造器中使用new.target</h4><p>在第三章你已学到了 new.target ，以及在调用函数的方式不同时它的值是如何变动的。你也可以在类构造器中使用 new.target ，来判断类是被如何被调用的。在简单情况下，new.target 就等于本类的构造器函数，正如下例；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new.target 就是 Rectangle</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>
<p>此代码说明在 new Rectangle(3, 4) 被调用时， new.target 就等于 Rectangle 。类构造器被调用时不能缺少 new ，因此 new.target 属性就始终会在类构造器内被定义。不过这个值并不总是相同的。研究以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new.target 就是 Square</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>
<p>Square 调用了 Rectangle 构造器，因此当 Rectangle 构造器被调用时， new.target 等于Square 。这很重要，因为构造器能根据如何被调用而有不同行为，并且这给了更改这种行为的能力。例如，你可以使用 new.target 来创建一个抽象基类（一种不能被实例化的类），如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This class cannot be instantiated directly."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape(); <span class="comment">// 抛出错误</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 没有错误</span></span><br><span class="line"><span class="built_in">console</span>.log(y <span class="keyword">instanceof</span> Shape); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>此例中的 Shape 类构造器会在 new.target 为 Shape 的时候抛出错误，意味着 newShape() 永远都会抛出错误。然而，你依然可以将 Shape 用作一个基类，正如 Rectangle所做的那样。 super() 的调用执行了 Shape 构造器，而且 new.target 的值等于Rectangle ，因此该构造器能够无错误地继续执行。<br>由于调用类时不能缺少 new ，于是 new.target 属性在类构造器内部就绝不会是undefined 。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/JS%E7%9A%84%E7%B1%BB/" data-id="ck9ghxoon000l7kr942t457l1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/" rel="tag">前端相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 13.33px;">CSS</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/" style="font-size: 10px;">前端相关</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 16.67px;">计算机网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/26/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/">引用类型之数组</a>
          </li>
        
          <li>
            <a href="/2020/04/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/">面向对象的程序设计</a>
          </li>
        
          <li>
            <a href="/2020/04/26/%E4%BA%8B%E4%BB%B6/">事件</a>
          </li>
        
          <li>
            <a href="/2020/04/26/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/">跨域资源共享</a>
          </li>
        
          <li>
            <a href="/2020/04/26/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/">防抖与节流</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>