<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Blog/css/main.css">


<link rel="stylesheet" href="/Blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gitee.com","root":"/Blog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="蚂蚁的博客">
<meta property="og:url" content="https://gitee.com/iversoncurry/Blog.git/page/2/index.html">
<meta property="og:site_name" content="蚂蚁的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="蚂蚁">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://gitee.com/iversoncurry/Blog.git/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>蚂蚁的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">蚂蚁的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/Blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/JS%E7%9A%84%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/JS%E7%9A%84%E7%B1%BB/" class="post-title-link" itemprop="url">JS的类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 10:04:36 / Modified: 11:28:04" itemprop="dateCreated datePublished" datetime="2020-04-26T10:04:36+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>与大多数正规的面向对象编程语言不同，JS从创建之初就不支持类，也没有把类继承作为定义相似对象以及关联对象的主要方式。而从ES1诞生之前知道ES5时期，很多库都创建了一些工具，让JS显得貌似能支持类。</p>
<h3 id="ES5中仿类结构"><a href="#ES5中仿类结构" class="headerlink" title="ES5中仿类结构"></a>ES5中仿类结构</h3><p>JS在ES5以及更早版本中都不存在类。与类最接近的是：创建一个构造器，然后将方法指派到该构造起的原型上。这种方式通常被称为创建一个自定义类型。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonType(<span class="string">'Nicholas'</span>)</span><br><span class="line">person.sayName()  <span class="comment">//Nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonType)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)      <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>此代码中的 PersonType 是一个构造器函数，并创建了单个属性 name 。 sayName() 方法被指派到原型上，因此在 PersonType 对象的所有实例上都共享了此方法。接下来，使用 new运算符创建了 PersonType 的一个新实例 person ，此对象会被认为是一个通过原型继承了PersonType 与 Object 的实例。</p>
<h3 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h3><p>类在ES6中最简单的形式就是类声明，看起来向其他语言中的类</p>
<h4 id="基本的类声明"><a href="#基本的类声明" class="headerlink" title="基本的类声明"></a>基本的类声明</h4><p>类声明以class关键字开始，其后是类的名称；其余部分的语法看起来就像对象字面量中的方法简写，并且在方法之间不需要使用逗号。下为简单类声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonCladd</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于PersonType构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'Nicholas'</span>)</span><br><span class="line">person.sayName()   <span class="comment">//输出Nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass)     <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName)  <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<p>这个PersonClass类声明的行为非常类似上个例子中的PersonType。类声明允许在其中使用特殊的constructor方法名称直接定义一个构造器，而不需要先定义一个函数再把它当做构造器使用。由于累的方法使用类间歇语法，于是就不再需要使用function关键字。constructor之外的方法名称则没有特别的含义。<br>自有属性（Own properties）：该属性出现在实力上而不是原型上，只能在类的构造器或方法内部进行创建。在本例中，name就是一个自有属性。建议应在构造器函数内创建所有可能出现的自有属性，这样在类中声明变量就会被限制在单一位置（有助于代码检查）<br>相对于已有的<strong>自定义类型声明方式</strong>来说，<strong>类声明</strong>仅仅是以它为基础的一个语法糖。PersonClass声明实际上创建了一个拥有constructor方法以及其行为的函数，这也是typeof PersonClass会得到“function”结果的原因。此例中的sayName()方法最终也成为PersonClass.prorotype上的一个方法，类似于上个例子中的sayName()与PersonType。prototype之间的关系。这些相似处允许把自定义类型与类混合使用，而不必考虑该使用哪一个。</p>
<h4 id="为何要使用类的语法"><a href="#为何要使用类的语法" class="headerlink" title="为何要使用类的语法"></a>为何要使用类的语法</h4><p>尽管类与自定义类型之间有相似性，但仍然要记住一些重要的区别：<br>1.类声明不会被提升，这与函数定义不同。类声明的行为与let相似，因此在程序执行到达声明处之前，类会存在于暂时性死区内。<br>2.类声明中的所有代码会自动运行在严格模式下，并且也无法退出严格模式。<br>3.类的所有方法都是不可枚举的，这是对于自定义类型的显著变化，后者必须用Object.defineProperty()才能将方法改变为不可枚举。<br>4.类的所有方法内部都没有[[Construct]]，因此使用new来调用它们会抛出错误。<br>5.调用类构造器时不使用new，会抛出错误。<br>6.试图在类的方法内部重写类名，会抛出错误。<br>这样看来，上例中的PersonClass声明实际上就直接等价于一下未使用类语法的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接等价于PersonClass</span></span><br><span class="line"><span class="keyword">let</span> PersonType2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line">    <span class="keyword">const</span> PersonType = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 确认函数被调用时使用了new</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'constructor must be called with new'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(PersonType2.prototype, <span class="string">'sayName'</span>, &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 确认函数被调用时没有使用new</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'method cannot be called with new'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="keyword">return</span> PersonType2</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<p>首先要注意这里有两个PersonType2声明：一个在外部作用的let声明，一个在IIFE内部的const声明。这就是为何类的方法不能对类名进行重写、而类外部的代码则被允许。构造器函数检查了new.target，以保证被调用时使用了new，否则就抛出错误。接下来，sayName()方法被定义为不可枚举，并且此方法也检查了new.target，它则要保证在被调用时没有使用new。最后一步是将构造器函数返回出去。<br>此例说明了尽管不使用新语法也能实现类的任何特性，但类语法显著简化了所有功能的代码。<br>不变的类名<br>只有在类的内部，类名才被视为是使用const声明的。这意味着你可以在外部重写类名但不能再累的方法内部这么做。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        Foo = <span class="string">'bar'</span> <span class="comment">//执行时抛出错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但在类声明之后没问题</span></span><br><span class="line">Foo = <span class="string">'baz'</span></span><br></pre></td></tr></table></figure>

<p>在此代码中，类构造器内部的 Foo 与在类外部的 Foo 是不同的绑定。内部的 Foo 就像是用 const 定义的，不能被重写，当构造器尝试使用任何值重写 Foo 时，都会抛出错误。但由于外部的 Foo 就像是用 let 声明的，你可以随时重写类名。</p>
<h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p>类与函数有相似之处，即它们都有两种形式：声明与表达式。函数声明与类声明都以适当的关键词为起始分别是（function与class），随后是标识符（即函数名或类名）。函数具有一种表达式形式，无需在function后面使用表示；类似的，类也有不需要表示符的表达式形式。类表达式被设计用于变量声明，或可作为参数传递给函数。<br>基本的类表达式<br>此处是与上例中的PersonCladd等效的类表达式，随后的代码使用了它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于PersonType构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'nicholas'</span>)</span><br><span class="line">person.sayName()  <span class="comment">//输出nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass)   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)        <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass)              <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName) <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<p>正如磁力所示，类表达式不需要再class关键字后使用标识符。除了语法差异，类表达式的功能等价于类声明。<br>使用类声明还是类表达式，主要是代码风格的问题。相对于函数声明与函数表达式之间的区别，类声明与类表达式都不会被提升，因此对代码运行时的行为影响甚微。</p>
<h4 id="具名类表达式"><a href="#具名类表达式" class="headerlink" title="具名类表达式"></a>具名类表达式</h4><p>上一节的示例使用了一个匿名的类表达式，不过就像函数表达式那样，也可以为类表达式明明。为此需要在class关键字后添加标识符，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = calss PersonClass2 &#123;</span><br><span class="line">    <span class="comment">// 等价于PersonType构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass)   <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2)  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>此例中的类表达式被命名为PersonClass2。PersonClass2标识符只在类定义内部存在，因此只能用在类方法内部（例如本例中的sayName()内）。在类的外部，typeof PersonClass2的结果为undefined，这是因为外部不存在PersonClass2绑定。要理解为何如此，请查看未使用类语法的等价声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接等价于PersonClass具名的类表达式</span></span><br><span class="line"><span class="keyword">let</span> PersonClass = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="keyword">const</span> = PersonClass2 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 确认函数被调用时使用了new</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'constructor must be called with new'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    object.defineProperty(PersonClass2.prototype, <span class="string">'sayName'</span>, &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 确认函数被调用时没有使用new</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'method cannot be called with new'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> PersonClass2</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<p>创建具名的类表达式稍微改变了在JS引擎内部发生的事。对于类声明来说，外部绑定（用let定义）与内部绑定（用const定义）有着相同的名称。而类表达式可在内部使用const来定义它的不同名称，因此此处的PersonClass2只能在类的内部使用。<br>尽管具名类表达式的行为已于具名函数表达式，但它们之间仍有许多相似点。二者都能被当做值来使用，这开启了许多可能性。</p>
<h3 id="作为一级公民的类"><a href="#作为一级公民的类" class="headerlink" title="作为一级公民的类"></a>作为一级公民的类</h3><p>在编程中，能被当做值来使用的就称为一级公民（first-class citizen），意味着它能作为参数给函数、能作为函数返回值、能用来给变量赋值。JS的函数就是一级公民（它们有时又被称为一级函数），此特性让JS独一无二。<br>ES6延续了传统，让类同样成为一级公民。这就使得类可以被多种方式所使用。例如，它能作为参数传入函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crateObject</span>(<span class="params">classDef</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> classDef()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = createObject(<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.sayHi()      <span class="comment">//hi</span></span><br></pre></td></tr></table></figure>
<p>此例中的createObject()函数被调用时接收了一个匿名函数表达式作为参数，使用new创建了该类的一个实例，并将其返回出来。随后变量obj储存了所返回的实例。<br>类表达式的另一个又去用途是立即调用类构造器，以创建单例（Singleton）。为此，必须使用new来配合类表达式，并在表达式后面添加括号。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">'nicholas'</span>)</span><br><span class="line">person.sayName()   <span class="comment">//nicholas</span></span><br></pre></td></tr></table></figure>
<p>此处创建了一个匿名类表达式，并立即执行了它。此模式允许你使用类语法来创建单例类，从而不留下任何可被探查的类引用（回忆一下PersonClass的例子，匿名类表达式只在类的内部创建了绑定，而外部无绑定）。<strong>类表达式后面的圆括号表示要调用前面的函数，并且还允许传入参数。</strong></p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>自有属性需要在类构造器中创建，而类还允许在原型上定义访问器属性。为了创建一个getter，需要使用get关键字，并要与后方标识符之间留出空格；创建setter用相同方式，只是要换用set关键字。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> html() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> html(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(CustomHTMLElement.prototype, <span class="string">'html'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'get'</span> <span class="keyword">in</span> descriptor)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'set'</span> <span class="keyword">in</span> descriptor)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor,enumerable) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>此代码中的CustomHTMLElement类用于包装一个已存在的DOM元素，它的属性html拥有getter与setter，委托了元素自身的innerHTML方法。该访问器属性被创建在CUnstmHTMLElement.prototype上，并且像其他类属性那样被创建为不可枚举属性。非类的等价表示如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接等价于上个范例</span></span><br><span class="line"><span class="keyword">let</span> CustomHTMLElement = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="keyword">const</span> CustomHTMLElement = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 确认函数被调用时使用了new</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'constructor must be called with new'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.element = element</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(CustomHTMLElement.prototype, <span class="string">'html'</span>, &#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function(value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> CunstomHTMLElement</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<h3 id="需计算的成员名"><a href="#需计算的成员名" class="headerlink" title="需计算的成员名"></a>需计算的成员名</h3><p>对象字面量与类之间的相似点还不仅前面那些。类方法与访问器属性也都能使用需计算的名称。㞏相同于对象字面量中的需计算名称：无需使用标识符，而是用方括号来包裹一个表达式。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">'sayName'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> </span>= PersonClass &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    [methodName]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> PersonClass(<span class="string">'nicholas'</span>)</span><br><span class="line">me.sayName()                  <span class="comment">//'nicholas'</span></span><br></pre></td></tr></table></figure>
<p>此版本的PersonClass使用了一个变量来命名类定义内的方法。字符串”sayName“被赋值给了methodName变量，而methodName变量则被用于声明方法。sayName()方法在此后能被直接访问。<br>访问器属性能以相同方式使用需计算的名称，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">'html'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> [propertyName]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> [propertyName](value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处html的getter与setter被设置为需使用propertyName变量，使用.html依然能访问此属性，这里影响的只有定义方式。</p>
<h3 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    *createIterator() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Myclass()</span><br><span class="line"><span class="keyword">let</span> iterator = instance.createIterator()</span><br></pre></td></tr></table></figure>
<p>此处代码创建了一个拥有createIterator()生成器的MyClass类。该方法返回了一个迭代器，它的值在生成器内部用硬编码提供。当使用一个对象来表示值的集合、并要求能简单迭代这些值，那么生成器方法就非常有用。数组、Set与Map都拥有多个生成器方法，负责让开发者用多种方式来操作它们的项。<br>既然生成器方法很有用，那么在表示集合的自定义类中定义一个默认迭代器，那就更好。可以使用 Symbol.iterator 来定义生成器方法，从而定义出类的默认迭代器，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = []</span><br><span class="line">    &#125;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> *<span class="keyword">this</span>.items.values()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> Collection()</span><br><span class="line">collection.items.push(<span class="number">1</span>)</span><br><span class="line">collection.items.push(<span class="number">2</span>)</span><br><span class="line">collection.items.push(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此例为生成器方法使用了一个需计算名称，并将此方法委托到this.items数组的values()迭代器上。任意管理集合的类都包含一个默认迭代器，这是因为一些集合专用的操作都要求目标集合具有迭代器。现在，Collection的任意实例都可以在for-of循环内被直接使用，也能配合扩展运算符使用。<br>当你想让方法与访问器属性在对象实例上出现时，把它们添加到类的原型上就会对此目的有帮助。而另一方面，若想让方法与访问器属性只存在于类自身，那么你就需要使用静态成员。</p>
<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>直接在构造器上添加额外方法来模拟静态成员，这在ES5及更早版本中是另一个通用的模式。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">PersonType.create = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PersonType(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = PersonType.create(<span class="string">'nicholas'</span>)</span><br></pre></td></tr></table></figure>
<p>在其他编程语言中，工厂方法PersonType.create()会被认定为一个静态方法，它的数据不依赖PersonType的任何势力。ES6的类简化了静态成员的创建，只要在方法与访问器属性的名称前添加正式的static标注。作为一个例子，此处有个与上例等价的类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于PersonType构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于PersonType.create</span></span><br><span class="line">    <span class="keyword">static</span> create(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonClass(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = PersonClass.create(<span class="string">'nicholas'</span>)</span><br></pre></td></tr></table></figure>
<p>PersonClass 的定义拥有名为 create() 的单个静态方法，此语法与 sayName() 基本相同，只多了一个 static 关键字。你能在类中的任何方法与访问器属性上使用 static 关键字，唯一限制是不能将它用于 constructor 方法的定义。<br><strong>静态成员不能用实例来访问，始终需要直接用类自身来访问它们</strong></p>
<h3 id="使用派生类进行继承"><a href="#使用派生类进行继承" class="headerlink" title="使用派生类进行继承"></a>使用派生类进行继承</h3><p>ES6之前，实现自定义类型的继承是个繁琐的过程。严格的继承要求有多个步骤。例如，研究一下范例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length*<span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">    Rectangle.call(<span class="keyword">this</span>, length, length)</span><br><span class="line">&#125;</span><br><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: Square,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea())    <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Square继承了Rectangle，为此它必须使用Rectangle.prototype所创建的一个新对象来重写Square.prototype，并且还要调用Rectangle.call()方法。<br>类让继承工作变得更轻易，使用熟悉的extends关键字来指定当给钱类所需要的继承的函数即可。生成的类的原型会被自动调整，而你还能调用super()方法来访问基类的构造器。此处是与上个例子等价的ES6代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="comment">// 与Rectangle.call(this, length, length)相同</span></span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square = Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea)       <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square)   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>此次Square类使用了extends关键字继承了Rectangle。Square构造器使用了super()配合指定参数调用了Rectangle构造器。注意与ES5版本的代码不同，Rectangle标识符尽在类定义时被使用了（在extends之后）。<br>继承了其他类的类被称为派生类（derived classes）。如果派生类指定了构造器，就需要使用super(),否则就会造成错误。若不使用构造器，super()方法会被自动调用，并会使用创建新实例时提供的所有参数。例如，下列两个类是完全相同的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有构造器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此例中的第二个类展示了与所有派生类默认构造器等价的写法，所有的参数都按顺序传递给了基类的构造器。在当前需求下，郑重做法并不完全准确，因为Square构造器只需要单个参数，因此最好手动定义构造器。<br>使用 super() 时需牢记以下几点：</p>
<ol>
<li>你只能在派生类中使用 super() 。若尝试在非派生的类（即：没有使用 extends关键字的类）或函数中使用它，就会抛出错误。</li>
<li>在构造器中，你必须在访问 this 之前调用 super() 。由于 super() 负责初始化this ，因此试图先访问 this 自然就会造成错误。</li>
<li>唯一能避免调用 super() 的办法，是从类构造器中返回一个对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name</span><br><span class="line">		<span class="keyword">this</span>.age = age</span><br><span class="line">	&#125;</span><br><span class="line">	sayAge() &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name, age, classNum) &#123;</span><br><span class="line">		<span class="keyword">super</span>(name, age)  <span class="comment">//注释之后报错，没有this</span></span><br><span class="line">		<span class="keyword">this</span>.classNum = classNum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xiaoHong = <span class="keyword">new</span> Student(<span class="string">'xiaohong'</span>, <span class="string">'12'</span>, <span class="string">'class3'</span>)</span><br><span class="line">xiaoHong.sayAge()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="屏蔽类方法"><a href="#屏蔽类方法" class="headerlink" title="屏蔽类方法"></a>屏蔽类方法</h4><p>派生类中的方法总是会屏蔽基类的同名方法。例如，可以将getArea()方法添加到Super类，以便重定义它的功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于getArea()已经被定义为Square的一部分，Rectangle.prototype.getArea()方法就不能再Square的任何实例上被调用。当然，总可以使用super.getArea()方法来调用基类中的同名方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getArea()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承静态成员"><a href="#继承静态成员" class="headerlink" title="继承静态成员"></a>继承静态成员</h4><p>如果基类包含静态成员，那么这些静态成员在派生类中也是可用的。继承的工作方式类似于其他语言。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> create(length, width) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rectangle(length, width)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="comment">// 与Rectangle.call(this, length, length)相同</span></span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rect = Square.create(<span class="number">3</span>, <span class="number">4</span>)   </span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(rect.getArea())             <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Square)     <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>在此代码中，一个新的静态方法 create() 被添加到 Rectangle 类中。通过继承，该方法会以 Square.create() 的形式存在，并且其行为方式与 Rectangle.create() 一样。</p>
<h4 id="从表达式中派生类"><a href="#从表达式中派生类" class="headerlink" title="从表达式中派生类"></a>从表达式中派生类</h4><p>在ES6中派生类的最强大能力，或许就是能够从表达式中派生类。只要一个表达式能够返回一个具有[[Construct]]属性以及原型的函数，就可以对其使用extends。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(x.getArea())             <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Rectangle被定义为ES5风格的构造器，而Square则是一个类。由于Rectangle具有[[Construct]]以及原型，Square类就能直接继承它。<br>extends后面能接受任意类型的表达式，这带来了巨大可能性，例如动态地决定所要继承的类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Rectangle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">getBase</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(x.getArea())   <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>getBase()函数作为类声明的一部分被直接调用，它返回了Rectangle，是的此例的功能等价于前一个例子。并且由于可以动态地决定基类，就能创建不同的继承方式。例如可以有效地创建混入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> SerializableMixin = &#123;</span><br><span class="line">    serialize() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> AreaMixin = &#123;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.assign(base.prototype, ...mixins)</span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">mixin</span>(<span class="title">AreaMixin</span>, <span class="title">SerializableMixin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(x.getArea())</span><br><span class="line"><span class="built_in">console</span>.log(x.serialize())  <span class="comment">//&#123;length: 3, width: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>此例使用了混入（mixin）而不是传统继承。mixin()函数接受代表混入对象的任意数量的参数，它创建了一个名为base的函数，并将每个混入对象的属性都赋值到新函数的原型上。阐述随后返回，于是Square就能够对其使用extends关键字了。注意由于仍然使用了extends，就必须在构造器内调用super().<br>Square的实例既有来自AreaMixin的getArea()方法，又有来自SerilaizableMixin的serialize()方法，这是通过原型继承实现的。mixin()函数使用了混入对象的所有自有属性，动态地填充了新函数的原型（注意：若多个混入对象拥有相同的属性，则只有最后添加的属性会被保留）。<br>任意表达式都能在extends关键字后使用，但并非所有表达式的结果都是一个有效的类。特别的，下列表达式类型会导致错误：<br>null;<br>生成器函数<br>试图使用结果为上述值得表达式来创建一个新的类实例，都会抛出错误，因为不存在[[Construct]]可供调用。</p>
<h4 id="继承内置对象"><a href="#继承内置对象" class="headerlink" title="继承内置对象"></a>继承内置对象</h4><p>几乎从JS数组出现那天开始，开发者就像通过继承机制来创建它们自己的特殊数组类型。在ES5及早期版本中，这是不可能做到的。试图使用传统继承并不能产生功能正确的代码，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置数组的行为</span></span><br><span class="line"><span class="keyword">var</span> colors = []</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])  <span class="comment">//undefined</span></span><br><span class="line"><span class="comment">// 在ES5中尝试继承数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">myArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: MyArray,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray()</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)  <span class="comment">//0</span></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])      <span class="comment">//red</span></span><br></pre></td></tr></table></figure>
<p>console.log()在此代码尾部的输出说明：对数组使用传统形式的JS继承，产生了预期外的行为。MyArray实例上的length属性以数值属性，其行为与内置数组并不一致，因为这些功能并未被涵盖在Array.apply()或数组原型中。<br>在ES6中的类，其设计目的之一就是允许从内置对象上进行继承。为了达成这个目的，类的继承模型与ES5或更早版本的传统继承模型有轻微差异：<br>在ES5的传统继承中，this的值会先被派生类（例如MyArray）创建，随后基类构造器（例如Array.apply()方法）才被调用。这意味着this一开始就是MyArray的实例，之后才使用了Array的附加属性对其进行了装饰。<br>在ES6基于类的继承中，this的值会先被基类（Array）创建，随后才被派生类的构造器（MyArray）所修改。结果是this初始就拥有作为基类的内置对象的所有功能，并能正确接收与之关联的所有功能。<br>一下范例实际展示了基于类的特殊数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray()</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)    <span class="comment">//1</span></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])    <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>MyArray直接继承了Array，因此工作方式与正规数组一致。与数值索引属性额互动更新了length属性，而操纵length属性也能更新索引属性。这意味着既能适当地继承Array来创建自己的派生数组类，也同样能继承其他的内置对象。</p>
<h4 id="Symbol-species属性"><a href="#Symbol-species属性" class="headerlink" title="Symbol.species属性"></a>Symbol.species属性</h4><p>继承内置对象一个有趣的方面是：任意能返回内置对象实例的方法，在派生类的实例。因此，若拥有类一个继承了Array的派生类MyArray，注入slice()之类的方法都会返回MyArray的实例。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">    subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在此代码中，slice()方法返回了MyArray的一个实例。slice()方法是从Array上继承的，原本应当返回Array的一个实例。而Symbol.species属性在后台造成了这种变化。<br>Symbol.species是名符号被用于定义一个能返回函数的静态访问器属性。每当类实例的方法（构造器除外）必须常建一个实例时，前面返回的函数就被用为新实例的构造器。下列内置类型都定义了Symbol.species:<br>Array<br>ArrayBuffer<br>Map<br>Promise<br>RegExp<br>Set<br>类型化数组<br>以上每个类型都拥有默认的Symol.species属性，其返回值为this，意味着该属性总会返回自身的构造器函数。若准备在一个自定义类上实现此功能，代码就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 几个内置类型使用species的方式类似于此</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    clone() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再此例中，Symbol.species知名符号被用于定义MyClass的一个静态访问器属性。注意此处只有getter而没有setter，这是因为修改累的species是不允许的。任何对this.constructor[Symbol.species]的调用都会返回MyClass，clone()方法使用了该定义来返回一个新的实例，而没有直接使用MyClass，这就允许派生类重写这个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    clone() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDerivedClass1</span> <span class="keyword">extends</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"><span class="comment">// 空代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDerivedClass2</span> <span class="keyword">extends</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyClass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> MyDerivedClass1(<span class="string">"foo"</span>),</span><br><span class="line">clone1 = instance1.clone(),</span><br><span class="line">instance2 = <span class="keyword">new</span> MyDerivedClass2(<span class="string">"bar"</span>),</span><br><span class="line">clone2 = instance2.clone();</span><br><span class="line"><span class="built_in">console</span>.log(clone1 <span class="keyword">instanceof</span> MyClass); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(clone1 <span class="keyword">instanceof</span> MyDerivedClass1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(clone2 <span class="keyword">instanceof</span> MyClass); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(clone2 <span class="keyword">instanceof</span> MyDerivedClass2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>此处, MyDerivedClass1 继承了 MyClass ，并且未修改 Symbol.species 属性。由于this.constructor[Symbol.species] 会返回 MyDerivedClass1 ，当 clone() 被调用时，它就返回了 MyDerivedClass1 的一个实例。 MyDerivedClass2 类也继承了 MyClass ，但重写了Symbol.species ，让其返回 MyClass 。当 clone() 在 MyDerivedClass2 的一个实例上被调用时，返回值就变成 MyClass 的一个实例。使用 Symbol.species ，任意派生类在调用应当返回实例的方法时，都可以判断出需要返回什么类型的值。<br>例如， Array 使用了 Symbol.species 来指定方法所使用的类，让其返回值为一个数组。在Array 派生出的类中，你可以决定这些继承的方法应返回何种类型的对象，正如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>此代码重写了从 Array 派生的 MyArray 类上的 Symbol.species 。所有返回数组的继承方法现在都会使用 Array 的实例，而不是 MyArray 的实例。<br>一般而言，每当想在类方法中使用 this.constructor 时，你就应当设置类的Symbol.species 属性。这么做允许派生类轻易地重写方法的返回类型。此外，若你从一个拥有 Symbol.species 定义的类创建了派生类，要保证使用此属性，而不是直接使用构造器。</p>
<h4 id="在类构造器中使用new-target"><a href="#在类构造器中使用new-target" class="headerlink" title="在类构造器中使用new.target"></a>在类构造器中使用new.target</h4><p>在第三章你已学到了 new.target ，以及在调用函数的方式不同时它的值是如何变动的。你也可以在类构造器中使用 new.target ，来判断类是被如何被调用的。在简单情况下，new.target 就等于本类的构造器函数，正如下例；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new.target 就是 Rectangle</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>
<p>此代码说明在 new Rectangle(3, 4) 被调用时， new.target 就等于 Rectangle 。类构造器被调用时不能缺少 new ，因此 new.target 属性就始终会在类构造器内被定义。不过这个值并不总是相同的。研究以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new.target 就是 Square</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>
<p>Square 调用了 Rectangle 构造器，因此当 Rectangle 构造器被调用时， new.target 等于Square 。这很重要，因为构造器能根据如何被调用而有不同行为，并且这给了更改这种行为的能力。例如，你可以使用 new.target 来创建一个抽象基类（一种不能被实例化的类），如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This class cannot be instantiated directly."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape(); <span class="comment">// 抛出错误</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 没有错误</span></span><br><span class="line"><span class="built_in">console</span>.log(y <span class="keyword">instanceof</span> Shape); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>此例中的 Shape 类构造器会在 new.target 为 Shape 的时候抛出错误，意味着 newShape() 永远都会抛出错误。然而，你依然可以将 Shape 用作一个基类，正如 Rectangle所做的那样。 super() 的调用执行了 Shape 构造器，而且 new.target 的值等于Rectangle ，因此该构造器能够无错误地继续执行。<br>由于调用类时不能缺少 new ，于是 new.target 属性在类构造器内部就绝不会是undefined 。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/iframe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/iframe/" class="post-title-link" itemprop="url">iframe</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 10:04:36 / Modified: 11:24:38" itemprop="dateCreated datePublished" datetime="2020-04-26T10:04:36+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>每个嵌入的浏览器上下文（embedded browsing context）都有自己的会话历史记录和dom树。包含嵌入内容的浏览器上下文成为符浏览上下文。顶级浏览上下文（即没有父级）通常是由window对象表示的浏览器窗口。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>该元素包含全局属性。<br>这里只介绍比较常用的几个<br>name： 用于定位嵌入的浏览器上下文的名称。该名称可以用作<a>标签与<form>标签的target属性值，也可以用作<input>标签和<button>标签的formtarget属性值，还可以用作window.open()方法的windowName参数值。</p>
<p>src：被嵌套的页面的URL地址。使用about:blank值可以嵌入一个遵从同源策略的空白页。</p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>内联的框架，就像<frame>元素一样，会被包含在window.frames伪数组中。<br>有了DOMHTMLIFrameElement对象，脚本可以通过contentWindow访问内联框架的window对象。contentDocument属性则引用了<iframe>内部的document元素。<br>在框架内部，脚本可以通过window.parent引用父窗口对象。<br>脚本访问框架内容必须遵守同源策略，并且无法访问同源的window对象的几乎所有属性。同源策略同样适用于子窗体访问父窗体的window对象。跨域通信可以通过window.postMessage实现。</p>
<p>window.postMessage()方法可以安全地事项跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于相同的协议通常为https，端口号（443位https的默认值），以及主机（两个页面的模数Document.domain设置相同的值）时，两个脚本才能相互通信。<br>window.postMessage()方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。<br>从广义上讲，一个窗口可以获得对另一个窗口的引用（比如targetWindow= window.opener),然后在窗口上调用targetWindow.postMessage()方法分发一个MessageEvent消息。接收消息的窗口可以根据需要自由处理此事件。传递给window.postMessage()的参数（比如message）将通过消息事件对象暴露给接收消息的窗口。</p>
<h3 id="postMessage语法"><a href="#postMessage语法" class="headerlink" title="postMessage语法"></a>postMessage语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer])</span><br></pre></td></tr></table></figure>
<p>otherWindow:其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是明明过或数值索引的window.frames.</p>
<p>message: 将要发送到其他window的数据。它将会被结构化克隆算法序列化。这意味着可以不受什么限制的将数据对象安全地传送给目标窗口而无需自己序列化。</p>
<p>targetOrigin：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”<em>“</em>（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是”*”。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。</p>
<p><strong>对otherWindw和targetOrigin的理解</strong>：otherWindow设定了要传递信息的窗口，并不会限制信息只向这个窗口传递信息。targetOrigin设定了要传递窗口所在的URI包括协议，主机和端口。</p>
<p>transfer 可选<br>是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</p>
<p>利用postMessage可以实现子域和父域相互传递消息以及不同域之间的通信。<br>message事件监听</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// For Chrome, the origin property is in the event.originalEvent</span></span><br><span class="line">  <span class="comment">// object. </span></span><br><span class="line">  <span class="comment">// 这里不准确，chrome没有这个属性</span></span><br><span class="line">  <span class="comment">// var origin = event.origin || event.originalEvent.origin; </span></span><br><span class="line">  <span class="keyword">var</span> origin = event.origin</span><br><span class="line">  <span class="keyword">if</span> (origin !== <span class="string">"http://example.org:8080"</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> message 的属性有:</p>
<p>data<br>从其他 window 中传递过来的对象。<br>origin<br>调用 postMessage  时消息发送方窗口的 origin . 这个字符串由 协议、“://“、域名、“ : 端口号”拼接而成。例如 “<a href="https://example.org" target="_blank" rel="noopener">https://example.org</a> (隐含端口 443)”、“<a href="http://example.net" target="_blank" rel="noopener">http://example.net</a> (隐含端口 80)”、“<a href="http://example.com:8080”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。">http://example.com:8080”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。</a><br>source<br>对发送消息的窗口对象的引用; 您可以使用此来在具有不同origin的两个窗口之间建立双向通信</p>
<p>不同域之间传递</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A窗口的域名是&lt;http://example.com:8080&gt;，以下是A窗口的script标签下的代码：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(...popup details...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果弹出框没有被阻止且加载完成</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这行语句没有发送信息出去，即使假设当前页面没有改变location（因为targetOrigin设置不对）</span></span><br><span class="line">popup.postMessage(<span class="string">"The user is 'bob' and the password is 'secret'"</span>,</span><br><span class="line">                  <span class="string">"https://secure.example.net"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设当前页面没有改变location，这条语句会成功添加message到发送队列中去（targetOrigin设置对了）</span></span><br><span class="line">popup.postMessage(<span class="string">"hello there!"</span>, <span class="string">"http://example.org"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 我们能相信信息的发送者吗?  (也许这个发送者和我们最初打开的不是同一个页面).</span></span><br><span class="line">  <span class="keyword">if</span> (event.origin !== <span class="string">"http://example.org"</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// event.source 是我们通过window.open打开的弹出页面 popup</span></span><br><span class="line">  <span class="comment">// event.data 是 popup发送给当前页面的消息 "hi there yourself!  the secret response is: rheeeeet!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 弹出页 popup 域名是&lt;http://example.org&gt;，以下是script标签中的代码:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当A页面postMessage被调用后，这个function被addEventListenner调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 我们能信任信息来源吗？</span></span><br><span class="line">  <span class="keyword">if</span> (event.origin !== <span class="string">"http://example.com:8080"</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// event.source 就当前弹出页的来源页面</span></span><br><span class="line">  <span class="comment">// event.data 是 "hello there!"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假设你已经验证了所受到信息的origin (任何时候你都应该这样做), 一个很方便的方式就是把event.source</span></span><br><span class="line">  <span class="comment">// 作为回信的对象，并且把event.origin作为targetOrigin</span></span><br><span class="line">  event.source.postMessage(<span class="string">"hi there yourself!  the secret response "</span> +</span><br><span class="line">                           <span class="string">"is: rheeeeet!"</span>,</span><br><span class="line">                           event.origin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>跨域POST消息发送<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span>   </span><br><span class="line"><span class="actionscript">            <span class="comment">// sendPost 通过postMessage实现跨域通信将表单信息发送到 moweide.gitcafe.io上,</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 并取得返回的数据   </span></span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">sendPost</span><span class="params">()</span> </span>&#123;       </span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 获取id为otherPage的iframe窗口对象       </span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> iframeWin = <span class="built_in">document</span>.getElementById(<span class="string">"otherPage"</span>).contentWindow;       </span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 向该窗口发送消息       </span></span></span><br><span class="line"><span class="javascript">                iframeWin.postMessage(<span class="built_in">document</span>.getElementById(<span class="string">"message"</span>).value, <span class="string">'http://moweide.gitcafe.io'</span>);   </span></span><br><span class="line">            &#125;   </span><br><span class="line"><span class="actionscript">            <span class="comment">// 监听跨域请求的返回   </span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;       </span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(event, event.data);   </span></span><br><span class="line"><span class="actionscript">            &#125;, <span class="literal">false</span>);</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"发送"</span> <span class="attr">onclick</span>=<span class="string">"sendPost()"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">"http://moweide.gitcafe.io/other-domain.html"</span> <span class="attr">id</span>=<span class="string">"otherPage"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 子窗体接收信息并处理 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>POST Handler<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//code.jquery.com/jquery-1.11.0.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/JavaScript"</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 监听父窗口发送过来的数据向服务器发送post请求</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> data = event.data;</span></span><br><span class="line"><span class="javascript">                $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 注意这里的url只是一个示例.实际练习的时候你需要自己想办法提供一个后台接口</span></span></span><br><span class="line"><span class="actionscript">                    type: <span class="string">'POST'</span>,</span></span><br><span class="line"><span class="actionscript">                    url: <span class="string">'http://moweide.gitcafe.io/getData'</span>,</span></span><br><span class="line"><span class="actionscript">                    data: <span class="string">"info="</span> + data,</span></span><br><span class="line"><span class="actionscript">                    dataType: <span class="string">"json"</span></span></span><br><span class="line"><span class="actionscript">                &#125;).done(<span class="function"><span class="keyword">function</span><span class="params">(res)</span></span>&#123;       </span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//将请求成功返回的数据通过postMessage发送给父窗口       </span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">window</span>.parent.postMessage(res, <span class="string">"*"</span>);   </span></span><br><span class="line"><span class="actionscript">                &#125;).fail(<span class="function"><span class="keyword">function</span><span class="params">(res)</span></span>&#123;       </span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//将请求失败返回的数据通过postMessage发送给父窗口       </span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">window</span>.parent.postMessage(res, <span class="string">"*"</span>);   </span></span><br><span class="line">                &#125;);</span><br><span class="line"><span class="actionscript">            &#125;, <span class="literal">false</span>);</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/https/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/https/" class="post-title-link" itemprop="url">HTTPS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 10:04:36 / Modified: 11:30:27" itemprop="dateCreated datePublished" datetime="2020-04-26T10:04:36+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HTTPS协议是基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护。HTTPS协议不是明文。</p>
<p>HTTPS有以下特定：<br>1.内容加密：采用混合加密技术，中间者无法直接查看明文内容；<br>2.验证身份：通过证书认证客户端访问的是自己的服务器；<br>3.保护数据完整性：防止传输的内容被中间人冒充或者篡改</p>
<p><strong>混合加密：</strong>结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。</p>
<p><strong>数字摘要：</strong>通过单向hash函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。</p>
<p><strong>数字签名技术：</strong>数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。</p>
<p>收方能够证实发送方的真实身份；<br>发送方事后不能否认所发送过的报文；<br>收方或非法者不能伪造、篡改报文。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/DOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/DOM/" class="post-title-link" itemprop="url">DOM相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 10:04:36 / Modified: 11:18:00" itemprop="dateCreated datePublished" datetime="2020-04-26T10:04:36+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>DOM文档对象模型，是针对HTML和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。</p>
<h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><p>DOM可以将任何HTML或XML文档描绘成一个由多个节点构成的结构。节点分为几种不同类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点数据和方法。另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面编辑则表现为一个一特定节点为根节点的树形结构.</p>
<h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><p>DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型实现的。JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。<br>每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的12个数值常量表示。</p>
<p>1.nodeName和nodeValue属性<br>要了解节点的具体信息，可以使用nodeName和nodeValue这两个属性。这两个属性的值完全取决于节点的类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>) &#123;  <span class="comment">//nodeType = 1表示为一个元素</span></span><br><span class="line">    value = someNode.nodeName  <span class="comment">//nodeName的值是元素的标签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.节点关系<br>文档中所有的节点之间都存在着联系。在HTML中，可以将<body>元素看成是<html>元素的子元素；相应的，就可以把<html>元素看成是<body>元素的父元素。而<head>元素，则可以看成是<body>元素的同胞元素，因为它们都是同一个父元素<html>的直接子元素。</p>
<p>每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种类数组对象，用于保存一组有序的节点，可以通过为止来访问这些节点。<strong>NodeList对象实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反应在NodeList对象中。我们常说，NodeList是有生命的、有呼吸的对象，而不是在我们第一次访问他们的某个瞬间拍摄下来的一张快照。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> count = someNode.childNodes.length</span><br></pre></td></tr></table></figure>
<p>其中length属性表示的是访问NodeList的那一刻，其中包含的节点数量。</p>
<p>3.操作节点<br>DOM提供了一些操作节点的方法。其中最常用的方法是appendChild()，用于向childNodes列表的末尾添加一个节点。添加节点后，childNodes的新增节点、父节点及以前的最后一个子节点的关系指针都会相应地得到更新。更新完成后，appendChild()返回新增的节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(newNode)</span><br><span class="line">alert(returnedNode == newNode) <span class="comment">//true</span></span><br><span class="line">alert(someNode.lastChild == newNode)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>如果传入到appendChild中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新的位置</strong>。即可以将DOM树看成是由一些列指针连接起来的，任何DOM节点不能同时出现在文档中的多个位置。因此如果调用appendChild()时传入了父节点的第一个子节点，那么该节点就会成为父节点的最后一个子节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(someNode.firstChild)</span><br><span class="line">alert(returnedNode == someNode.firstNode)  <span class="comment">//false</span></span><br><span class="line">alert(returnedNode == someNode.lastChild)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>如果需要把节点放在childNodes列表中某个特定的位置上，而不是放在末尾，那么可以使用insertBefore()方法。这个方法接收连个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节的前一个同胞节点，同时被方法返回。如果参照节点是null，则insertBefore()与appendChild()执行相同的操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入后成为最后一个子节点</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, <span class="literal">null</span>)</span><br><span class="line">alert(newNode == someNode.lastChild)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入后成为第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.insertBefore(newNode, someNode.firstChild)</span><br><span class="line">alert(returnedNode == newNode)  <span class="comment">//true</span></span><br><span class="line">alert(newNode == someNode.firstChild)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入到最后一个子节点前面</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, someNode.lastChild)</span><br><span class="line">alert(newNode == someNode.childNodes[someNode.childNodes.length - <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>replaceChild()方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点是将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.replaceChild(newNode, someNode.firstChild)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换最后一个子节点</span></span><br><span class="line">returnedNode = someNode.replaceChild(newNode, someNode.lastChild)</span><br></pre></td></tr></table></figure>
<p>在使用replaceChild()插入一个节点时，该节点的所有关系指针都会从被它替换的节点复制过来。被替换的节点还在文档中，但没有了自己的位置。<br>以上三个方法只针对有子节点的节点，没有子节点的节点调用后会报错。</p>
<p>4.其他方法<br>有两个方法是所有类型的节点都有的。第一个是cloneNode()，用于创建调用这个方法的节点的一个完全相同的副本。cloneNode()方法接受一个布尔参数，表示是否执行深复制。在参数为true的情况下，执行深复制，也就是复制节点及其整个子节点树；在参数为false的情况下，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。</p>
<p>另一种方法是normalize(),这个方法唯一的作用就是处理文档树中的文本节点。由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。</p>
<h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><p>JavaScript通过Document类型表示文档。<strong>在浏览器中，document对象是HTMLDocument(继承自Document类型)的一个实例，表示整个HTML页面</strong>。而且document对象时window对象的一个属性，因此可以将其作为全局对象来访问。</p>
<p>1.文档信息<br>document对象的一些属性能够表现网页的一些信息。<br>1）document.title<br>通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。</p>
<p>2）document.URL<br>该属性包含着页面完整的URL</p>
<p>3）document.domain<br>该属性中包含着页面的域名，可以设置，但并不是可以任意设置。如果URL中包含一个子域名，例如p2p.wrox.com，那么就只能将domain设置为wrox.com。不能讲这个属性设置为URL中不包含的域。两个页面同时设置为相同的document.domain则可进行通信。<br>但是初始是松散的如wrox.com，则不能再将其设置为紧绷的p2p.wrox.com。</p>
<p>4）document.referrer<br>该属性中保存着链接到当前页面的那个页面的URL。在没有来源页面的情况先，referrer属性中可能会包含空字符串。</p>
<p>3.查找元素<br>有几种查找元素的方法：<br>1.getElementByID()，接收一个参数，要取得的元素的ID。如果找到则返回，否则返回null</p>
<p>2.getElementByTagName()。这个方法接受一个参数，即要取得元素的标签名，而返回的是包含零过多个元素的NodeList。在HTML文档中，这个方法会返回一个HTMLCollection对象，作为一个动态几何，该对象与NodeList非常类似。</p>
<p>3.getElementByName()<br>只有HTMLDocument类型才有的方法。这个方法会返回带有给定的name特性的所有元素。</p>
<p>4.文档写入<br>有一个document对象的功能已经存在很多年了，那就是将输出流写入到网页的能力。这个能力体现在下列4个方法中：<br>1.write()和writeln()<br>write()和writeln()方法都接受一个字符串参数，即要写入到输出流中的文本。write()会远洋写入，而writeln()则会在字符串的末尾添加一个换行符（\n)。页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>the current date and time is:</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript&gt;</span></span></span><br><span class="line">document.write("&lt;strong&gt;" + (new Data()).toString() + "&lt;/strong&gt;")</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.open(),close()<br>open()和close()分别用于打开和关闭网页的输出流。如果是在页面加载期间使用write()或writeln()方法，则不需要用到这两个方法。</p>
<h3 id="使用NodeList"><a href="#使用NodeList" class="headerlink" title="使用NodeList"></a>使用NodeList</h3><p>理解NodeList、NameNodeMap和HTMLCollection，是从整体上透彻理解DOM的关键所在。这三个集合都是动态地；换句话说，当文档结构发生变化时，它们都会得到更新。因此，它们始终都会保存着最新、最准确的信息。从本质上讲，所有NodeList对象都是在访问DOM文档时实时运行的查询。<br>如下代码将导致无限循环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">var</span> i</span><br><span class="line"><span class="keyword">var</span> div</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.length; i++) &#123;</span><br><span class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行代码会取得文档中所有<div>元素的HTMLCollection。由于这个集合是动态地，因此只要有新的<div>元素被添加到页面中，这个元素也会被添加到该集合中。浏览器不会将创建的所有集合都保存在一个列表中，而是在下一次访问集合时再更新集合。由此将导致无限循环。</p>
<h2 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h2><h3 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h3><p>众多JavaScript库中最常用的一项功能，就是根据CSS选择符与某个模式匹配的DOM元素。Selectors API Level 1的核心是两个方法：querySelector()和querySelectorAll()。</p>
<p>1.querySelector()方法<br>querySelector()方法接受一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>)</span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">'#myDiV'</span>)</span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">'.selected'</span>)</span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.body.querySelector(<span class="string">'img.button'</span>)</span><br></pre></td></tr></table></figure>

<p>2.querySelectorAll()方法<br>querySelectorAll()方法接收的参数与querySelector()方法一样，都是一个CSS选择符，但返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的的是一个NodeList的实例。<br>具体来说，返回的值实际上是带有所有属性和方法的NodeList，而其底层实现类似于一组元素的快照，而非不断对文档进行搜索的动态查询。这样实现可以避免使用NodeList对象通常会引起的大多数性能问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/css%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/css%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">CSS相关基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 10:04:36 / Modified: 11:30:30" itemprop="dateCreated datePublished" datetime="2020-04-26T10:04:36+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CSS工作原理"><a href="#CSS工作原理" class="headerlink" title="CSS工作原理"></a>CSS工作原理</h2><p>每个HTML元素都有一组样式属性，可以通过CSS来设定。这些属性涉及元素在屏幕上显示时的不同方面，比如在屏幕上位置，边框宽度，文本内容的字体，字号和颜色等等。CSS就是一种先选择HTML元素，然后设定选中元素CSS属性的机制。<strong>CSS选择符要应用的样式构成了一条CSS规则。</strong><br><em>为文档添加样式的三种方法</em><br>1.行内样式<br>行内样式是写在特定HTML标签的style属性里的。行内样式的作用范围非常有限。行内样式只能影响它所在的标签，而且会覆盖嵌入样式和链接样式。<br>2.嵌入样式<br>嵌入的CSS样式是放在HTML文档的head元素中的。<em>嵌入样式的应用范围仅限于当前页面。</em>页面样式会覆盖外部样式表中的样式，但会被行内样式覆盖。<br>3.链接样式<br>在创建包含多个页面的网站时，需要把样式集中在一个单独的文件里，这个文件就叫样式表。样式表其实就是一个扩展名为.css的文本文件。可以在任意多个HTML页面中连接同一个样式表文件每个页面中只需要加入类似下面的这一行代码即可：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>链接样式的作用范围可以是整个网站。只要使用<link>标签把样式表链接到每个页面，相应的页面就可以使用其中的样式。随后，只要修改了样式表中的样式，改动就会在所有被选中的元素上体现出来，无论这个元素在哪个页面里。这样，既可以做到全栈页面外观统一，又便于征战样式更新。<br>除了以上三种为页面添加样式的方法，还有一种在样式表中链接其他样式表的方法就是应用@import指令（是一种at规则）：<br>@import url(css/style2.css)<br>要注意的是，@import指令必须出现在样式表中其他样式之前，否则@import引用的样式表不会被加载。<strong>在加载页面方面，使用link的引用的文件，被同时加；@import引用的文件，要在页面加载完毕后才会被加载。</strong><br>有一点很重要，那就是 CSS 样式是通过<style>标签嵌入到页面里的。当浏览器遇到开标签<style>时，就会由解释 HTML 代码切换为解释 CSS 代码。等遇到闭标签</style>时，它会再切换回解释 HTML 代码。<br>对于写在样式表里的样式，就不需要<style>标签了。如果你在样式表里加上这个标签，样式表中的样式就不会被浏览器加了。</p>
<h3 id="上下文选择符"><a href="#上下文选择符" class="headerlink" title="上下文选择符"></a>上下文选择符</h3><p>上下文选择符的格式如下：<br>标签1 标签2 {声明}<br>其中，标签2就是我们想要选择的目标，而且只有在标签1是器祖先元素（不一定是父元素）的情况下才会被选中。<br>上下文选择符，严格来讲（也就是CSS规范里），叫后代组合式选择符（descendant combinator selector），就是一组以空格分隔的标签。用于选择作为指定祖先元素后代的标签。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span> &#123;<span class="attribute">font-weight</span>: bold;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特殊的上下文选择符"><a href="#特殊的上下文选择符" class="headerlink" title="特殊的上下文选择符"></a>特殊的上下文选择符</h3><p>上一节的上下文选择符是以某个祖先标签作为上下文。只要有标签在它的层次结构“上游”存在这么一个祖先，那么就会选中改标签。无论从该标签到作为祖先的上下文之间间隔着多少层次都没有关系。不过，有时候我们可能还会需要比“某些祖先”更具体的上下文。</p>
<h4 id="子选择符-gt"><a href="#子选择符-gt" class="headerlink" title="子选择符&gt;"></a>子选择符&gt;</h4><p>标签1&gt;标签2<br>标签2必须是标签1的子元素</p>
<h4 id="紧邻通报选择符"><a href="#紧邻通报选择符" class="headerlink" title="紧邻通报选择符+"></a>紧邻通报选择符+</h4><p>标签1+标签2<br>标签2必须紧跟在其同胞标签的后面</p>
<h4 id="一般同胞选"><a href="#一般同胞选" class="headerlink" title="一般同胞选"></a>一般同胞选</h4><p>标签1~标签2<br>标签2必须跟（不一定紧跟）在其同胞标签1后面</p>
<h4 id="通用选择符"><a href="#通用选择符" class="headerlink" title="通用选择符*"></a>通用选择符*</h4><p>通用选择符*（常被称为星号选择符）是一个通配符，它匹配任何元素，因此下面这条规则</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#123;<span class="attribute">color</span>: green;&#125;</span><br></pre></td></tr></table></figure>
<p>会导致所有元素（的文本和边框）都变成绿色。不过，一般在使用*选择符时，都会同时使用另一个选择符，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> * &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure>
<p>这样只会把 p 包含的所有元素的文本变成红色。这个选择符有一个非常有意思的用法，即用它构成非子选择符，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> * <span class="selector-tag">a</span> &#123;<span class="attribute">font-size</span>:<span class="number">1.3em</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>如图 2-13 所示，任何是 section 孙子元素，而非子元素的a 标签都会被选中。至于a的父元素是什么，没有关系。</p>
<h4 id="ID和类选择符"><a href="#ID和类选择符" class="headerlink" title="ID和类选择符"></a>ID和类选择符</h4><p>ID和类为选择元素提供了另一套手段，利用他们可以不用考虑文档的层次结构。只要在HTML标记中为元素添加了id和class属性就可以在CSS选择符中使用ID和类名，直接玄宗文档中特定的区域。<br>*可以给id和class属性设定任何值，但不能以数字或特殊符号开头。<br>雷属性就是HTML元素的class属性，body标签中包含的任何HTML元素都可添加这个属性。<br>1.类选择符<br>.类名  .my-class<br>注意类选择符前面是（.），紧跟着类名，两者之间没有空格。<br>2.标签带类选择符<br>p.specialtext {color:red;}<br>p.specialtext span {font-weight:bold;}<br>其中specialtext是p的一个子元素的类名，而span位于带有specialtext类的段落里。<br>2.多类选择符</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"specialtext featured"</span>&gt;</span>Here the span tag <span class="tag">&lt;<span class="name">span</span>&gt;</span>may or may not<span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br><span class="line"> be styled.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 多个类名，如这里的 specialtext 和 featured，放在同一对引号里，用空格分隔。实际上，更准确的说法，就应该是 HTML 的 class 属性可以有多个空格分隔的值。要选择同时存在这两个类名的元素，可以这样写：<br> .specialtext.featured {font-size:120%;}<br> <strong>注意，CSS 选择符的两个类名之间没有空格，因为我们只想选择同时具有这两个类名的那个元素。如果你加了空格，那就变成了“祖先/后代”关系的上下文选择符了。</strong></p>
<h4 id="ID属性"><a href="#ID属性" class="headerlink" title="ID属性"></a>ID属性</h4><p> ID与类的写法相似，而且表示ID选择符的#的用法<br>如果有一个段落像下面这样设定了 ID 属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"specialtext"</span>&gt;</span>This is the special text.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么，相应的 ID 选择符就是这样的：<br>#specialtext {CSS 样式声明}<br>或者这样的：<br>p#specialtext {CSS 样式声明}<br>用于页内导航的 ID<br>ID 也可以用在页内导航链接中。下面就是一个链接，其目标是同一页的另一个位置。 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#bio"</span>&gt;</span>Biography<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>看到 href 属性值开头的#了吗？它表示这个链接的目标在当前页面中，因而不会触发浏览器加载页面（如果没有#，浏览器就会尝试加载 bio 目录下的默认页面了）。<br>使用与 CSS 选择符里相同的 #ID 名语法，可以把链接导航到同一页面中的目标 ID。在这个页<br>面的下方，应该有对应的目标元素。 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">"bio"</span>&gt;</span>Biography<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I was born when I was very young…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同样要注意，作为目标的 ID 值前面是没有#的，就是一个普通的 ID 值。<br>用户单击前面的链接时，页面会向下滚动到 ID 值为 bio 的 h3 元素的位置。如果链接的 href<br>属性里只有一个#，那么点击该链接会返回页面顶部。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Back to Top<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>换句话说，要写一个“返回顶部”链接，根本不需要 ID 为#的目标元素。<br>另外，如果你暂时不知道某个 href 应该放什么 URL，也可以用#作为占位符，但不能把该属性<br>留空。因为 href 属性值为空的链接的行为跟正常链接不一样。这样，团队中的其他人将来可<br>以用中间层（比如 PHP）变量替换#，以便动态接收来自数据库的 URL。</p>
<h4 id="什么时候用ID，什么时候用类"><a href="#什么时候用ID，什么时候用类" class="headerlink" title="什么时候用ID，什么时候用类"></a>什么时候用ID，什么时候用类</h4><p>ID 的用途是在页面中唯一地标识一个元素。正因为如此，同一个页面中的每一个 ID属性，都必须有独一无二的值（名字）。<br>类的目的是为了标识一组具有相同特征的元素。</p>
<h3 id="属性选择符"><a href="#属性选择符" class="headerlink" title="属性选择符"></a>属性选择符</h3><h4 id="属性名选择符"><a href="#属性名选择符" class="headerlink" title="属性名选择符"></a>属性名选择符</h4><p>标签名[属性名] 例如：img[title] {border:2px solid blue;}</p>
<h4 id="属性值选择符"><a href="#属性值选择符" class="headerlink" title="属性值选择符"></a>属性值选择符</h4><p>标签名[属性名=”属性值”]  例如：img[title=”red flower”] {border:4px solid green;}</p>
<h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>伪类这个叫法源自它们与类相似，但实际上没有类会附加到标记中的标签上。伪类分两种。<br>1.UI(User Interface, 用户界面)伪类会在HTML元素处于某个状态时（比如鼠标指针位于链接上），为该元素应用CSS样式。<br>2.结构化伪类会在标记中存在某种结构上的关系时（如某个元素是一组元素中的第一个或最后一个），为相应元素应用CSS样式。</p>
<h4 id="UI伪类"><a href="#UI伪类" class="headerlink" title="UI伪类"></a>UI伪类</h4><p>UI伪类会基于特定HTML元素的状态应用样式。最常使用UI伪类的元素是链接（a元素），利用UI伪类，链接可以在用户鼠标悬停时改变文本颜色，或者去掉文本的下划线。此外，还可以有其他响应方式，比如悬停时显示一个信息面板。<br>1.链接伪类<br>针对链接的伪类一共有 4 个，因为链接始终会处于如下 4 种状态之一。<br> Link。此时，链接就在那儿等着用户点击。<br> Visited。用户此前点击过这个链接。<br> Hover。鼠标指针正悬停在链接上。<br> Active。链接正在被点击（鼠标在元素上按下，还没有释放）。<br>以下就是这些状态对应的 4 个伪类选择符（使用了 a 选择符和一些示例声明）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:black;&#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>:gray;&#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">text-decoration</span>:none;&#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure>
<p>其中(:)表示伪类,一个冒号（:）表示伪类，两个冒号（::）表示 CSS3 新增的伪元素。<br>注意，有些伪类可以用于任何元素，而不仅仅是 a 元素。比如，下面这条规则能让段落背景在鼠标悬停时变成灰色：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">background-color</span>:gray;&#125;</span><br></pre></td></tr></table></figure>
<p>2.:focus 伪类<br>表单中的文本字段在用户单击它时会获得焦点，然后用户才能在其中输入字符。下面的规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid blue;&#125;</span><br></pre></td></tr></table></figure>
<p>会在光标位于 input 字段中时，为该字段添加一个蓝色边框。这样可以让用户明确地知道输入的字符会出现在哪里。<br>3.:target 伪类</p>
<p>如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标（target），可以用:target 伪类选中它。对于下面这个链接:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#more_info"</span>&gt;</span>More Information<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>位于页面其他地方、ID 为 more_info 的那个元素就是目标。该元素可能是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"more_info"</span>&gt;</span>This is the information you are looking for.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么，如下 CSS 规则</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#more_info</span><span class="selector-pseudo">:target</span> &#123;<span class="attribute">background</span>:<span class="number">#eee</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>会在用户单击链接转向 ID 为 more_info 的元素时，为该元素添加浅灰色背景。</p>
<h4 id="结构化伪类"><a href="#结构化伪类" class="headerlink" title="结构化伪类"></a>结构化伪类</h4><p>结构化伪类可以根据标记的结构应用样式，比如根据某元素的父元素或前面的同胞元素是什么。<br>1.:first-child 和:last-child<br>:first-child 代表一组同胞元素中的第一个元素，而:last-child 则代表最后一个。<br>2.:nth-child<br>e:nth-child(n)<br>e 表示元素名，n 表示一个数值（也可以使用 odd 或 even）。<br>例如，<br>li:nth-child(3)  会选择一组列表项中的每个第三项。<br>:nth-child 伪类最常用于提高表格的可读性，比如像第 6 章中那样，对表格的所有行交替应用不同颜色。</p>
<h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>顾名思义，伪元素就是你的文档中若有实无的元素。</p>
<ol>
<li>::first-letter 伪元素<br>p::first-letter {font-size:300%;}<br>可以得到段落首字符放大的效果。</li>
<li>::first-line 伪元素<br>e::first-line<br>可以选中文本段落（一般情况下是段落）的第一行。</li>
<li>::before 和::after 伪元素<br>以下两个伪元素<br>e::before<br>e::after<br>可用于在特定元素前面或后面添加特殊内容。<br>搜索引擎不会取得伪元素的信息（因为它在标记中并不存在）。因此，不要通过伪元素添加你想让搜索引擎索引的重要内容。</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>文档中的所有元素，无论它在层次结构中多么靠下，都将继承这些样式，以Helvetica 字体（或者在 Helvetica 字体无效时以其他字体代替）显示各自包含的文本。继承给我们带来的效率是显而易见的，全站的主字体只要在某个上层元素上指定即可，无须在每一个标签上分别指定。而对于个别想使用不同字体的元素，只要个别设定 font-family 属性就好了。<br>CSS 中有很多属性是可以继承的，其中相当一部分都跟文本有关，比如颜色、字体、字号。然而，也有很多 CSS 属性不能继承，因为继承这些属性没有意义。这些不能继承的属性主要涉及元素盒子的定位和显示方式，比如边框、外边距、内边距。</p>
<h3 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h3><p>层叠，就是层叠样式表中的层叠，是一种样式在文档层次中逐层叠加的过程，目的是让浏览器面对某个标签特定属性值的多个来源，确定最终使用哪个值。<br>层叠是 CSS 的核心机制，理解了它才能以最经济的方式写出最容易改动的 CSS，让文档外观在达到设计要求的同时，也给用户留下一些空间，让他们能根据需要更改文档的显示效果（比如整体调整字号）。</p>
<h4 id="样式来源"><a href="#样式来源" class="headerlink" title="样式来源"></a>样式来源</h4><p>样式有多处来源。首先，如果告诉你浏览器有一个默认的样式表，你应该不会感到奇怪，因为你还没有写一行 CSS 呢，每个标签已经带了一定的样式。h1 是不是粗体，字号还挺大？em 是不是斜体？列表呢，是不是缩进而且还带项目符号或编号？<br>然后，有一个用户样式表。没错，用户也可以提供样式表，尽管这样的用户不多见。这个选择对于视障用户很有用，他们可以通过用户样式表，强制浏览器加载的所有网站都以更大的字号，更容易分辨的颜色显示内容。比如，某个视障用户可以增加如下样式：<br>再有，就是作者样式表，也就是网页设计师（你）写的样式表。前面我们已经讲了作者给网页添加样式的三种方法：链接样式、嵌入样式和行内样式。</p>
<h4 id="层叠规则"><a href="#层叠规则" class="headerlink" title="层叠规则"></a>层叠规则</h4><p><strong>层叠规则一：找到应用给每个元素和属性的所有声明。</strong>浏览器在加载每个页面时，都会据此查到每一条 CSS 规则，标识出所有受到影响的 HTML 元素。<br><strong>层叠规则二：按照顺序和权重排序。</strong>浏览器依次检查 5 个来源，并设定匹配的属性。如果匹配的属性在下一个来源也有定义，则更新该属性的值，如此循环，直到检查完页面中所有标签受影响属性的全部 5 个来源为止。最终某个属性被设定成什么值，就用什么值来显示。声明也可以有权重。可以像下面这样为单独的声明增加权重：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:green <span class="meta">!important</span>; <span class="attribute">font-size</span>:<span class="number">12pt</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>空格!important 分号（;）用于加重声明的权重。<br><strong>层叠规则三：按特指度排序。</strong>除了有点拗口之外，特指度（specificity）其实表示一条规则有多明确。<br><strong>层叠规则四：顺序决定权重。</strong>如果两条规则都影响某元素的同一个属性，而且它们<br>的特指度也相同，则位置最靠下（或后声明）的规则胜出。</p>
<h4 id="计算特指度"><a href="#计算特指度" class="headerlink" title="计算特指度"></a>计算特指度</h4><p>下面我们具体讲一讲怎么计算选择符的特指度。首先，有一个简单的记分规则，即对每个选择符都要按下面的“ICE”公式计算三个值：<br>三个字母间的短横线是分隔符，并非减号。针对这个公式的计分办法如下：</p>
<ol>
<li>选择符中有一个 ID，就在 I 的位置上加 1；</li>
<li>选择符中有一个类，就在 C 的位置上加 1；</li>
<li>选择符中有一个元素（标签）名，就在 E 的位置上加 1；</li>
<li>得到一个三位数。<br>通过几个例子来理解特指度。<br>P 0-0-1 特指度=1<br>p.largetext 0-1-1 特指度=11<br>p#largetext 1-0-1 特指度=101<br>body p#largetext 1-0-2 特指度=102<br>body p#largetext ul.mylist 1-1-3 特指度=113<br>body p#largetext ul.mylist li 1-1-4 特指度=114<br>在此，每个选择符都比前一个选择符的特指度更高。</li>
</ol>
<p>简单层叠要点<br>在这个版本里，只要记住三条规则就够了。这三条规则适合所有情况。<br>规则一：包含 ID 的选择符胜过包含类的选择符，包含类的选择符胜过包含标签名的选择符。<br>规则二：如果几个不同来源都为同一个标签的同一个属性定义了样式，行内样式胜过嵌入样式，嵌入样式胜过链接样式。在链接的样式表中，具有相同特指度的样式，后声明的胜过先声明的。规则一胜过规则二。换句话说，如果选择符更明确（特指度更高），无论它在哪里，都会胜出。<br>规则三：设定的样式胜过继承的样式，此时不用考虑特指度（即显式设定优先）。下面简单<br>解释一下规则三。比如下面的标记</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"cascade_demo"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"inheritance_fact"</span>&gt;</span>Inheritance is <span class="tag">&lt;<span class="name">em</span>&gt;</span>weak<span class="tag">&lt;/<span class="name">em</span>&gt;</span> in the Cascade<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>和下面的规则<br>div#cascade_demo p#inheritance_fact {color:blue;}<br>2 - 0 - 2 （高特指度）<br>会导致单词“weak”变成蓝色，因为它从父元素 p 那里继承了这个颜色值。<br>但是，只要我们再给 em 添加一条规则<br>em {color:red;}<br>0 - 0 - 1 （低特指度）<br>em 就会变成红色。因为，虽然它的特指度低（0-0-1），但 em 继承的颜色值，会被为它明确（显式）指定的颜色值覆盖，就算（隐式）遗传该颜色值的规则的特指度高（2-0-2）也没有用。</p>
<h3 id="规则声明"><a href="#规则声明" class="headerlink" title="规则声明"></a>规则声明</h3><p>CSS 属性值主要分以下三类。<br><strong>文本值。</strong>例如，font-weight:bold 声明中的 bold 就一个文本值。文本值也叫做关键字。<br><strong>数字值。</strong>数字值后面都有一个单位，例如英寸或点。在声明 font-size:12px 中，12是数字值，而 px 是单位（像素）。如果数字值为 0，那么就不用带单位了。<br><strong>颜色值。</strong>颜色值可以用几种不同的格式来写，包括 RGB（Red, Green, Blue，红绿蓝）、<br>HSL（Hue, Saturation, Luminance，色相，饱和度，亮度）和十六进制值（例如color:#336699）。</p>
<h4 id="文本值"><a href="#文本值" class="headerlink" title="文本值"></a>文本值</h4><p>所有 CSS 属性都有文本值。例如，visibility 属性有 visible 和 hidden 值，border-style 属性有 solid、 dashed 以及 inset 值。</p>
<h4 id="数字值"><a href="#数字值" class="headerlink" title="数字值"></a>数字值</h4><p>数字值主要分两类：绝对值和相对值。<br>em 和 ex 都是字体大小的单位，但在 CSS 中，它们作为长度单位适用于任何元素。先说说 em ，它表示一种字体中字母 M 的宽度，因此它的具体大小取决于你使用的字体。而 ex 呢，等于给定字体中字母 x 的高度（小写字母 x 代表一种字体的字母中间部分的高度，不包括字母上、下突出的部分——如 d 和 p 上下都出头儿）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/CSS%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/CSS%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">CSS布局</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 10:04:36 / Modified: 11:30:28" itemprop="dateCreated datePublished" datetime="2020-04-26T10:04:36+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="布局的基本概念"><a href="#布局的基本概念" class="headerlink" title="布局的基本概念"></a>布局的基本概念</h2><p>多栏布局有三种基本的实现方案：固定宽度、流动、弹性。<br>固定宽度布局的大小不会随用户调整浏览器窗口大小而变化（不适用）。<br>流动布局的大小会随用户调整浏览器窗口大小而变化。这种布局能更好的适应屏幕变化。但同时也意味着放弃对页面某些方面的控制，比如随着页面宽度变化，文本行的长度和页面元素之间的位置关系可能变化。<br>弹性布局与流动布局类似，在浏览器窗口变宽时，不仅布局变宽，而且所有内容元素的大小也会变化，让人产生一种所有东西都变大了的感觉。（很难控制）</p>
<h3 id="布局高度和布局宽度"><a href="#布局高度和布局宽度" class="headerlink" title="布局高度和布局宽度"></a>布局高度和布局宽度</h3><p>布局高度和布局宽度两者的控制方法很不一样<br>1.布局高度<br>多数情况下，布局中结构化元素（乃至任何元素）的高度是不必设定的。只有这样元素才能随着自己包含内容的增加而在垂直方向上扩展。这样扩展的元素会把下面的元素向下推，而布局也能随着内容数量的增减而垂直伸缩。假如明确设定了元素的高度，那么超出的内容要么被剪掉，要么会跑到容器之外————取决于元素overflow属性的的设定。</p>
<p>2.布局宽度<br>与高度不同，我们需要更精细的控制布局宽度，以便随着浏览器窗口宽度的合理变化，布局能够做出适当的调整，确保文本行不会过长或过短。如果随意给元素添加内边距、边框，或者元素本身过大，导致浮动元素的宽度超过包含元素的布局宽度，那浮动元素就可能“躲到”其他元素下方。<br>即使必须设定栏宽，也不要给包含在其中的内容元素设定宽度，应该让这些内容元素自动扩展到填满栏的宽度。简言之，就是让栏宽限制其中内容元素的宽度。</p>
<h2 id="三栏-固定宽度布局"><a href="#三栏-固定宽度布局" class="headerlink" title="三栏-固定宽度布局"></a>三栏-固定宽度布局</h2><p>为保证每一栏的高度看起来是相同的，可以<br>圣杯布局和双飞翼布局<br>圣杯布局来源于文章In Search of the Holy Grail，而双飞翼布局来源于淘宝UED。虽然两者的实现方法略有差异，不过都遵循了以下要点：</p>
<p>两侧宽度固定，中间宽度自适应<br>中间部分在DOM结构上优先，以便先行渲染<br>允许三列中的任意一列成为最高列<br>只需要使用一个额外的<div>标签<br>圣杯布局</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>csslayout<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">            body &#123;</span><br><span class="line">                min-width: 550px;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-id">#container</span> &#123;</span></span><br><span class="line">                padding-left: 200px; </span><br><span class="line">                padding-right: 150px;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-id">#container</span> <span class="selector-class">.column</span> &#123;</span></span><br><span class="line">                float: left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-id">#center</span> &#123;</span></span><br><span class="line">                width: 100%;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-id">#left</span> &#123;</span></span><br><span class="line">                width: 200px; </span><br><span class="line">                margin-left: -100%;</span><br><span class="line">                position: relative;</span><br><span class="line">                right: 200px;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-id">#right</span> &#123;</span></span><br><span class="line">                width: 150px; </span><br><span class="line">                margin-right: -150px; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-id">#footer</span> &#123;</span></span><br><span class="line">                clear: both;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>双飞翼布局</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>another test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="selector-id">#container</span> &#123;</span></span><br><span class="line">		  width: 100%;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">		<span class="selector-class">.column</span> &#123;</span></span><br><span class="line">		  float: left;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">		<span class="selector-id">#center</span> &#123;</span></span><br><span class="line">		  margin-left: 200px;</span><br><span class="line">		  margin-right: 150px;</span><br><span class="line">		  background: yellow;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">		<span class="selector-id">#left</span> &#123;</span></span><br><span class="line">		  width: 200px; </span><br><span class="line">		  margin-left: -100%;</span><br><span class="line"><span class="css">		  <span class="selector-tag">margin-right</span><span class="selector-pseudo">:1px</span>;</span></span><br><span class="line">		  background: blue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">		<span class="selector-id">#right</span> &#123;</span></span><br><span class="line">		  width: 150px; </span><br><span class="line">		  background: green;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">		<span class="selector-id">#footer</span> &#123;</span></span><br><span class="line">		  clear: both;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="对于float-负外边距的理解"><a href="#对于float-负外边距的理解" class="headerlink" title="对于float+负外边距的理解"></a>对于float+负外边距的理解</h3><p>浮动的作用：<br>1.将里面的元素包裹（紧紧包裹）<br>2.将元素尽可能向上向左移动</p>
<p>当元素使用float: left时，当时用margin-left: -x时，若x&lt;元素宽度时，元素响应缩短x，当x&gt;元素宽度时，元素会向上一行移动，覆盖上一行的元素，移动距离为x；<br>当元素使用float: left时，当时用margin-right: -x时，若x&lt;元素宽度时，元素相应缩短x，当x&gt;元素宽度时，元素会向上一行移动，放到上一行的尾部。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/cookie%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/cookie%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">cookie</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 10:04:36 / Modified: 11:24:24" itemprop="dateCreated datePublished" datetime="2020-04-26T10:04:36+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为解决HTTP无状态导致的问题，出现了cookie。但Cookie的存在也不是为了解决通讯协议无状态的问题，只是为了解决客户端与服务端会话状态的问题，这个状态是指后端服务的状态而非通讯协议的状态。</p>
<h2 id="Cookie介绍"><a href="#Cookie介绍" class="headerlink" title="Cookie介绍"></a>Cookie介绍</h2><p>Cookie（复数形式为Cookies），类型为[小型文本文件]，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。<br>作为一段一般不超过4kb的小型文本数据，它有一个名称（Name），一个值（Value）和其他几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。</p>
<p>Cookie文件不仅可以保存在浏览器中还可以保存在存放在本地文件中，这样的好处是即使关闭了浏览器，Cookie依然可以生效。</p>
<h2 id="Cookie的保质期"><a href="#Cookie的保质期" class="headerlink" title="Cookie的保质期"></a>Cookie的保质期</h2><p>有永久的也有临时的，每个浏览器都含有自己的Cookie，每次请求的时候都会根据domain来发送相应的Cookie，可通过设置expries、max-age来设定保存日期，不设置的话默认是临时存储，即关闭浏览器就消失。</p>
<h2 id="满足同源策略"><a href="#满足同源策略" class="headerlink" title="满足同源策略"></a>满足同源策略</h2><p>虽然网站images.google.com和网站<a href="http://www.google.com同属Google，但是域名不一样，二者同样不能相互操作彼此的Cookie。而且path也必须一样才能相互访问彼此的Cookie。需要注意不同浏览器对path的访问规定不一样，对于chorme，path必须为当前目录，设置为其他目录无效，**只能当前页面访问当前目录及以上的cookie" target="_blank" rel="noopener">www.google.com同属Google，但是域名不一样，二者同样不能相互操作彼此的Cookie。而且path也必须一样才能相互访问彼此的Cookie。需要注意不同浏览器对path的访问规定不一样，对于chorme，path必须为当前目录，设置为其他目录无效，**只能当前页面访问当前目录及以上的cookie</a>**</p>
<h2 id="Cookie的设置"><a href="#Cookie的设置" class="headerlink" title="Cookie的设置"></a>Cookie的设置</h2><p>1.客户端发送HTTP请求到服务器<br>2.当服务器收到HTTP请求时，在响应头里添加一个Set-Cookie字段<br>3.浏览器收到响应后保存在Cookie<br>4.之后对该服务器每一次请求中都通过Cookie字段将Cookie信息发送给服务器。</p>
<h2 id="前端使用cookie操作cookie"><a href="#前端使用cookie操作cookie" class="headerlink" title="前端使用cookie操作cookie"></a>前端使用cookie操作cookie</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="built_in">document</span>.cookie=<span class="string">'name=xiaoming;expires='</span>+oDate</span><br></pre></td></tr></table></figure>

<h2 id="Cookies的属性"><a href="#Cookies的属性" class="headerlink" title="Cookies的属性"></a>Cookies的属性</h2><p>1.name字段：一个cookie的名称<br>2.value字段：一个cookie的值</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires用于设置Cookie时间。比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;</span><br></pre></td></tr></table></figure>
<p>当Expires属性缺省时，表示是绘画性Cookie，例如，当Expires属性的值为Session，表示的就是绘画性Cookie。党委绘画性Cookie的时候，值保存在客户端内存中，并在用户关闭浏览器时失效。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie也会被保留下来。<br>与会话性Cookie相对的是持久性Cookie，持久性Cookies会保存在用户的硬盘中，直至过期或者清除Cookie。值得注意的是，设定的日期和事件至于客户端相关，而不是服务端。</p>
<h3 id="max-age"><a href="#max-age" class="headerlink" title="max-age"></a>max-age</h3><p>max-age用于设置在Cookie失效之前需要经过的秒数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Max-Age=<span class="number">604800</span>;</span><br></pre></td></tr></table></figure>
<p>max-age可以为正数，负数，甚至是0<br>如果max-age属性为正数时，浏览器会将其持久化，即写到对应的Cookie文件中<br>当max-age属性为负数，则表示Cookie只是一个会话性Cookie<br>当max-age为0时，则会立即删除这个Cookie<br>假如max-age和expires都存在，max-age优先级更高</p>
<h3 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h3><p>domain指定了Cookie可以送达的主机名。假如没有指定，那么默认值为当前文档访问地址中的主机部分（但不包含子域名）<br>想淘宝首页设置的domain就是.taobao.com，这样无论是a.taobao.com还是b.taobao.com都可以使用Cookie<br>这里需要注意的是，不能跨域设置Cookie，比如阿里域名下的页面把domain设置成百度是无效的</p>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>path指定了一个URL路径，这个路径必须出现在要请求的资源的路径中才可以发送Cookie首部。<br>比如设置**Path=/docs，/docs/Web/下的资源才会带Cookie首部，/test则不会懈怠Cookie首部<br>domain和path标示共同定义了Cookie的作用域：即Cookie该发送给哪些URL</p>
<h3 id="Secure属性"><a href="#Secure属性" class="headerlink" title="Secure属性"></a>Secure属性</h3><p>标记为Secure的Cookie只应通过被HTTPs协议吉阿米果的请求发送给服务端。使用HTTPs安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程不被窃取和篡改。</p>
<h3 id="HTTPOnly"><a href="#HTTPOnly" class="headerlink" title="HTTPOnly"></a>HTTPOnly</h3><p>设置HTTPOnly属性可以防止客户端脚本通过document.cookie等方式访问Cookie，有助于避免XSS攻击。</p>
<h3 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h3><p>作用<br>SameSite属性可以让Cookie在跨站请求时不会被发送，从而可以组织跨站请求伪造攻击（CSRF）</p>
<p>属性值<br>SameSite可以有下面三种值<br>1.Strict：仅允许一方请求懈怠Cookie，即浏览器将只发送相同站点请求的Cookie，即当前网页URL与请求目标URL完全一致。<br>2.Lax：允许比分第三方请求懈怠Cookie<br>3.None： 无论是否跨站都会发送Cookie</p>
<p>之前默认是None的，Chorme80后默认是Lax</p>
<h3 id="跨域和跨站"><a href="#跨域和跨站" class="headerlink" title="跨域和跨站"></a>跨域和跨站</h3><p>首先要理解的一点就是跨站和跨域是不同的。同站（same-site）、跨站（cross-site）和第一方（first-party）、第三方（third-party）是等价的。但是与浏览器同源策略（SOP）中的同源（same-origin）、跨域（corss-origin）是完全不同的概念。</p>
<p>同源策略的同源是指两个URL的协议、主机名、端口一致。<br>同源策略作为浏览器的安全基石，其同源判断是比较严格的，相对而言，Cookie中的同站判断就比较宽松：只要两个URL的eTLD+1相同即可，不需要考虑协议和端口。其中，eTLD表示有效顶级域名，注册于Mozilla维护的公共后缀列表中。例如.come,.co.uk,.github.io等。eTLD+1则表示，有效顶级域名+二级域名。例如taobao.com等。</p>
<p>举几个例子，<a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a> 和 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 是跨站，<a href="http://www.a.taobao.com" target="_blank" rel="noopener">www.a.taobao.com</a> 和 <a href="http://www.b.taobao.com" target="_blank" rel="noopener">www.b.taobao.com</a> 是同站，a.github.io 和 b.github.io 是跨站(注意是跨站)。</p>
<h3 id="由此带来的改变"><a href="#由此带来的改变" class="headerlink" title="由此带来的改变"></a>由此带来的改变</h3><p><strong>此处有图</strong><br>从上图可以看出，对大部分 web 应用而言，Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站会发送三方 Cookie，变成了不发送。<br>Post表单：应该的，学 CSRF 总会举表单的例子。<br>iframe：iframe 嵌入的 web 应用有很多是跨站的，都会受到影响。<br>AJAX：可能会影响部分前端取值的行为和结果。<br>Image：图片一般放 CDN，大部分情况不需要 Cookie，故影响有限。但如果引用了需要鉴权的图片，可能会受到影响。<br>除了这些还有 script 的方式，这种方式也不会发送 Cookie，像淘宝的大部分请求都是 jsonp，如果涉及到跨站也有可能会被影响。</p>
<h2 id="带来问题"><a href="#带来问题" class="headerlink" title="带来问题"></a>带来问题</h2><p>我们再看看会出现什么的问题？举几个例子：</p>
<p>天猫和飞猪的页面靠请求淘宝域名下的接口获取登录信息，由于 Cookie 丢失，用户无法登录，页面还会误判断成是由于用户开启了浏览器的“禁止第三方 Cookie”功能导致而给与错误的提示</p>
<p>淘宝部分页面内嵌支付宝确认付款和确认收货页面、天猫内嵌淘宝的登录页面等，由于 Cookie 失效，付款、登录等操作都会失败</p>
<p>阿里妈妈在各大网站比如今日头条，网易，微博等投放的广告，也是用 iframe 嵌入的，没有了 Cookie，就不能准确的进行推荐</p>
<p>一些埋点系统会把用户 id 信息埋到 Cookie 中，用于日志上报，这种系统一般走的都是单独的域名，与业务域名分开，所以也会受到影响。</p>
<p>一些用于防止恶意请求的系统，对判断为恶意请求的访问会弹出验证码让用户进行安全验证，通过安全验证后会在请求所在域种一个Cookie，请求中带上这个Cookie之后，短时间内不再弹安全验证码。在Chrome80以上如果因为Samesite的原因请求没办法带上这个Cookie，则会出现一直弹出验证码进行安全验证。</p>
<p>天猫商家后台请求了跨域的接口，因为没有 Cookie，接口不会返回数据</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方案就是设置 SameSite 为 none。<br>不过也会有两点要注意的地方：</p>
<p>1.HTTP 接口不支持 SameSite=none<br>如果你想加 SameSite=none 属性，那么该 Cookie 就必须同时加上 Secure 属性，表示只有在 HTTPS 协议下该 Cookie 才会被发送。</p>
<p>2.需要 UA 检测，部分浏览器不能加 SameSite=none<br>IOS 12 的 Safari 以及老版本的一些 Chrome 会把 SameSite=none 识别成 SameSite=Strict，所以服务端必须在下发 Set-Cookie 响应头时进行 User-Agent 检测，对这些浏览器不下发 SameSite=none 属性</p>
<h2 id="新的解决方式"><a href="#新的解决方式" class="headerlink" title="新的解决方式"></a>新的解决方式</h2><h3 id="cookie存在问题"><a href="#cookie存在问题" class="headerlink" title="cookie存在问题"></a>cookie存在问题</h3><p>1.网络请求耗费资源<br>2.安全性</p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>session是服务端存储用户信息，当用户登录后返回sessionId，客户端将sessionID存储在cookie中，客户端在请求时携带sessionID，服务端通过sessionId以及相关映射关系获取用户登录状态。</p>
<p>解决了传递cookie的资源浪费问题，但仍存在安全性的问题。同时服务端需要存储用户状态，增大服务端压力。</p>
<h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>token在session的基础上，解决了服务端存储的问题，同时防止 CSRF攻击。<br>token和sessionId类似不过由用户名和一个服务端提供的数字签名组成。用户成功登陆后，服务端返回token，token可以存在cookie或localstorage等中。token不是随请求自动发送，需要在请求头中添加，即使token放在cookie中，但服务端不是通过cookie中的token进行验证，而是通过请求头中的token进行验证，由此防止了 CSRF攻击。同时token是无状态的，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/BOM%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/BOM%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">BOM相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 10:04:36 / Modified: 11:24:20" itemprop="dateCreated datePublished" datetime="2020-04-26T10:04:36+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>BOM的核心对象时windwo，它表示浏览器的一个实例。<strong>在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。</strong>这意味着在网页中定义的任何一个对象、变量和函数，都是以window作为其Global对象，因此有权访问parseInt()等方法。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>由于window对象同时扮演者ECMAScript中Global对象的角色，因此所有在全局作用域中声明的变量、函数都会变成window的属性和方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">window</span>.age)  <span class="comment">//29</span></span><br><span class="line">sayAge()  <span class="comment">//29</span></span><br><span class="line"><span class="built_in">window</span>.sayAge()  <span class="comment">//29</span></span><br></pre></td></tr></table></figure>

<p>抛开全局变量会成为window对象的属性不谈，定义全局变量与在window对象上直接定义属性还是有一点差别：全局变量不能通过delete操作符删除，而直接定义在window对象上的属性可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span></span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.age</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.color</span><br><span class="line">alert(<span class="built_in">window</span>.age)   <span class="comment">//29</span></span><br><span class="line">alert(<span class="built_in">window</span>.color)   <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>定义的全局变量再添加到window时[[Configurable]]被设置为false，因此这样定义的属性不可以通过delete操作符删除。</p>
<p>尝试访问未声明的变量会抛出错误，但通过查询window对象，可以知道某个可能未声明的变量是否存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newValue = oldValue</span><br><span class="line"><span class="comment">// 报错，因为oldValue未定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newValue = <span class="built_in">window</span>.oldValue</span><br><span class="line"><span class="comment">// 不会报错，值为undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h3><p>如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对象。每个window对象都有一个name属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">row</span>=<span class="string">"160, *"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame.htm"</span> <span class="attr">name</span>=<span class="string">"topFrame"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%, 50%"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"anotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"leftFrame"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"yetanotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"rightFrame"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个框架集，可以利用如下代码引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.frames[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">window</span>.frames.topFrame</span><br><span class="line">top.frames[<span class="number">0</span>]</span><br><span class="line">top.frames.topFrame</span><br><span class="line">frames[<span class="number">0</span>]</span><br><span class="line">frames.topFrame</span><br></pre></td></tr></table></figure>
<p>其中top对象始终指向最高层，也就是浏览器窗口。与top相对的另一个window对象时parent。parent始终指向当前框架的直接上层框架。<br>除非最高层窗口是通过window.open()打开的，否则其window对象的那么属性不会包含任何值。<br>与框架有关的最后一个对象时self，它始终指向window。<br>所有这些对象都是window对象的属性，可以通过window.parent、window.top等形式来访问。同时也以为这可以将不同层次的window对象连缀起来，例如window.parent.parent.frames[0].</p>
<p><strong>注意</strong><br>在使用框架的情况下，浏览器中会存在多个Global对象，每个框架中定义的全局变量会自动成为框架中window对象的属性。由于每个window对象都包含原生类型的构造函数，因此每个框架都有一台自己的构造函数，这些构造函数一一对应，但并不相等。例如，top.Object并不等于top.frames[0].Object。这个问题影响到对跨框架传递的对象使用instanceof操作符。</p>
<h3 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h3><h3 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h3><p>使用window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个方法可以接收4个参数：要加载的URL，窗口目标，一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。**通常只需传递一个参数，最后一个参数只在不打开新窗口的情况下使用。<br>如果window.open()传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>,<span class="string">"topFrame"</span>)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&lt;a href=<span class="string">"http://www.wrox.com"</span> target=<span class="string">"topFrame"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>调用这行代码，就如同用户单击了href属性为<a href="http://www.word.com/" target="_blank" rel="noopener">http://www.word.com/</a>, target属性为topFrame的链接。如果有一个名叫topFrame的窗口或者框架，就会在该窗口或框架加载这个URL；否则就会创建一个新的窗口并将其命名为topFrame。此外，第二个参数也可以是下列任何一个特殊的窗口名称。**_self, _parent, _top, _blank.</p>
<p>window.open()方法会返回一个纸箱新窗口的引用。引用的对象与其他window对象大致相似，但可以对其进行更多控制。</p>
<h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>location提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。事实上，location对象时一个很特别的对象，因为它既是window对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。以下为location的属性</p>
<p>1.hash  “#contents”   返回URL中的hash（#号后跟零个或多个字符），如果URL中不包含散列，则返回空字符串。<br>2.host  “<a href="http://www.wrox.com:80&quot;">www.wrox.com:80&quot;</a>   返回服务器名称含端口号（如果有）<br>3.hostname  “<a href="http://www.wrox.com&quot;" target="_blank" rel="noopener">www.wrox.com&quot;</a>  返回不带端口号的服务器名称<br>4.href   “http:/<a href="http://www.wrox.com&quot;" target="_blank" rel="noopener">www.wrox.com&quot;</a>  返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值<br>5.pathname   “/wileyCDA”  返回URL中的目录和（或）文件名<br>6.port   “8080”  返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串。<br>7.protocol  “http:”  返回页面使用的协议。通常是http:或https:<br>8.search   “?q=javascript”   返回URL的查询字符串。这个字符串以问号开头</p>
<h3 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h3><p>似然通过属性search可以得到从问号到URL末尾的所有内容，但无法逐个访问。由此可以建立一个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAueryStringArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = (location.seratch.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>): <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">var</span> args = &#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : []</span><br><span class="line">    <span class="keyword">var</span> item = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> value = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> len = item.length</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        item = items[i].split(<span class="string">'='</span>)</span><br><span class="line">        name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>])</span><br><span class="line">        value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span>(name.length) &#123;</span><br><span class="line">            args[name] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><p>使用location对象可通过很多方式来改变浏览器的位置。首先，最常用的就是使用assign()方法并为其传递一个URL，如下所示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.assign(<span class="string">'http://www.worx.com'</span>)</span><br></pre></td></tr></table></figure>
<p>这样就可以立即打开新URL并在浏览器的历史记录中生成一条记录。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location = <span class="string">"http://www.worx.com"</span></span><br><span class="line">location.href = <span class="string">"http://www.worx.com"</span></span><br></pre></td></tr></table></figure>
<p>以上方式和显式调用assing方法效果一样（因为会调用assing()方法）。<br>通过修改location的其他属性也能改变当前加载的页面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设初始URL为http://www.worx.com/wikeyCDA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将URL修改为"http://www.worx.com/WileyCDA/#section1"</span></span><br><span class="line">location.hash = <span class="string">"#section1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将URL修改为"http://www.worx.com/WileyCDA/?q=javascript"</span></span><br><span class="line">location.search = <span class="string">"?q=javascript"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将URL修改为"http://www.yahoo.com/WileyCDA/"</span></span><br><span class="line">location.hostname = <span class="string">"www.yahoo.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将URL修改为"http://www.yahoo.com/mydir/"</span></span><br><span class="line">location.pathname = <span class="string">"mydir"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将URL修改为"http://www.worx.com:8080/WileyCDA/"</span></span><br><span class="line">location.port = <span class="string">"8080"</span></span><br></pre></td></tr></table></figure>
<p>每次修改location的属性（hash除外），页面都会以新URL重新加载。<br>当通过上述任何一种方式修改URL之后，浏览器的历史记录中就会生成一条新纪录，因此用户通过单击后退俺就都会导航到前一个页面。<br>要禁用这种行为，可以使用replace()方法。这个方法只接受一个参数，纪要导航到的URL；结果虽然会导致浏览器位置变化，但不会在历史记录中生成新纪录。再调用replace()方法之后，用户不能回到前一个页面。</p>
<p>另一个与位置有关的方法是reload(),作用是重新加载当前显示的页面。如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。<strong>就是说如果页面自上次请求依赖没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要传递参数true。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location.reload()       <span class="comment">//重新加载（有可能从缓存中加载）</span></span><br><span class="line">location.reload(<span class="literal">true</span>)    <span class="comment">//重新加载（从服务器重新加载）</span></span><br></pre></td></tr></table></figure>
<p>位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。</p>
<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>history对象保存着用户上网的历史记录，从窗口被打开的哪一个算起。因为history是window对象的属性，<strong>因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联</strong>。出于安全方面考虑，开发人员无法得知用户浏览过的URL。不过，皆有用户访问过的页面列表，同样可以在不知道实际URL的情况下实现后退和前进。<br>使用go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接收一个参数，表示向后或向前跳转页面数的一个整数值。负的表示向后跳转（类似于单击浏览器的后退），正数表示向前跳转（类似于单击浏览器的前进按钮）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.go(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">history.go(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">history.go(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置（可能前进也可能后退，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么什么也不做。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="string">'worx.com'</span>)</span><br></pre></td></tr></table></figure>
<p>另外还可以使用两个简写方法back()（向后）和forward()（向前）来代替go()。</p>
<p>除了以上几个方法外，history对象还有一个length属性，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length等于0。通过如下测试该属性，可以确定用户是否一开始就打开了你的页面</p>
<p>```js<br>if (history.length == 0) {<br>    // 是第一个打开的<br>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/AMD%E3%80%81CMD%E3%80%81Commonjs%E5%92%8CES6%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/AMD%E3%80%81CMD%E3%80%81Commonjs%E5%92%8CES6%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">AMD、CMD、CommonJs和ES6对比</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 10:04:36 / Modified: 11:24:23" itemprop="dateCreated datePublished" datetime="2020-04-26T10:04:36+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以上都是用于在模块化定义中使用的，AMD、CMD、CommonJs是ES中提供的模块化编程的方案，import/export是ES6中新增的。</p>
<h2 id="CommonJS-同步"><a href="#CommonJS-同步" class="headerlink" title="CommonJS(同步)"></a>CommonJS(同步)</h2><p>Nodejs模块系统就采用CommonJS模式。CommonJS标准规定，一个单独的文件就是一个模块，模块内将需要对外暴露的变量放到export对象里，可以是任意对象，函数，数组等，潍坊到exports对象里的都是私有的。用require方法加载模块，即读取模块文件获得exports对象。<br>CommonJS编程示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义hi.js：</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'Hi'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(str + <span class="string">', '</span> + name + <span class="string">'!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = sayHi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载</span></span><br><span class="line"><span class="keyword">var</span> Hi = <span class="built_in">require</span>(<span class="string">'./hi'</span>);</span><br><span class="line">Hi(<span class="string">'Jack'</span>);     <span class="comment">// Hi, Jack!</span></span><br></pre></td></tr></table></figure>
<h3 id="Nodejs中module-exports和exports区别"><a href="#Nodejs中module-exports和exports区别" class="headerlink" title="Nodejs中module.exports和exports区别"></a>Nodejs中module.exports和exports区别</h3><p>module和exports是Node.js给每个js文件内置的两个对象。实际上，这两个对象指向同一块内存。require引入的对象本质上是module.exports。当 module.exports和exports指向的不是同一块内存时，exports的内容就会失效。<br>例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">name</span>: <span class="string">'萤火虫叔叔'</span>&#125;；</span><br><span class="line">exports = &#123;<span class="attr">name</span>: <span class="string">'萤火虫老阿姨'</span>&#125;  <span class="comment">//更改了exports指向</span></span><br></pre></td></tr></table></figure>

<h2 id="AMD-异步模块定义"><a href="#AMD-异步模块定义" class="headerlink" title="AMD-异步模块定义"></a>AMD-异步模块定义</h2><p>AMD（Asynchronous Module Definition)，是RequireJS推广过程中对模块定义的规范化准则，它是一个概念，RequireJS是对这个概念的实现，就好比JavaScript语言是对ECMAScript规范的实现。AMD是一个组织，RequireJS是在这个组织下定义的一套脚本语言。</p>
<p>AMD采用异步方式加载模块，模块的加载不影响它后面的语句运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会执行。<br>AMD使用define定义模块，AMD可以采用require()语句加载模块，但是不同于CommonJs，它要求两个参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="built_in">module</span>],fn)</span><br><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback)</span><br></pre></td></tr></table></figure>
<p>define第一个参数[module]是该模块的依赖，第二个参数fn返回一个可以引用的模块对象。require第一个参数[module]，是一个数组，里面的成员就是要加载的模块，第二个参数callback则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义test.js模块</span></span><br><span class="line">define([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> addHello = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(math.add(x,y)).fill(<span class="string">'hello'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        addHello: addHello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'test'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">    alert(test.addHello)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>math.add()与math模块加载不是同步的。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD是SeaJS在推广过程中对模块定义的规范化产出，是一个同步模块定义，是SeaJS的一个标准，SeaJS是CMD概念的一个实现，SeaJS是淘宝团队提供的一个模块开发的js框架。</p>
<p>通过define()定义，没有依赖前置，通过require加载jQuery插件，CMD是依赖就近，在什么地方使用到插件就在什么地方require该插件，即用即返。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确写法</span></span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span>,</span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>SeaJS只会在真正需要使用(依赖)模块时才执行该模块<br>SeaJS是异步加载模块的没错, 但执行模块的顺序也是严格按照模块在代码中出现(require)的顺序,而RequireJS会先尽早地执行(依赖)模块, 相当于所有的require都被提前了, 而且模块执行的顺序也不一定100%就是先mod1再mod2</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/04/26/Ajax%E4%B8%8EComet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/04/26/Ajax%E4%B8%8EComet/" class="post-title-link" itemprop="url">Ajax与Comet</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-26 10:04:36 / Modified: 11:24:22" itemprop="dateCreated datePublished" datetime="2020-04-26T10:04:36+08:00">2020-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Ajax是一种能够向服务器请求额外的数据而无需卸载页面。为Asynchornous.JavaScript + XML的简写。<br>Ajax的技术核心是XMLHttpRequest对象（简称XHR）。在XHR出现之前，Ajax式的通信必须借助一些hack手段来实现，大多数是使用隐藏的框架或内嵌框架。XHR为向服务器发送请求和解析服务器响应提供了流畅的接口。能够以异步方式从服务器取得更多信息，意味着用户单击后，可以不必刷新页面也能取得新数据。也就是说，可以使用XHR对象取得新数据，然后在通过DOM将新数据插入到页面中。另外，虽然名字中包含XML的成分，但Ajax通信与数据格式无关；这种技术就是无需刷新页面即可从服务崎岖的数据，但不一定是XML数据。</p>
<h2 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h2><h3 id="XHR的用法"><a href="#XHR的用法" class="headerlink" title="XHR的用法"></a>XHR的用法</h3><p>在使用XHR对象时，要调用的第一个方法是open(),它接受三个参数：要发送的请求的类型（’get‘，‘post’等），请求的URL和是否异步发送请求的布尔值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHTTPRequest()</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.php'</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>这行代码会启动一个针对example.php的get请求。有关这行代码，需要说明两点： 一是URL相对于执行大妈的当前页面（当然也可以使用绝对路径）；二是调用open()方法并不会真正发送请求，而只是起送一个请求以备发送。<br>要发送特定的请求，必须像如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.txt'</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>这里send()方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送的数据，则必须传入null，因为这个参数对于有些浏览器来说是必须的。调用send()之后，请求就会被分派到服务器。由于这次请求时同步的，javaScript代码会等到服务器响应之后再继续执行。在收到响应后，响应的数据会自动填充XHR对象的属性，相关的属性简介如下：</p>
<p>responseText：作为响应主体被返回的文本<br>responseXML：如果响应的内容是’text/xml‘或“application/xml”，这个属性中将保存包含着响应数据的XML DOM文档<br>status： 形影的HTTP状态<br>statusText： HTTP状态的说明<br>在接收到响应后，第一步是检查status属性，以确定响应已经成功返回。一般来说，可以将HTTP状态代码为200作为成功的标志。此时，responseText属性的内容已经就绪，而且在内容类型正确的情况下，responseXML也应该能够访问了。此外，状态代码为304表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本；当人也意味着响应时有效的。</p>
<p>像前面这样发送同步请求相对较少，大多数情况下，需要发送异步请求。此时，可以检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下。<br>0：未初始化。尚未调用open方法<br>1：启动。已经调用open()方法，但尚未调用send()方法<br>2：发送。已经调用send()方法，但尚未接收到响应<br>3：接收。已经接收到部分相应数据。<br>4：完成。已经接收到全部响应数据，而且已经可以在客户端使用。<br>只要readyState属性的值由一个值编程另一个值，都会触发一次readystatechange事件。可以利用这个事件来检测每次状态变化后readyState的值。通常，我们只对readyState值为4的阶段感兴趣。此时所有数据都已经就绪。不过，必须调用open()之前指定onreadystaechange事件处理程序才能确保跨浏览器兼容性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR()</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">'response was unsuccessful: '</span> + xhr.status)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.txt'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>以上代码利用DOM0级方法为XHR对象添加了事件处理程序，原因是并非所有的浏览器都支持DOM2级方法。与其他事件处理程序不同，这里没有像onreadystatechange事件处理程序中传递event对象，必须通过XHR对象本身来确定下一步该怎么做。<br>另外，在接受到响应之前还可以调用abort()方法来取消异步请求，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.abort()</span><br></pre></td></tr></table></figure>
<p>调用这个方法后，XHR对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。在终止请求之后，还应该对XHR对象进行解引用操作。由于内存原因，不建议重用XHR对象。</p>
<h3 id="HTTP头部信息"><a href="#HTTP头部信息" class="headerlink" title="HTTP头部信息"></a>HTTP头部信息</h3><p>每个HTTP请求和响应都会带有响应的头部信息，XHR对象也提供了操作这两种头图（即请求头和响应头）信息的方法<br>默认情况下，在发送XHR请求的同时，还会发送下列头部信息<br>Accept：浏览器能够处理的内容类型<br>Accept-Charset：浏览器能够显示地字符集<br>Accept-Encoding：浏览器嫩狗处理的压缩编码。<br>Accept-language：浏览器当前设置的语言。<br>Connection： 浏览器与服务器之间链接的类型。<br>Cookie：当前页面设置的任何Coolie<br>Host：发出请求的页面所在的域。<br>Referer：发出请求的页面的URI。<br>User-Agent：浏览器的用户代理字符串。<br>虽然不同浏览器实际发送的头部信息会有所不同，但以上列出的基本上是所有浏览器都会发送的。使用seRequestHeader()方法可以设置自定义的请求头部信息。这个方法接受两个参数：头部字段的名称和头部字段的值。要成功发送请求头部信息，必须再调用open方法之后且调用send方法之前调用setRequestHeader</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">'response was unsuccessful: '</span> + xhr.status)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.php'</span>,<span class="literal">true</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">'MyHeader'</span>, <span class="string">'MyValue'</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>部分浏览器不支持重写默认的头部信息。<br>调用XHR对象的getResponseHeader()方法并传入头部字段名称，可以取得相应的响应头部信息。而调用getAllReponseHeader()方法则可以取得一个包含所有头部信息的长字符串。</p>
<h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><p>get常用语向服务器查询某些信息。必要时，可以将查询字符串参数追加到URL末尾，以便将信息发送给服务器。对XHR而言，<strong>位于传入open()方法的URL末尾的查询字符串必须经过正确的编码才行。</strong><br>使用GET请求经常会发生一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码，然后才能放到URL的末尾；而且所有名值对都必须由（&amp;）号分隔，如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.php?name1=value1&amp;name2=value2'</span>,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>下面这个函数可以辅助向现有URL的末尾添加查询字符串参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addURLParam</span>(<span class="params">url, name, value</span>) </span>&#123;</span><br><span class="line">    url += (url.indexof(<span class="string">'?'</span>) == <span class="number">-1</span> ? <span class="string">'?'</span>: <span class="string">'&amp;'</span>)</span><br><span class="line">    url += <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>POST通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主体提交。POST请求的主体可以包含非常多的数据，而且格式不限。在open()方法第一个参数的位置传入’post‘，就可以初始化一个POST请求<br>发送POST请求的第二步就是想send()方法中传入某些数据。由于XHR最初的设计主要是为了处理XML，因此可以在此传入XML DOM文档，传入的文档经序列话之后将作为请求主体被提交到服务器。<strong>也可以在此传入任何想发送到服务器的字符串。</strong><br>默认情况下，服务器对POST请求和提交Web表单的请求并不会一视同仁。因此服务器端必须有程序来读取发送过来的原始数据，并从中解析出有用的部分。不过，我们可以使用XHR来模仿表单提交：<br>首先将Content-Type头部信息设置为application/x-www-form-urlencoded,就是表单提交时的内容类型，其次是以适当的格式创建一个字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialize()函数为表单序列化函数</span></span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">'response was unsuccessful: '</span> + xhr.status)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'postexample.php'</span>,<span class="literal">true</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>)</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'user-info'</span>)</span><br><span class="line">xhr.send(serialize(form))</span><br></pre></td></tr></table></figure>
<p>这个函数可以将ID为’user-info’的表单中的数据序列化之后发送给服务器。而下面的示例PHP文件postexample.php就可以通过$_POST取得提交的数据了。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">'Content-Type: text/plain'</span>)&gt;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">Name: <span class="subst">&#123;$_POST['user-name']&#125;</span></span></span><br><span class="line"><span class="string">Email: <span class="subst">&#123;$_POST['user-email']&#125;</span></span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不设置Content-Type头部信息，那么发送给服务器的数据就不会出现在$_POST超级全局变量中。这时候，要访问同样的数据，就必须借助$HTTP_RAW_POST_DATA.</p>
<h2 id="XMLHttpRequest-2级"><a href="#XMLHttpRequest-2级" class="headerlink" title="XMLHttpRequest 2级"></a>XMLHttpRequest 2级</h2><p>XMLHttpRequest 2级并非所有浏览器都完整实现了。</p>
<h3 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h3><p>XMLHttpRequest 2级定义了FormData类型。FormData为序列化表单以及创建表单格式相同的数据（用于通过XHR传输）提供了便利。下面的代码创建了一个FormData对象，并向其中添加了一些数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData()</span><br><span class="line">data.append(<span class="string">'name'</span>, <span class="string">'Nicholas'</span>)</span><br></pre></td></tr></table></figure>
<p>这个append()方法接收两个参数：键和值，分别对应表单字段的名字和字段中包含的值。可以像这样添加任意多个键值对。而通过向FormData构造函数中传入表单元素，也可以用表单元素的数据预先向其中键入键值对。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.form[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>创建了FormData实例后，可以将它直接传给XHR的send方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR()</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">'response was unsuccessful: '</span> + xhr.status)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'postexample.php'</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'user-info'</span>);</span><br><span class="line">xhr.send(<span class="keyword">new</span> FormData(form))</span><br></pre></td></tr></table></figure>
<p>使用FormData的方便之处在于<strong>不必明确地在XHR对象上设置请求头部。</strong>XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息。</p>
<h3 id="超时设定"><a href="#超时设定" class="headerlink" title="超时设定"></a>超时设定</h3><p>IE8位XHR对象添加了一个timeout属性，表示请求在等待响应多少毫秒之后就终止。在给timeout设置衣蛾数值后，如果在规定的事件内浏览器还没有接收到响应，那么就会触发timeout事件，进而会调用ontimeout事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(<span class="string">'response was unsuccessful: '</span> + xhr.status)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">            <span class="comment">// 假设由ontimeout事件处理程序处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'timeout.php'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.timeout = <span class="number">1000</span>;</span><br><span class="line">xhr.ontomeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Request did not return in a second'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>请求终止时，会调用ontimeout事件处理程序。但此时readyState可能已经变为4了，这意味着会调用onreadystateChange事件处理程序。因此需要封装在try-catch语句中。</p>
<h3 id="overrideMineType-方法"><a href="#overrideMineType-方法" class="headerlink" title="overrideMineType()方法"></a>overrideMineType()方法</h3><p>该方法用于重写XHR响应的MIME类型。这个方法后来也被纳入XMLHttpRequest 2级规范。因为返回响应的MIME类型决定了XHR对象如何处理它，所以提供一种方法能够重写服务器返回的MIME类型是很有用的。<br>比如服务器返回的MIME类型是text/plain,但数据中实际包含的是XML。根据MIME类型，即使数据是XML，responseXML属性中仍然是null。通过overrideMimeType()方法，可以保证把响应当做XML而非纯文本来处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR()</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'text.php'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.overrideMimeType(<span class="string">'text/xml'</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>这个例子强迫XHR对象将响应当做XML而非纯文本来处理。调用overrideMimeType()必须在send()方法之前，才能保证重写响应的MIME类型。</p>
<h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><p>Progress Events规范是W3C的一个工作草案，定义了与客户端服务器通信的有关事件。有以下6个进度事件。<br>loasstart: 在接收响应数据的第一个字节时触发。<br>progress： 在接收响应期间持续不断地触发。<br>error: 在青丘发生错误时触发。<br>load： 在接收到完整的响应数据时触发。<br>loadend：在通信完成或者触发error、abort或load事件后触发。<br>每个请求都从触发loadstart事件开始，接下来是一或多个progress事件，然后触发error、abort或load事件中的一个，最后触发loadend事件结束。</p>
<h3 id="load事件"><a href="#load事件" class="headerlink" title="load事件"></a>load事件</h3><p>引入load事件，用以替代readystatechange事件。响应接收完毕后将触发load事件，因此也就没有必要去检查readyState属性了。而onload事件处理程序会接收到一个event对象，其target属性就只想XHR对象实例。因此可以访问到XHR对象的所有方法和属性。然而，并非所有浏览器都为这个事件实现了适当的事件对象。因此还需要引用XHR对象变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR()</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">        alert(xhr.responseText)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'resquest was unsuccessful: '</span> + xhr.status)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'get'</span> <span class="string">'altevents.php'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>只要浏览器接收到服务器的响应，不管其状态如何，都会触发load事件。这意味着必须检查status属性。</p>
<h3 id="progress事件"><a href="#progress事件" class="headerlink" title="progress事件"></a>progress事件</h3><p>这个事件会在浏览器接收新数据期间周期性的触发。而onporgress事件处理程序会接收到一个event对象，qitarget属性是XHR对象，但包含三个额外的属性：lengthComputable、position和totalSize。其中，lengthComputable时表示进度信息是否可用的布尔值，position表示已经接收的字节数，totalSize表示根据Content-Length响应头部确定的预期字节数。有了这些信息，就可以为用户创建一个进度指示器了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR()</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">        alert(xhr.responseText)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'resquest was unsuccessful: '</span> + xhr.status)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> divStatus = <span class="built_in">document</span>.getElementById(<span class="string">'status'</span>)</span><br><span class="line">    <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">        divStatus.innerHTML = <span class="string">'Received'</span> + event.position + <span class="string">'of'</span> + event.totalSize + <span class="string">'bytes'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'altevents.php'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>为确保正常执行，必须在调用open()方法之前添加onprogress事件处理程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/Blog/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/Blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/Blog/page/3/">3</a><a class="extend next" rel="next" href="/Blog/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">蚂蚁</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Blog/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蚂蚁</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Blog/lib/anime.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/Blog/js/utils.js"></script>

<script src="/Blog/js/motion.js"></script>


<script src="/Blog/js/schemes/pisces.js"></script>


<script src="/Blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
