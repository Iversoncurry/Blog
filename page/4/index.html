<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/Iversoncurry.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Iversoncurry.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Iversoncurry.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Iversoncurry.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Iversoncurry.github.io/css/main.css">


<link rel="stylesheet" href="/Iversoncurry.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/Iversoncurry.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="蚂蚁的博客">
<meta property="og:url" content="https://github.com/Iversoncurry/Iversoncurry.github.io.git/page/4/index.html">
<meta property="og:site_name" content="蚂蚁的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="蚂蚁">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/Iversoncurry/Iversoncurry.github.io.git/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>蚂蚁的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Iversoncurry.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">蚂蚁的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/Iversoncurry.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Iversoncurry.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Iversoncurry/Iversoncurry.github.io.git/2020/01/08/BOM%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Iversoncurry.github.io/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Iversoncurry.github.io/2020/01/08/BOM%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">BOM相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-08 20:27:08" itemprop="dateCreated datePublished" datetime="2020-01-08T20:27:08+08:00">2020-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:25:12" itemprop="dateModified" datetime="2020-05-31T10:25:12+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>BOM的核心对象时windwo，它表示浏览器的一个实例。<strong>在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。</strong>这意味着在网页中定义的任何一个对象、变量和函数，都是以window作为其Global对象，因此有权访问parseInt()等方法。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>由于window对象同时扮演者ECMAScript中Global对象的角色，因此所有在全局作用域中声明的变量、函数都会变成window的属性和方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">window</span>.age)  <span class="comment">//29</span></span><br><span class="line">sayAge()  <span class="comment">//29</span></span><br><span class="line"><span class="built_in">window</span>.sayAge()  <span class="comment">//29</span></span><br></pre></td></tr></table></figure>

<p>抛开全局变量会成为window对象的属性不谈，定义全局变量与在window对象上直接定义属性还是有一点差别：全局变量不能通过delete操作符删除，而直接定义在window对象上的属性可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span></span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.age</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.color</span><br><span class="line">alert(<span class="built_in">window</span>.age)   <span class="comment">//29</span></span><br><span class="line">alert(<span class="built_in">window</span>.color)   <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>定义的全局变量再添加到window时[[Configurable]]被设置为false，因此这样定义的属性不可以通过delete操作符删除。</p>
<p>尝试访问未声明的变量会抛出错误，但通过查询window对象，可以知道某个可能未声明的变量是否存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newValue = oldValue</span><br><span class="line"><span class="comment">// 报错，因为oldValue未定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newValue = <span class="built_in">window</span>.oldValue</span><br><span class="line"><span class="comment">// 不会报错，值为undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h3><p>如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对象。每个window对象都有一个name属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">row</span>=<span class="string">"160, *"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame.htm"</span> <span class="attr">name</span>=<span class="string">"topFrame"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%, 50%"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"anotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"leftFrame"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"yetanotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"rightFrame"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个框架集，可以利用如下代码引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.frames[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">window</span>.frames.topFrame</span><br><span class="line">top.frames[<span class="number">0</span>]</span><br><span class="line">top.frames.topFrame</span><br><span class="line">frames[<span class="number">0</span>]</span><br><span class="line">frames.topFrame</span><br></pre></td></tr></table></figure>
<p>其中top对象始终指向最高层，也就是浏览器窗口。与top相对的另一个window对象时parent。parent始终指向当前框架的直接上层框架。<br>除非最高层窗口是通过window.open()打开的，否则其window对象的那么属性不会包含任何值。<br>与框架有关的最后一个对象时self，它始终指向window。<br>所有这些对象都是window对象的属性，可以通过window.parent、window.top等形式来访问。同时也以为这可以将不同层次的window对象连缀起来，例如window.parent.parent.frames[0].</p>
<p><strong>注意</strong><br>在使用框架的情况下，浏览器中会存在多个Global对象，每个框架中定义的全局变量会自动成为框架中window对象的属性。由于每个window对象都包含原生类型的构造函数，因此每个框架都有一台自己的构造函数，这些构造函数一一对应，但并不相等。例如，top.Object并不等于top.frames[0].Object。这个问题影响到对跨框架传递的对象使用instanceof操作符。</p>
<h3 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h3><h3 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h3><p>使用window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个方法可以接收4个参数：要加载的URL，窗口目标，一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。**通常只需传递一个参数，最后一个参数只在不打开新窗口的情况下使用。<br>如果window.open()传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>,<span class="string">"topFrame"</span>)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&lt;a href=<span class="string">"http://www.wrox.com"</span> target=<span class="string">"topFrame"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>调用这行代码，就如同用户单击了href属性为<a href="http://www.word.com/" target="_blank" rel="noopener">http://www.word.com/</a>, target属性为topFrame的链接。如果有一个名叫topFrame的窗口或者框架，就会在该窗口或框架加载这个URL；否则就会创建一个新的窗口并将其命名为topFrame。此外，第二个参数也可以是下列任何一个特殊的窗口名称。**_self, _parent, _top, _blank.</p>
<p>window.open()方法会返回一个纸箱新窗口的引用。引用的对象与其他window对象大致相似，但可以对其进行更多控制。</p>
<h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>location提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。事实上，location对象时一个很特别的对象，因为它既是window对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。以下为location的属性</p>
<p>1.hash  “#contents”   返回URL中的hash（#号后跟零个或多个字符），如果URL中不包含散列，则返回空字符串。<br>2.host  “<a href="http://www.wrox.com:80&quot;">www.wrox.com:80&quot;</a>   返回服务器名称含端口号（如果有）<br>3.hostname  “<a href="http://www.wrox.com&quot;" target="_blank" rel="noopener">www.wrox.com&quot;</a>  返回不带端口号的服务器名称<br>4.href   “http:/<a href="http://www.wrox.com&quot;" target="_blank" rel="noopener">www.wrox.com&quot;</a>  返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值<br>5.pathname   “/wileyCDA”  返回URL中的目录和（或）文件名<br>6.port   “8080”  返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串。<br>7.protocol  “http:”  返回页面使用的协议。通常是http:或https:<br>8.search   “?q=javascript”   返回URL的查询字符串。这个字符串以问号开头</p>
<h3 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h3><p>似然通过属性search可以得到从问号到URL末尾的所有内容，但无法逐个访问。由此可以建立一个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAueryStringArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = (location.seratch.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>): <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">var</span> args = &#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : []</span><br><span class="line">    <span class="keyword">var</span> item = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> value = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> len = item.length</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        item = items[i].split(<span class="string">'='</span>)</span><br><span class="line">        name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>])</span><br><span class="line">        value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span>(name.length) &#123;</span><br><span class="line">            args[name] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><p>使用location对象可通过很多方式来改变浏览器的位置。首先，最常用的就是使用assign()方法并为其传递一个URL，如下所示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.assign(<span class="string">'http://www.worx.com'</span>)</span><br></pre></td></tr></table></figure>
<p>这样就可以立即打开新URL并在浏览器的历史记录中生成一条记录。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location = <span class="string">"http://www.worx.com"</span></span><br><span class="line">location.href = <span class="string">"http://www.worx.com"</span></span><br></pre></td></tr></table></figure>
<p>以上方式和显式调用assing方法效果一样（因为会调用assing()方法）。<br>通过修改location的其他属性也能改变当前加载的页面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设初始URL为http://www.worx.com/wikeyCDA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将URL修改为"http://www.worx.com/WileyCDA/#section1"</span></span><br><span class="line">location.hash = <span class="string">"#section1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将URL修改为"http://www.worx.com/WileyCDA/?q=javascript"</span></span><br><span class="line">location.search = <span class="string">"?q=javascript"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将URL修改为"http://www.yahoo.com/WileyCDA/"</span></span><br><span class="line">location.hostname = <span class="string">"www.yahoo.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将URL修改为"http://www.yahoo.com/mydir/"</span></span><br><span class="line">location.pathname = <span class="string">"mydir"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将URL修改为"http://www.worx.com:8080/WileyCDA/"</span></span><br><span class="line">location.port = <span class="string">"8080"</span></span><br></pre></td></tr></table></figure>
<p>每次修改location的属性（hash除外），页面都会以新URL重新加载。<br>当通过上述任何一种方式修改URL之后，浏览器的历史记录中就会生成一条新纪录，因此用户通过单击后退俺就都会导航到前一个页面。<br>要禁用这种行为，可以使用replace()方法。这个方法只接受一个参数，纪要导航到的URL；结果虽然会导致浏览器位置变化，但不会在历史记录中生成新纪录。再调用replace()方法之后，用户不能回到前一个页面。</p>
<p>另一个与位置有关的方法是reload(),作用是重新加载当前显示的页面。如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。<strong>就是说如果页面自上次请求依赖没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要传递参数true。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location.reload()       <span class="comment">//重新加载（有可能从缓存中加载）</span></span><br><span class="line">location.reload(<span class="literal">true</span>)    <span class="comment">//重新加载（从服务器重新加载）</span></span><br></pre></td></tr></table></figure>
<p>位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。</p>
<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>history对象保存着用户上网的历史记录，从窗口被打开的哪一个算起。因为history是window对象的属性，<strong>因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联</strong>。出于安全方面考虑，开发人员无法得知用户浏览过的URL。不过，皆有用户访问过的页面列表，同样可以在不知道实际URL的情况下实现后退和前进。<br>使用go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接收一个参数，表示向后或向前跳转页面数的一个整数值。负的表示向后跳转（类似于单击浏览器的后退），正数表示向前跳转（类似于单击浏览器的前进按钮）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.go(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">history.go(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">history.go(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置（可能前进也可能后退，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么什么也不做。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="string">'worx.com'</span>)</span><br></pre></td></tr></table></figure>
<p>另外还可以使用两个简写方法back()（向后）和forward()（向前）来代替go()。</p>
<p>除了以上几个方法外，history对象还有一个length属性，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length等于0。通过如下测试该属性，可以确定用户是否一开始就打开了你的页面</p>
<p>```js<br>if (history.length == 0) {<br>    // 是第一个打开的<br>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Iversoncurry/Iversoncurry.github.io.git/2020/01/02/DOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Iversoncurry.github.io/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Iversoncurry.github.io/2020/01/02/DOM/" class="post-title-link" itemprop="url">DOM相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-02 20:27:08" itemprop="dateCreated datePublished" datetime="2020-01-02T20:27:08+08:00">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:22:43" itemprop="dateModified" datetime="2020-05-31T10:22:43+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>DOM文档对象模型，是针对HTML和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。</p>
<h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><p>DOM可以将任何HTML或XML文档描绘成一个由多个节点构成的结构。节点分为几种不同类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点数据和方法。另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面编辑则表现为一个一特定节点为根节点的树形结构.</p>
<h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><p>DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型实现的。JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。<br>每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的12个数值常量表示。</p>
<p>1.nodeName和nodeValue属性<br>要了解节点的具体信息，可以使用nodeName和nodeValue这两个属性。这两个属性的值完全取决于节点的类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>) &#123;  <span class="comment">//nodeType = 1表示为一个元素</span></span><br><span class="line">    value = someNode.nodeName  <span class="comment">//nodeName的值是元素的标签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.节点关系<br>文档中所有的节点之间都存在着联系。在HTML中，可以将<body>元素看成是<html>元素的子元素；相应的，就可以把<html>元素看成是<body>元素的父元素。而<head>元素，则可以看成是<body>元素的同胞元素，因为它们都是同一个父元素<html>的直接子元素。</p>
<p>每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种类数组对象，用于保存一组有序的节点，可以通过为止来访问这些节点。<strong>NodeList对象实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反应在NodeList对象中。我们常说，NodeList是有生命的、有呼吸的对象，而不是在我们第一次访问他们的某个瞬间拍摄下来的一张快照。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> count = someNode.childNodes.length</span><br></pre></td></tr></table></figure>
<p>其中length属性表示的是访问NodeList的那一刻，其中包含的节点数量。</p>
<p>3.操作节点<br>DOM提供了一些操作节点的方法。其中最常用的方法是appendChild()，用于向childNodes列表的末尾添加一个节点。添加节点后，childNodes的新增节点、父节点及以前的最后一个子节点的关系指针都会相应地得到更新。更新完成后，appendChild()返回新增的节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(newNode)</span><br><span class="line">alert(returnedNode == newNode) <span class="comment">//true</span></span><br><span class="line">alert(someNode.lastChild == newNode)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>如果传入到appendChild中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新的位置</strong>。即可以将DOM树看成是由一些列指针连接起来的，任何DOM节点不能同时出现在文档中的多个位置。因此如果调用appendChild()时传入了父节点的第一个子节点，那么该节点就会成为父节点的最后一个子节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(someNode.firstChild)</span><br><span class="line">alert(returnedNode == someNode.firstNode)  <span class="comment">//false</span></span><br><span class="line">alert(returnedNode == someNode.lastChild)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>如果需要把节点放在childNodes列表中某个特定的位置上，而不是放在末尾，那么可以使用insertBefore()方法。这个方法接收连个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节的前一个同胞节点，同时被方法返回。如果参照节点是null，则insertBefore()与appendChild()执行相同的操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入后成为最后一个子节点</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, <span class="literal">null</span>)</span><br><span class="line">alert(newNode == someNode.lastChild)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入后成为第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.insertBefore(newNode, someNode.firstChild)</span><br><span class="line">alert(returnedNode == newNode)  <span class="comment">//true</span></span><br><span class="line">alert(newNode == someNode.firstChild)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入到最后一个子节点前面</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, someNode.lastChild)</span><br><span class="line">alert(newNode == someNode.childNodes[someNode.childNodes.length - <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>replaceChild()方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点是将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.replaceChild(newNode, someNode.firstChild)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换最后一个子节点</span></span><br><span class="line">returnedNode = someNode.replaceChild(newNode, someNode.lastChild)</span><br></pre></td></tr></table></figure>
<p>在使用replaceChild()插入一个节点时，该节点的所有关系指针都会从被它替换的节点复制过来。被替换的节点还在文档中，但没有了自己的位置。<br>以上三个方法只针对有子节点的节点，没有子节点的节点调用后会报错。</p>
<p>4.其他方法<br>有两个方法是所有类型的节点都有的。第一个是cloneNode()，用于创建调用这个方法的节点的一个完全相同的副本。cloneNode()方法接受一个布尔参数，表示是否执行深复制。在参数为true的情况下，执行深复制，也就是复制节点及其整个子节点树；在参数为false的情况下，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。</p>
<p>另一种方法是normalize(),这个方法唯一的作用就是处理文档树中的文本节点。由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。</p>
<h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><p>JavaScript通过Document类型表示文档。<strong>在浏览器中，document对象是HTMLDocument(继承自Document类型)的一个实例，表示整个HTML页面</strong>。而且document对象时window对象的一个属性，因此可以将其作为全局对象来访问。</p>
<p>1.文档信息<br>document对象的一些属性能够表现网页的一些信息。<br>1）document.title<br>通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。</p>
<p>2）document.URL<br>该属性包含着页面完整的URL</p>
<p>3）document.domain<br>该属性中包含着页面的域名，可以设置，但并不是可以任意设置。如果URL中包含一个子域名，例如p2p.wrox.com，那么就只能将domain设置为wrox.com。不能讲这个属性设置为URL中不包含的域。两个页面同时设置为相同的document.domain则可进行通信。<br>但是初始是松散的如wrox.com，则不能再将其设置为紧绷的p2p.wrox.com。</p>
<p>4）document.referrer<br>该属性中保存着链接到当前页面的那个页面的URL。在没有来源页面的情况先，referrer属性中可能会包含空字符串。</p>
<p>3.查找元素<br>有几种查找元素的方法：<br>1.getElementByID()，接收一个参数，要取得的元素的ID。如果找到则返回，否则返回null</p>
<p>2.getElementByTagName()。这个方法接受一个参数，即要取得元素的标签名，而返回的是包含零过多个元素的NodeList。在HTML文档中，这个方法会返回一个HTMLCollection对象，作为一个动态几何，该对象与NodeList非常类似。</p>
<p>3.getElementByName()<br>只有HTMLDocument类型才有的方法。这个方法会返回带有给定的name特性的所有元素。</p>
<p>4.文档写入<br>有一个document对象的功能已经存在很多年了，那就是将输出流写入到网页的能力。这个能力体现在下列4个方法中：<br>1.write()和writeln()<br>write()和writeln()方法都接受一个字符串参数，即要写入到输出流中的文本。write()会远洋写入，而writeln()则会在字符串的末尾添加一个换行符（\n)。页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>the current date and time is:</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript&gt;</span></span></span><br><span class="line">document.write("&lt;strong&gt;" + (new Data()).toString() + "&lt;/strong&gt;")</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.open(),close()<br>open()和close()分别用于打开和关闭网页的输出流。如果是在页面加载期间使用write()或writeln()方法，则不需要用到这两个方法。</p>
<h3 id="使用NodeList"><a href="#使用NodeList" class="headerlink" title="使用NodeList"></a>使用NodeList</h3><p>理解NodeList、NameNodeMap和HTMLCollection，是从整体上透彻理解DOM的关键所在。这三个集合都是动态地；换句话说，当文档结构发生变化时，它们都会得到更新。因此，它们始终都会保存着最新、最准确的信息。从本质上讲，所有NodeList对象都是在访问DOM文档时实时运行的查询。<br>如下代码将导致无限循环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">var</span> i</span><br><span class="line"><span class="keyword">var</span> div</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.length; i++) &#123;</span><br><span class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行代码会取得文档中所有<div>元素的HTMLCollection。由于这个集合是动态地，因此只要有新的<div>元素被添加到页面中，这个元素也会被添加到该集合中。浏览器不会将创建的所有集合都保存在一个列表中，而是在下一次访问集合时再更新集合。由此将导致无限循环。</p>
<h2 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h2><h3 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h3><p>众多JavaScript库中最常用的一项功能，就是根据CSS选择符与某个模式匹配的DOM元素。Selectors API Level 1的核心是两个方法：querySelector()和querySelectorAll()。</p>
<p>1.querySelector()方法<br>querySelector()方法接受一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>)</span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">'#myDiV'</span>)</span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">'.selected'</span>)</span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.body.querySelector(<span class="string">'img.button'</span>)</span><br></pre></td></tr></table></figure>

<p>2.querySelectorAll()方法<br>querySelectorAll()方法接收的参数与querySelector()方法一样，都是一个CSS选择符，但返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的的是一个NodeList的实例。<br>具体来说，返回的值实际上是带有所有属性和方法的NodeList，而其底层实现类似于一组元素的快照，而非不断对文档进行搜索的动态查询。这样实现可以避免使用NodeList对象通常会引起的大多数性能问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Iversoncurry/Iversoncurry.github.io.git/2019/12/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Iversoncurry.github.io/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Iversoncurry.github.io/2019/12/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">面向对象的程序设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-26 20:27:08" itemprop="dateCreated datePublished" datetime="2019-12-26T20:27:08+08:00">2019-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:29:08" itemprop="dateModified" datetime="2020-05-31T10:29:08+08:00">2020-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Iversoncurry.github.io/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">JavaScript高级程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>引用类型的值（对象）是引用类型的一个实例。</strong>在ECMAScript中，引用类型是一种书结构，用于将数据和功能组织在一起。尽管ECMAScript从技术上讲是一门面向对象的语言，但他不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。<br>对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的，构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。</p>
<h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>虽然Object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。<br>创建Object实例的方法有两种，第一种是使用new操作符后跟Object构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">"Nicholas"</span></span><br><span class="line">person.age = <span class="number">19</span></span><br></pre></td></tr></table></figure>
<p>另一种方式是使用<strong>对象字面量</strong>表示法，对象i字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。其中，属性名也可以使用字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>,</span><br><span class="line">person.age = <span class="number">19</span></span><br></pre></td></tr></table></figure>
<p>对象的属性可以通过点表示法和方括号法进行访问，从功能上看两者没有任何区别，但方括号语法的主要优点是可以通过变量来访问属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;</span><br><span class="line">    name: <span class="string">'daming'</span>,</span><br><span class="line">    age: <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personName = <span class="string">'name'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br><span class="line"><span class="built_in">console</span>.log(person[personName])</span><br></pre></td></tr></table></figure>
<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>ECMA-262在定义只有内部才能用的特性(attribute)时，描述了属性(property)的各种特征。这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问它们。为了表示特性是内部值，该规范把他们放在了两对方括号中，例如[[Enumerable]]。<br>对象有两种属性，数据属性和访问器属性</p>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有4个描述其行为的特性：<br>1.[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。<br>2.[[Enumerable]]:表示能否通过for-in循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true；<br>3.[[Writable]]:表示能否修改属性的值，像前面离震中那样直接在对象上定义的属性，它们的这个特性默认为true；<br>4.[[Value]]:包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性时，把新值保存在这个位置。这个特性的默认值为undefined。<br>对于前面例子中那样直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]、[[Writable]]特性都被设置为true，而[[Value]]特性被设置为指定的值<br>要修改属性默认的特性，必须使用Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象，属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable，enumerable，writable，value。设置其中的一个或多个值，可以修改对应的特性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">//Nicholas</span></span><br><span class="line">person.name = <span class="string">"daming"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>
<p>当writable为false时，在严格模式下赋值操作将抛出错误，在非严格模式下将被忽略，这个规则适用于”configurable: false”情况下。同时当把属性定义为不可配置的，就<strong>不能</strong>把它在变回可配置的。此时再调用Object.defineProperty()方法修改除writable之外的特性，都会导致错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configureble: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//一下代码将导致抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: ture,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p><strong>访问器属性不包含数据值</strong>，它们包含一对getter和setter函数（这两个函数都不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数，并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性：<br>[[Configurable]]: 表示能否通过delete删除从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性，对于直接在对象上定义的属性，合格特性的默认值为true<br>[[Enumerable]]：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。<br>[[Get]]：在读取属性时调用的函数。默认值为undefined<br>[[Set]]：再写入属性时。默认值为undefined<br>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _yera: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.edition)   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>_year前的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性；而<strong>访问器属性year</strong>则包含一个getter函数和一个setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，把year属性修改为2005会导致——year变为2005，而edition变为2.这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。<br>不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，非严格模式下尝试写入属性会被忽略；在严格模式下，尝试写入值制定了getter函数的属性会抛出错误。类似的，没有指定getter函数的属性也不能读，否则在非严格模式下会返回undefined，在严格模式下会抛出错误。</p>
<h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>由于为对象定义多个属性的可能性很大，ECMAScript 5 又定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">    _year:&#123;</span><br><span class="line">        value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>使用Object.definePropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和尧都区其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个歌对象的属性又configurable, enumerable, get, set；如果是数据属性，这个对象的属性有configurable, enumerable, writable, value.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperities(book, &#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>)</span><br><span class="line"><span class="keyword">var</span> descriptor2 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor2.value)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor2.enumerable)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor2.get)</span><br></pre></td></tr></table></figure>
<p>在JavaScript中，可以针对任何对象，包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    o.name = name</span><br><span class="line">    o.age = age</span><br><span class="line">    o.job = job</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>)</span><br></pre></td></tr></table></figure>
<p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别问题（即怎样知道一个对象的类型）。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"daming"</span>, <span class="number">13</span>, <span class="string">"SoftWare Engineer"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaoming"</span>, <span class="number">11</span>, <span class="string">"student"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：要创建Person的新实例，必须使用new操作符，这种方式调用构造函数实际上会经历以下4个步骤:<br>1.创建一个新对象<br>2.将构造函数的租用与赋给新对象（因此this就只想了这个新对象）<br>3.执行构造函数中的代码（为这个个新对象添加属性）<br>4.返回新对象</p>
<p>在前面的例子最后，person1和person2分别保存着Person的一个不同的实例，这两个对象都有一个constructor（构造函数）属性，改属性指向Person。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor === Person)    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor === Person)    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>对象的constructor属性最初时用来表示对象类型的。但是，提到检测对象类型，还是instanceof更可靠一些。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)         <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person)         <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而着正事构造函数模式胜过工厂模式的地方。<br><strong>以这种方式定义的构造函数是定义在Global对象（在浏览器中是window对象）中的。</strong></p>
<p>**将构造函数当作函数<br>构造函数与其他函数的唯一区别，就在于调用它们的方式不同，不过构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new操作符调用，那它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当作构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"software engineer"</span>)</span><br><span class="line">person.sayName()       <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//作为普通函数调用</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>)</span><br><span class="line"><span class="built_in">window</span>.sayName()                <span class="comment">//"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">Person.call(o, <span class="string">"daming"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>)</span><br><span class="line">o.sayName()              <span class="comment">//"daming"</span></span><br></pre></td></tr></table></figure>

<p>**构造函数的问题<br>构造函数模式虽然好用，但也并非没有缺点，使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。ECMAScript中的函数是对象，因此没定义一个函数，也就是实例化了一个对象，从逻辑角度讲，此时的构造函数也可以这样定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log(this.name)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个角度上来看构造函数，更容易明白每个Person实例都包含一个不同的Function实例（以显示name属性）的本质。以这种方式创建函数，会导致不同的作用域链和表示符解析，但创建Function新实例的机制仍然是相同的。因此不同实力上的同名函数是不相等的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName)       <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>然而，创建两个完成同样任务的Function实例的确没有必要，况且有this对象在，根本不用在执行代码前就把哈数绑定到特定对象上面。因此，大可像下面这样，通过函数定义转移到构造函数外部来解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"daming"</span>, <span class="number">19</span>, <span class="string">"software engineer"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"xiaoming"</span>, <span class="number">17</span>, <span class="string">"docter"</span>)</span><br></pre></td></tr></table></figure>
<p>这个例子中，我们把sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们讲sayName属性设置等于全局的sayName函数，这样一来由于sayName包含的是一个指向函数的指针，因此person1和person2对象就共享了在全局作用臃肿定义的同一个sayName()函数。这解决了两个函数做同一件事的问题，但出现了新问题。全局作用域下的函数只能被某个对象调用，有违全局作用域的本意，同时如果对象需要定义很多方法，那么就要定义多个全局函数，这样就毫无封装性可言了。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。换句话说，不必再构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.prototype.name = <span class="string">"daming"</span></span><br><span class="line">    Person.prototype.age = <span class="number">19</span></span><br><span class="line">    Person.prototype.job = <span class="string">"software engineer"</span></span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line">person1.sayName()    <span class="comment">//daming</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line">person2.sayName()    <span class="comment">//daming</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName)    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在此，<strong>与构造函数不同之处在于，新对象的这些属性和方法是由所有实例共享的。</strong></p>
<p>理解原型对象<br>无论什么时候，只要创建了一个新函数，就回根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针，就拿前面的例子来说，Person.prototype.constructor指向Person。通过这个构造函数，我们可以继续为原型对象添加其他属性和方法。<br>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，至于其他方法，都是从Object继承而来。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象，ECMA-262第5版中管这个指针叫[[Prototype]]。<strong>要明确的是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例和构造函数之间</strong>。具体关系如下图</p>
<!-- ![attr](/public/images/实例原型构造函数关系图.png) -->
<p><img src="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/a.png" alt="attr"><br>如上例中，两个对象都不包含属性和方法，但我们却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。<br>虽然在所有实现中都无法访问到[[Prototype]],但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向 调用isPrototypeOf()方法的对象（Person.prototype),那么这个方法就返回true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1))</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person2))</span><br></pre></td></tr></table></figure>
<p>ECMAScript5中增加了一个新方法，叫Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype)     <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1).name)                    <span class="comment">//"daming"</span></span><br></pre></td></tr></table></figure>
<p>使用Object.getPrototypeOf()可以方便地取得一个对象的原型，而在利用原型实现集成的情况下是非常重要的。<br>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值，如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那就在实例中创建该属性，改属性将会屏蔽原型中的那个属性。添加这个属性只会阻止访问原型对象中的那个属性，但不会修改那个属性。即使将该属性设为null，也只会在实例中设置这个属性，不会恢复其指向原型的连接。不过delete操作符可以完全删除实例属性，从而能够重新访问原型中的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span></span><br><span class="line">Person.prototype.age = <span class="number">19</span></span><br><span class="line">Person.prototype.job = <span class="string">"software engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line">person1.name = <span class="string">"daming"</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name)   <span class="comment">//daming</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name)   <span class="comment">//Nicholas</span></span><br><span class="line">person1.sayName()           <span class="comment">//daming</span></span><br><span class="line">person2.sayName()           <span class="comment">//Nicholas</span></span><br><span class="line"></span><br><span class="line">person1.name = <span class="literal">null</span>         </span><br><span class="line"><span class="built_in">console</span>.log(person1.name)   <span class="comment">//null</span></span><br><span class="line">person1.sayName()           <span class="comment">//null</span></span><br><span class="line"><span class="keyword">delete</span> person1.name</span><br><span class="line"><span class="built_in">console</span>.log(person1.name)   <span class="comment">//Nicholas</span></span><br><span class="line">person1.sayName()           <span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>
<p>使用hasOwnProperty()方法可以检测一个属性是存在在于实例中还是存在在于原型中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span></span><br><span class="line">Person.prototype.age = <span class="number">19</span></span><br><span class="line">Person.prototype.job = <span class="string">"software engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line">person1.name = <span class="string">"daming"</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name)                    <span class="comment">//daming</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name)                    <span class="comment">//Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="keyword">delete</span> person1.name                           </span><br><span class="line"><span class="built_in">console</span>.log(person1.name)                    <span class="comment">//Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><strong>原型与in操作符</strong><br>有两种方式使用in操作符：单独使用和在for-in循环中使用。<br><strong>单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span></span><br><span class="line">Person.prototype.age = <span class="number">29</span></span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1)               <span class="comment">//true</span></span><br><span class="line">person1.name = <span class="string">"Greg"</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name)                    <span class="comment">//"Greg" -----来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1)               <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name)                    <span class="comment">//daming -----来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person2)               <span class="comment">//true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name</span><br><span class="line"><span class="built_in">console</span>.log(person1.name)                    <span class="comment">//daming -----来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1)               <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>在使用for-in循环时，返回的时所有能够通过对象访问的，可枚举的（enumerated）属性，其中，既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerale]]标记的属性）的实例也会在for-in循环中返回。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span></span><br><span class="line">Person.prototype.age = <span class="number">29</span></span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;                                    <span class="comment">//name, age, job, sayName</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"name"</span>, &#123;</span><br><span class="line">	enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;                                   <span class="comment">//age, job, sayName</span></span><br><span class="line">person1.name = <span class="string">"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> person1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;                                   <span class="comment">//name, age, job, sayName</span></span><br></pre></td></tr></table></figure>
<p>要取得对象上所有可枚举的实例属性，可以使用ECMAScript5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。<br><strong>注意Object.keys和for-in之间的差别</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"daming"</span></span><br><span class="line">Person.prototype.age = <span class="number">29</span></span><br><span class="line">Person.prototype.job = <span class="string">"softWare Engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(keys)                               <span class="comment">//name, age, job, sayName</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1.name = <span class="string">"Rob"</span></span><br><span class="line">p1.age = <span class="number">31</span></span><br><span class="line"><span class="keyword">var</span> p1keys = <span class="built_in">Object</span>.keys(p1)</span><br><span class="line"><span class="built_in">console</span>.log(p1keys)                            <span class="comment">//name, age</span></span><br></pre></td></tr></table></figure>
<p><strong>如果需要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(keys)                                   <span class="comment">//constructor, name, age, job, sayName</span></span><br></pre></td></tr></table></figure>

<p><strong>更简单的原型语法</strong><br>用一个包含所有属性和方法的对象字面量来重写整个原型对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，将Person.prototype设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外，constructor属性不再指向Person了。每创建一个函数，都会同时创建它的prototype对象，这个对象会自动获得constructor属性，而我们在这里使用的语法，本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数。此时，尽管instanceof操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor ==<span class="built_in">Object</span>)  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(friend2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend2 <span class="keyword">instanceof</span> Person)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend2.constructor == Person) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(friend2.constructor ==<span class="built_in">Object</span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>另一种写法，会导致不同的输出结果，原因在于重写了Person.prototype对象后Person.prototype已发生改变，<strong>注意与上一种的区别联系</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor ==<span class="built_in">Object</span>)  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person)  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor ==<span class="built_in">Object</span>)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>如果constructor的值真的很重要，可以像像下面这样特意将他设置会适当值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "nicholas",</span><br><span class="line">    age: 29,</span><br><span class="line">    job: "software Engineer",</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，以这种方式重设constructor属性会导致它的[[Enumerable]]特性被设置为true。默认情况下，原生的constructor属性是不可枚举的，弥补方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fucntion Person() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span></span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>原型的动态性</strong><br>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所作的任何修改都能够立即从实例上反映出来，即使先创建了实例后修改原型也照样如此。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line">friend.sayHi()     <span class="comment">//hi</span></span><br></pre></td></tr></table></figure>
<p>尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果重写整个原型对象就不一样了。其原因在于，调用构造函数时会为实力添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系。**实例中的指针仅指向原型，不指向构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sayAge'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person()</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'Nicholas',</span><br><span class="line">    age: 19,</span><br><span class="line">    job: 'software enginner',</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">friend.sayAge()                 <span class="comment">//'sayAge'</span></span><br><span class="line">friend.sayName()                <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p><strong>原生对象的原型</strong><br>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object, Array, String, 等等）都在其构造函数的原型上定义了方法。例如，在Array.prototype中可以找到sort()方法，而在String.prototype中可以找到substring()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort)                 <span class="comment">//funciton</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring)           <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型String添加了一个名为startsWith()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">'Hello World'</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">'Hello'</span>))   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>尽管可以这样做，但不推荐在产品化的程序中修改原生对象的原型。如果因某个事项中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的视线中运行代码时，就可能会导致命名冲突，而且这样做也可能会意外地重写原生方法。<br><strong>原生对象地问题</strong><br>原型模式也不是没有缺点，首先，它省略了为构造函数传递初始化阐述这一回姐，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题，原型模式的最大问题是由其共享的本性所导致的。<br>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性说得过去，因为通过在实力上添加一个同名属性，可以隐藏原型中的对应属性。但对于包含引用类型的属性来说，问题就比较突出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'Nicholas',</span><br><span class="line">    age: 19,</span><br><span class="line">    job: 'software enginee',</span><br><span class="line">    friends: ['daing', 'lingling'],</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line">person1.friends.push(<span class="string">'Van'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends)                       <span class="comment">//daing, lingling, Van</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends)                       <span class="comment">//daing, lingling, Van</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.freidns)   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在person1的friends中添加一项，person2的friends也相应添加了一项，在大多数情况下这是不想要的，这个问题正是很少有人单独使用原型模式的原因。</p>
<h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。<strong>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性</strong>。这样，每个实力都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，这最大限度地接上了内存。另外，这种混成模式还支持向构造函数传递参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">'daming'</span>, <span class="string">'lingling'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">19</span>, <span class="string">'software engineer'</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">17</span>, <span class="string">'doctor'</span>)</span><br><span class="line">person1.friends.push(<span class="string">'van'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends)                                 <span class="comment">//daming, lingling, van</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends)                                 <span class="comment">//daming, lingling</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends)             <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName)             <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>动态原型模式把所有信息都封装再了构造函数中，二通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否有需要初始化原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>通常，在前述的集中模式都不适用的情况下，可以使用寄生(parasitic)构造函数模式。这种模式的基本思想时创建一个函数，该函数的作用仅仅时封装创建对象的代码，然后再返回新建的对象；但从表面上看，这个函数又像是典型的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    o.name = name</span><br><span class="line">    o.age = age</span><br><span class="line">    o.job = job</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'software engineer'</span>)</span><br><span class="line">friend.sayName()                                                  <span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>
<p>这里除了使用new操作符并把使用的包装函数叫做构造函数骄傲做构造函数之外，这个模式跟工厂模式其实是一模一样的。<strong>构造函数在不返回值的情况下，默认会返回新对象实例。而通过构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值。</strong><br>这个模式可以在特殊的情况西用来为对象创建构造函数，假设我们向创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数，因此可以使用这个模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">    values.push.apply(values, <span class="built_in">arguments</span>)</span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>)</span><br><span class="line"><span class="built_in">console</span>.log((colors.toPipeString()));</span><br></pre></td></tr></table></figure>
<p>关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造汉顺外部创建的对象没有什么不同。为此不能依赖instanceof操作符来确定对象类型。</p>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this对象，稳妥对象最适合在一些安全的环境中使用（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">"Nicholas"</span>, <span class="number">19</span>, <span class="string">"Software Engineer"</span>)</span><br><span class="line">friend.sayName()                                             <span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>
<p>注意，在以这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法访问name的值。<br>这样，变量person中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。稳妥构造函数模式提供这种安全性。<br>与寄生构造函数模式类似，使用稳妥构造含糊模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。</p>
<h2 id="扩展的对象功能"><a href="#扩展的对象功能" class="headerlink" title="扩展的对象功能"></a>扩展的对象功能</h2><h3 id="对象类别"><a href="#对象类别" class="headerlink" title="对象类别"></a>对象类别</h3><p>对象类别包括：<br>普通对象： 拥有JS对象所有默认的内部行为<br>奇异对象：其内部行为在某些方面有别于默认行为<br>标准对象：在ES6中被定义的对象，例如Array、Date等等<br>内置对象：在脚本开始运行时由JS运行环境提供的对象。<strong>所有标准对象都是内置对象。</strong></p>
<h3 id="对象字面量语法的扩展"><a href="#对象字面量语法的扩展" class="headerlink" title="对象字面量语法的扩展"></a>对象字面量语法的扩展</h3><p>对象字面量是JS中最流行的模式之一（JSON就是基于这种语法），而它还存在于互联网上的几乎所有JS文件中。<br><strong>属性初始化器的速记法</strong><br>在ES5及更早的版本中，对象字面量是“键值对”的简单集合。这意味着在属性值被初始化时可能会有重复，ES6中，可以使用属性初始化器的速记法来消除对象名称与本地变量的重复情况。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6语法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cretePerson</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法简写</strong><br>ES6同样改进了为对象字面量方法赋值的语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"nicholas"</span>,</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>需计算属性名</strong><br>对象实例能使用”需计算属性名“，只要用方括号表示法来替代小数点表示法即可。方括号允许你将变量或字符串字面量指定为属性名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'last name'</span></span><br><span class="line">person[<span class="string">'first name'</span>] = <span class="string">'nicholas'</span></span><br><span class="line">person[lastName] = <span class="string">'zakas'</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])          <span class="comment">//nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastName])              <span class="comment">//zakas</span></span><br><span class="line"><span class="built_in">console</span>.log(person.first name)             <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>可以在对象字面量中将字符串字面量直接用作属性，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">'first name'</span>: <span class="string">'nicholas'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])</span><br></pre></td></tr></table></figure>
<p>在ES6中，需计算属性名时对象字面语法的一部分，它用的也是方括号表示法，于此前在对象实例上的用法一直</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastName = <span class="string">'last name'</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">'first name'</span>: <span class="string">'nicholas'</span>,</span><br><span class="line">    [lastName]: <span class="string">'zakas'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(person[lastName])</span><br></pre></td></tr></table></figure>
<p>对象字面量内的方括号表明该属性名需要计算，其结果是一个字符串，这意味着其中可以包含表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suffix = <span class="string">' name'</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    [<span class="string">'first'</span> + suffix]: <span class="string">'nicholas'</span>,</span><br><span class="line">    [<span class="string">'last'</span> + suffix]: <span class="string">'zakas'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'last name'</span>])</span><br></pre></td></tr></table></figure>
<h3 id="新的方法"><a href="#新的方法" class="headerlink" title="新的方法"></a>新的方法</h3><p>当JS中要比较两个值时，可能会使用相等运算符（==）或严格相等运算符（===）。为了避免在比较时发生前值类型转化，许多开发者更倾向使用后者。但严格相等运算符也不完全标准，例如它认为+0和-0相等，即使这两者在JS引擎中有不同的表示；另外NaN===NaN会返回false，因此有必要使用isNaN()函数来正确检查NaN，<br>ES6引入了Object.is()方法来弥补严格相等运算符残留的怪异点。此方法接收两个参数，并会在二者的值相等时返回true，此时要求二者类型相同并且值也相等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="string">"5"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="string">"5"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="number">5</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="string">"5"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>Object.assign方法</strong><br>混入（Mixin）是在JS中组合对象时最流行的模式。再一次混入中，一个对象会从另一个对象中接收属性与方法。很多JS的库中都有类似下面的混入方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minin</span>(<span class="params">receiver, supplier</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(supplier).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        receiver[key] = supplier[key]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> receiver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于mixin()函数使用了赋值运算符（=），<strong>因此无法将访问器属性复制到接收者上，Object.assign()体现了这种区别(即无法复制访问器属性）。</strong><br>Object.assign() 方法接受任意数量的供应者，而接收者会按照供应者在参数中的顺序来依次接收它们的属性。这意味着在接收者中，第二个供应者的属性可能会覆盖第一个供应者的，这在下面的代码片段中就发生了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(receiver,</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">"js"</span>,</span><br><span class="line">        name: <span class="string">"file.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">"css"</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(receiver.type) <span class="comment">// "css"</span></span><br><span class="line"><span class="built_in">console</span>.log(receiver.name) <span class="comment">// "file.js"</span></span><br></pre></td></tr></table></figure>
<p><strong>需要记住 Object.assign() 并未在接收者上创建访问器属性，即使供应者拥有访问器属性。由于 Object.assign() 使用赋值运算符，供应者的访问器属性就会转变成接收者数据属性</strong>，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> supplier = &#123;</span><br><span class="line">    <span class="keyword">get</span> name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"file.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(receiver, supplier)</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(receiver, <span class="string">"name"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value) <span class="comment">// "file.js"</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.get); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>重复的对象字面量属性</strong><br>ES5 严格模式为重复的对象字面量属性引入了一个检查，若找到重复的属性名，就会抛出错误。例如，以下代码就有问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    name: <span class="string">"Greg"</span> <span class="comment">// 在 ES5 严格模式中是语法错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但 ES6 移除了重复属性的检查，严格模式与非严格模式都不再检查重复的属性。当存在重复属性时，排在后面的属性的值会成为该属性的实际值，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    name: <span class="string">"Greg"</span> <span class="comment">// 在 ES6 严格模式中不会出错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// "Greg"</span></span><br></pre></td></tr></table></figure>
<p><strong>自有属性的枚举顺序</strong><br>ES5并没有定义对象属性的枚举顺序。ES6中则严格定义了对象自由属性在被美剧时返回的顺序。这对Object.getOwnPropertyNames()和Reflect.ownKeys如何返回属性造成了影响，同样影响了Object.assign()处理属性的顺序。<br>自有属性枚举时基本顺序如下：<br>1.所有的数字类型键，按升序排列；<br>2.所有的字符串类型键，按被添加到对象的顺序排类；<br>3.所有的符号类型键，也按添加顺序排列。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    c: <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">obj.d = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).join(<span class="string">""</span>)); <span class="comment">// "012acbd"</span></span><br></pre></td></tr></table></figure>
<p><strong>for-in 循环的枚举顺序仍未被明确规定，因为并非所有的 JS 引擎都采用相同的方式。而 Object.keys() 和 JSON.stringify() 也使用了与 for-in 一样的枚举顺序。</strong><br><strong>更强大的原型</strong><br>修改对象的原型<br>一般来说，对象的原型会在通过构造器或 Object.create() 方法创建该对象时被指定。直到ES5 为止， JS 编程最重要的假定之一就是对象的原型在初始化完成后会保持不变。尽管ES5 添加了 Object.getPrototypeOf() 方法来从任意指定对象中获取其原型，但仍然缺少在初始化之后更改对象原型的标准方法。<br>ES6 通过添加 Object.setPrototypeOf() 方法而改变了这种假定，此方法允许你修改任意指定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = <span class="built_in">Object</span>.create(person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 将原型设置为 dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Woof"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>对象原型的实际值被存储在一个内部属性[[Prototype]]上，Object.getPrototypeOf()方法会返回此属性存储的值，而Object.setPrototypeOf()方法能够修改该值。<br><strong>使用super引用的简单原型访问</strong><br>关于原型的另一项进步就是引入了super引用，这让在对象原型上的功能调用变得更加容易。例如若要覆盖对象实例的一个方法、但依然要调用原型上的同名方法，如下（以下代码为ES5的实现方案）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">	name: <span class="string">'daming'</span>,</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="comment">// return 'woof' + this.name</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'woof'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">	name: <span class="string">'friend'</span>,</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">', hi'</span>         <span class="comment">//这里的this指向friend，可以通过this.name验证</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person)</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting())                             <span class="comment">//hello, hi</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person)         <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog)</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting())                             <span class="comment">//woof, hi</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog)            <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>从代码中可以看出this的指向过于复杂。ES6中引入super。简单说，super是指向当前对象的原型的一个指针，实际上就是Object.getPrototypeOf(this)的值。由此简化friend中的getGreet()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">    <span class="comment">// 这相当于上个例子中的：</span></span><br><span class="line">    <span class="comment">// Object.getPrototypeOf(this).getGreeting.call(this)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处调用super.getGreeting()等用于在上例的环境中使用Object.getPrototypeOf(this).getGreeting.call(this).类似的，能使用super引用来调用对象原型上的任何方法，<strong>只要这个引用时位于简写的方法之内</strong>。试图在方法接卸之外的情况使用super会导致语法错误，<strong>在这种上下文中 super 是不可用的：错误信息（SyntaxError: ‘super’ keyword unexpected here）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">', hi'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在多继承时，super引用功能非常强大，因为这种情况下，Object.getPrototypeOf()不再适用于所有场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="comment">// console.log('%%%%%%%%%%%%%%%%')</span></span><br><span class="line">    	<span class="comment">// console.log(this === relative)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">',hi'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person)</span><br><span class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend)</span><br><span class="line"><span class="built_in">console</span>.log(person.getGreeting())                   <span class="comment">//hello</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting())                   <span class="comment">//hello, hi</span></span><br><span class="line"><span class="built_in">console</span>.log(relative.getGreeting())                 <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>调用 Object.getPrototypeOf() 时，在调用 relative.getGreeting() 处发生了错误。这是因为此时 this 的值是 relative ，而 relative 的原型是 friend 对象，这样<br>friend.getGreeting().call() 调用就会导致进程开始反复进行递归调用，直到发生堆栈错误。(原因在于this引用的一直都是relative)<br>在ES6中，利用super可以解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person)</span><br><span class="line"><span class="comment">// 原型为 friend</span></span><br><span class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend)</span><br><span class="line"><span class="built_in">console</span>.log(person.getGreeting()) <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()) <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(relative.getGreeting()) <span class="comment">// "Hello, hi!"</span></span><br></pre></td></tr></table></figure>
<p><strong>正式的“方法”定义</strong><br>在ES6之前，“方法”的概念从未被正式定义，此前禁止对象的函数属性（而非数据属性）。ES6中正事做出了定义：方法时一个拥有[[HomeObject]]内部属性的函数，此内部属性指向该方法所属的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shareGreeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何对 super 的引用都会使用 [[HomeObject]] 属性来判断要做什么。第一步是在[[HomeObject]] 上调用 Object.getPrototypeOf() 来获取对原型的引用；接下来，在该原型<br>上查找同名函数；最后，创建 this 绑定并调用该方法。这里有个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person)</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()) <span class="comment">// "Hello, hi!"</span></span><br></pre></td></tr></table></figure>
<p>调用 friend.getGreeting() 返回了一个字符串，也就是 person.getGreeting() 的返回值与”, hi!” 的合并结果。此时 friend.getGreeting() 的 [[HomeObject]] 值是 friend ，并且friend 的原型是 person ，因此 super.getGreeting() 就等价于person.getGreeting.call(this) 。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ECMAScript中描述了<strong>原型链</strong>的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。<br>实现原型链有一种基本模式，其代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue())         <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.constructor)             <span class="comment">//SuperType</span></span><br></pre></td></tr></table></figure>
<p>通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。即，当一度去模式访问一个实例属性是，首先会在实力上搜索改属性，果果没有找到改属性，则会继续搜索实例的原型，再通过原型链实现集成的请款西，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，条用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype；3）搜索SuperType.prototype，最后一步才会找到该方法。再找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。<br><strong>默认的原型</strong><br>之前的例子中展示的原型链还少一环。所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。所有函数的默认原型都是Object的实例。因此默认内源性都会包含一个内部指针，指向Object.prototype。这也是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。<br><strong>SubType继承了SuperType，而SuperType继承了Object。</strong><br><strong>确定原型和实例关系</strong><br>可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用instanceof操作符。只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就回返回true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>)                <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperType)             <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SubType)               <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>由于原型链的关系，可以说instance是Object、SuperType或SubType中任何一个类型的实例。<br>第二种方法是使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型。因此isPrototypeOf()方法也会返回true：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance))     <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance))  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(SubType.prototoye.insPrototypeOf(instance))   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>谨慎的定义方法</strong><br>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue())              <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个继承SuperType的对象对getSuperValue()的引用未发生改变</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anSubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.anSubProperty = <span class="string">'hhh'</span></span><br><span class="line">&#125;</span><br><span class="line">anSubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">anSubType.prototype.getanSubProperty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.anSubProperty</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anInstance = <span class="keyword">new</span> anSubType()</span><br><span class="line"><span class="built_in">console</span>.log(anInstance.getSuperValue())             <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>当通过SubType的实例调用getSuperValue()时，调用的就是这个重新定义的方法；但通过SuperType的实例调用getSuperValue()时，还会继续调用原来的那个方法。<br>这里要格外注意的时，<strong>必须在用SuperType的实例替换原型之后，再定义这两个方法。</strong><br>除默认原型外，其他实例中不包含指向构造函数的指针，这也就是图6-5中展现出的形式，即SubType.prototype不包含constructor属性，因为它是由SuperType生成的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(SubType.prototype.constructor)               <span class="comment">//SuperType</span></span><br></pre></td></tr></table></figure>
<p>还有一点要注意，即在通过原型链实现继承，不能使用对象字面量创建原型方法，因为这样做就会重写原型链:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    getSubValue: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">    &#125;,</span><br><span class="line">    getSuperValue: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue())               <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>以上代码展示了刚刚把SuperType的实例赋值给原型链，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，一次原型链已经被切断。<br><strong>此处继承和通过原型构造实例的对象字面量方式的区别与联系在于：</strong></p>
<p><strong>原型链的问题</strong><br>原型链虽然很强大，可以用它来实现继承，但也存在一些问题。其中最主要的问题来自包含引用类型值的原型。包含引用类型值的原型属性会被所有实例共享，这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType()</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)            <span class="comment">//red, blue, green, black</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)            <span class="comment">//red, blue, green, black</span></span><br></pre></td></tr></table></figure>
<p>原型链的第二个问题是：在创建i之类性的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>在解决原型中包含引用类型值所带来问题的过程中，开始使用一种叫做借用构造函数的技术。其基本思想为在子类型构造函数的内部调用超类型构造函数。**函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）创建的对象上执行构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType()</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)</span><br></pre></td></tr></table></figure>
<p>代码中注释”继承了SuperType”那一行代码借调了超类型的构造函数。通过使用call()方法和apply()方法，实际上是在新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就回在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码（实际上利用this绑定到新对象），由此，SubType的每个实例就都会具有自己的colors属性的副本。<br><strong>传递函数</strong><br>相对于原型链而言，借用构造函数有一个很大的优势： 即可以在子类型构造函数中向超类型构造函数传递参数，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>)</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.name)                   <span class="comment">//Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age)                    <span class="comment">//19</span></span><br></pre></td></tr></table></figure>
<p>以上代码中的SuperType只接收一个参数name，该参数会直接赋给一个属性，在SubType构造函数内部调用SuperType构造函数时，实际上是为SubType的实例设置了name属性。为保证SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。<br><strong>借用构造函数的问题</strong><br>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题————方法都在构造函数中定义，因此无法进行函数复用。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术结合到一起。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">19</span>)</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)</span><br><span class="line">instance1.sayName()</span><br><span class="line">instance1.sayAge()</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">17</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)</span><br><span class="line">instance2.sayName()</span><br><span class="line">instance2.sayAge()</span><br></pre></td></tr></table></figure>
<p>instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>该方式的基本想法为借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        F.prototype = o</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象左右这个构造函数的原型，最后返回了这个临时类型的新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'shelby'</span>, <span class="string">'court'</span>, <span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person)</span><br><span class="line">anotherPerson.name = <span class="string">'Greg'</span></span><br><span class="line">anotherPerson.friends.push(<span class="string">'rob'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person)</span><br><span class="line">yetAnotherPerson.name = <span class="string">'linda'</span></span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">'barbie'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.friends)                    <span class="comment">//'shelby', 'court', 'van', 'rob'</span></span><br></pre></td></tr></table></figure>
<p>实际上，上述代码相当于又创建了person的两个副本<br>ECMAScript5通过Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()和Object()方法的行为相同。(<strong>注意基本数据类型和引用类型的区别</strong>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'shelby'</span>, <span class="string">'count'</span>, <span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person)</span><br><span class="line">aontherPerson.name = <span class="string">'Greg'</span></span><br><span class="line">anotherPerson.friends.push(<span class="string">'Rob'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person)</span><br><span class="line">yetAnotherPerson.name = <span class="string">'Linda'</span></span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">'Barbie'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.friends)                <span class="comment">//'shelby', 'count', 'van', 'Rob', 'Barbie'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    name: <span class="string">'nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'shelby'</span>, <span class="string">'count'</span>, <span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">'greg'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name)                <span class="comment">//greg</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson)                     <span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person)                            <span class="comment">//&#123; name: 'nicholas', friends: [ 'shelby', 'count', 'van' ] &#125;</span></span><br></pre></td></tr></table></figure>
<p>在没必要使用构造函数，只想让一个对象与另一个对象保持类似的情况西，原型式继承完全可以胜任。不过，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承是与原型式继承相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即船舰一个仅用于封装击沉过程的函数，该函数在内部以某种愤怒时来增强对象，最后再像真的是他做了所有工作一样返回对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object(original)</span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'nicholas'</span>,</span><br><span class="line">    friends: [<span class="string">'shelby'</span>, <span class="string">'courts'</span>, <span class="string">'van'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person)</span><br><span class="line">anotherPerson.sayHi()</span><br></pre></td></tr></table></figure>
<p>使用寄生式继承来为对象添加函数会由于不饿能做到函数复用而降低效率；这一点与构造函数类似</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>前面说过，组合继承是javaScript最常用的集成模式；不过，也有不足。组合继承最大的问题就是无论什么请款下，都会调用两次超类型构造函数：一次实在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例，但不得不再调用子类型构造函数时重写这些属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Supertype</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name)                   <span class="comment">//调用第二次构造函数，重写SubType原型SuperType中的name和colors属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()              <span class="comment">//调用第一次构造函数</span></span><br><span class="line">SubType.prototype.constructor = SubType</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形成来继承方法。其背后的思路是：不必为了指定子类型的原型而调用超类型的构造函数，所需的无非是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.ptototype)</span><br><span class="line">    prototype.constructor = subType</span><br><span class="line">    subType.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Iversoncurry/Iversoncurry.github.io.git/2019/12/15/%E4%BA%8B%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Iversoncurry.github.io/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Iversoncurry.github.io/2019/12/15/%E4%BA%8B%E4%BB%B6/" class="post-title-link" itemprop="url">事件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-15 20:27:08" itemprop="dateCreated datePublished" datetime="2019-12-15T20:27:08+08:00">2019-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:38:08" itemprop="dateModified" datetime="2020-05-31T10:38:08+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JavaScript与HTML之间的交互是通过事件实现的。<strong>事件，就是文档或浏览器窗口中发生的一些特定交互瞬间。</strong>可以使用侦听器（或处理程序）来订阅事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式。支持页面的行为与页面的外观之间的松散耦合。</p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>IE的事件流叫做事件冒泡（event bubbling），即事件开始时有最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>事件捕获的思想是不太具体的节点更早接收到事件，具体的节点最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。老版本的浏览器对事件捕获不支持。</p>
<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。</p>
<p>在DOM事件流中，实际的目标（<div>元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从document到<html>再到<body>后就停止了。下一个阶段是“处于目标阶段，于是事件在<div>上发生，并在事件处理中被看成冒泡阶段的一部分。然后冒泡阶段发生，事件又传回文档。</p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>事件就是用户或浏览器自身执行的某种动作。诸如click、load和mouseover，都是事件的名字。而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以“on”开头，因此click事件的处理程序就是onclick，load事件的处理程序就是onload。</p>
<h3 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h3><p>某个元素支持的每种事件，都可以使用一个与响应事件处理程序的同名HTML特性来指定。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">onclick</span>=<span class="string">"alert('Click')"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样指定时间处理程序有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"click me"</span> onclick=<span class="string">"alert(event.type)"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>通过event变量，可以直接访问事件对象，不用自己定义它，也不用从函数的参数列表中读取。<br>在这个函数内部，this值等于事件的目标元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(event.type)"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于这个动态函数，在它内部，可以像访问局部变量一样访问document及该元素本身的成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(<span class="built_in">document</span>) &#123;</span><br><span class="line">        <span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 元素属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是由JavaScript底层实现，不需要开发者编写。<br>由此，可以更便利的访问自己的属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(value)"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果当前元素是一个表单输入元素，则作用域中还会包含访问表单元素（父元素）的入口，这个函数就变成了如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(<span class="built_in">document</span>) &#123;</span><br><span class="line">        <span class="keyword">with</span>(<span class="keyword">this</span>.form) &#123;</span><br><span class="line">            <span class="keyword">with</span>(<span class="keyword">this</span>)</span><br><span class="line">            <span class="comment">// 元素属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这样扩展作用域的方式，无非就是想让事件处理程序无需引用表单元素就能访问其他表单字段</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Echo Username"</span> <span class="attr">onclick</span>=<span class="string">"alert(username.value)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不过在HTML中指定事件处理程序有两个缺点。首先，存在一个时间差问题。因为用户可能会在HTML元素已出现在页面上就触发相应的事件，但当时事件处理程序可能不具备执行条件（还没有被解析）<br>另一个缺点是，这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。<br>还有就是导致HTML和JavaScript代码紧密耦合。</p>
<h3 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h3><p>通过JavaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。要使用JavaScript指定事件处理程序，首先必须取得一个要操作的对象引用。<br>每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。这种属性的值设置为一个函数，就可以指定事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bin = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Clicked"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这段代码运行之前不会指定事件处理程序，因此如果这些代码在页面中位于按钮后面，就有可能在一段时间内单击没反应。<br><strong>使用DOM0级方法指定的事件处理程序被认为是元素的方法。</strong>因此，这时候的事件处理程序实在元素的作用域中运行；换句话说，程序中的this引用当前元素。<br>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。<br>也可以删除通过DOM0级方法指定的事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><p>“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。所有DOM节点中都包含这两个方法，并且它们都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。<br>要在按钮上click事件添加事件处理程序如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>同时可以添加多个事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>这里为按钮添加了两个事件处理程序，会按照添加它们的顺序触发。<strong>与DOM0级方法一样，这里添加的事件处理程序也是再其依附的元素的作用域中运行。</strong><br>通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；一出事传入的参数与添加处理程序时使用的参数相同。<strong>这也意味着通过addEventListener()添加的匿名函数将无法移除</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventlisterer(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">//无效</span></span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventlisterer(<span class="string">'click'</span>, handler, <span class="literal">false</span>)   <span class="comment">//有效</span></span><br></pre></td></tr></table></figure>

<h3 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h3><p>IE实现了与DOM中类似的两个方法：attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。attachEvent()添加的事件处理程序都会被添加到事件冒泡阶段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'clicked'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>在IE中使用attachEvent()与使用DOM0级方法的主要区别在于事件处理程序的作用域。在使用attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此this等于window。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span> === <span class="built_in">window</span>)   <span class="comment">//true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>attachEvent()方法也可以用来为一个元素添加多个事件处理程序。但执行顺序与DOM2方法相反。<br>使用attachEvent()添加的事件可以通过detachEvent()来移除，条件是必须提供相同的参数。</p>
<p><strong>跨浏览器的事件处理需要检查浏览器对事件的支持程度（DOM0、DOM2或IE）</strong></p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含这所有与事件有关的信息。包括导致事件的元素，事件的类型以及其他与特定事件相关的信息。所有浏览器都支持event对象，但支持方式不同。</p>
<h3 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h3><p>兼容DOM的浏览器会将一个event对象传入到事件处理程序中国。无论指定时间处理程序时使用什么方法（DOM0级或DOM2级），都会传入event对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.type)   <span class="comment">//click</span></span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.type)   <span class="comment">//click</span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>在通过HTML特定定义事件处理程序是，变量event中保存着event对象。以这种方式提供event对象，可以让HTML特性事件处理程序与JavaScript函数执行相同的操作。<br>要阻止特定事件的默认行为，可以使用preventDefault()方法。例如链接的默认行为就是在被单击是会导航到其href特性指定的URL。如果想阻止连接导航这一默认行为，那么通过链接的onclick事件处理程序可以取消它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">'myLink'</span>)</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。例如，直接添加到一个按钮的事件处理程序可以调用stopPropagation(),从而避免触发注册在document.body上面的事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'clicked'</span>)</span><br><span class="line">    event.stopPropagation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'body clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件对象的eventPhase属性，可以用来确定事件当前正位于事件流的那个阶段。如果是在捕获阶段调用的事件处理程序，那么eventPhase等于1；如果事件处理程序处于目标对象上，则eventPhase等于2；如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。尽管“处于目标”发生在冒泡阶段，但eventPhase仍然一直等于2；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.eventPhase)  <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.eventPhase) <span class="comment">//1</span></span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.eventPhase)   <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h3><p>访问DOM的event对象不同，要访问IE中的event对象有几种不同方式，取决于指定时间处理程序的方法。在使用DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> event = <span class="built_in">window</span>.event</span><br><span class="line">    alert(event.type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果事件处理程序时使用attachEvent()添加的，那么就会有一个event对象作为参数被传入事件处理程序函数中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.type)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用attachEvent()的情况下，也可以通过window对象来访问event对象，就像使用DOM0级方法一样。<br>如果是通过HTML特性指定的事件处理程序，那么可以通过一个名叫event的变量来访问event对象（与DOM中的事件模型相同）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(event.type)"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标。故而，最好还是使用event.srcElement比较保险。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>)  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.srcElement === <span class="keyword">this</span>)       <span class="comment">//false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在第一个事件处理程序中（使用DOM0级方法指定的），srcElement属性等于this，但在第二个事件处理程序中，这两者的值不相同。<br>returnValue属性相当于DOM中的preventDefault()方法，它们的作用都是取消给定事件的默认行为。只要将returnValue设置为false，就可以阻止默认行为。</p>
<h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有时间。例如，click事件会一直冒泡到document层次。也就是说，我们可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</p>
<h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><p>每当事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的JavaScript代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。可以使用事件委托技术，显示建立连接数量。另外，再不需要的时候移除事件处理程序，也是解决这个问题的一种方案。内存中留有那些过时不用的“空事件处理程序”，也是造成Web应用程序内存与性能问题的主要原因。<br>两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有时间处理程序的元素时。可能是通过纯粹的DOM操作，例如使用removeChild()和replaceChild()方法，但更多地是发生在使用innerHTML替换页面中某一部分。如果带有时间处理程序的元素被innerHTML删除了，那么原来添加到元素中的事件处理程序极有可能无法被当做垃圾回收。<br>这种情况下，当知道某个元素即将被移除，手动移除事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn")</span></span><br><span class="line"><span class="string">btn.onclick = function() &#123;</span></span><br><span class="line"><span class="string">    btn.onclick = null</span></span><br><span class="line"><span class="string">    document.getElementById('</span>myDiv<span class="string">').innerHTML = '</span>Processing...<span class="string">'</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>另一种情况就是卸载页面的时候。如果页面卸载之前没有清理干净事件处理程序，那么就会滞留在内存中。每次加载完页面再卸载页面时（可能是在两个页面间来回切换，也可以是单击了刷新按钮）内存中直流的对象数目就会增加，因为事件处理程序占用的内存并没有被释放。<br>这种情况最好的做法是在页面卸载之前，通过onunload事件处理程序移处所有事件处理程序。</p>
<h2 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h2><p>事件，就是网页中某个特别值得关注的瞬间。事件经常由用户操作或通过其他浏览器功能来触发。<br>事实上，可以使用JavaScript在任意时刻来触发特定的事件，而此时的事件就如同浏览器创建的事件一样。也就是所，这些事件通浏览器创建的事件一样可以冒泡，也可以指定事件处理程序。</p>
<h3 id="DOM中的事件模拟"><a href="#DOM中的事件模拟" class="headerlink" title="DOM中的事件模拟"></a>DOM中的事件模拟</h3><p>可以在document对象上使用creatEvent方法创建event对象。这个方法接收一个参数，即表示要创建的事件类型的字符串。在DOM2级中，所有这些字符串都使用英文复数形式，而在DOM3级中都变成了单数。<br>这个字符串可以是下列几个字符串之一。<br>1.UIEvents：一般化UI事件。鼠标事件和键盘事件都继承UI事件。<br>2.MouseEvents：一般化的鼠标事件。<br>3.MutationEvents：一般化的DOM变动事件<br>4.HTMLEvents：一般化的HTML事件 如focus…</p>
<p>模拟事件步骤：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domElement = <span class="built_in">document</span>.getElementById(<span class="string">'someId'</span>)</span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.creatEvent(<span class="string">"MouseEvents"</span>)</span><br><span class="line">event.initMouseEvent(<span class="string">'props...'</span>)  <span class="comment">//不同方法事件参数不一样</span></span><br><span class="line">domElement.dispatchEvent(event)   <span class="comment">//等同于触发了initMouseEvent中type设置的事件</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义DOM事件</strong><br>DOM3级还定义了“自定义事件”。自定义事件不是由DOM原生触发的，它的目的是让开发人员创建自己的事件。要创建新的自定义事件，可以调用createEvent(‘CustomEvent’)。返回的对象有一个名为initCustomEvent()的方法，接收如下4个参数。<br>1.type(字符串)：触发的事件类型，可入“keydown”<br>2.bubble(布尔值)：表示事件是否应该冒泡<br>3.cancelable(布尔值)：表示事件是否可以取消<br>4.detail(对象)：任意值，保存在event对象的detail属性中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"><span class="keyword">var</span> event;</span><br><span class="line">EventUtil.addHandler(div, <span class="string">'myevent'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'div:'</span> + event.detail)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">'myevent'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'document:'</span> + event.detail)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">'CustomEvents'</span>, <span class="string">'3.0'</span>)) &#123;</span><br><span class="line">    event = <span class="built_in">document</span>.createEvent(<span class="string">'CustomEvent'</span>)</span><br><span class="line">    event.initCustomEvent(<span class="string">'myevent'</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">'hello world'</span>)</span><br><span class="line">    div.dispatchEvent(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子创建了一个冒泡事件‘myevent’。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Iversoncurry/Iversoncurry.github.io.git/2019/11/30/%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%97%AD%E5%8C%85%E4%BB%A5%E5%8F%8Athis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Iversoncurry.github.io/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Iversoncurry.github.io/2019/11/30/%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%97%AD%E5%8C%85%E4%BB%A5%E5%8F%8Athis/" class="post-title-link" itemprop="url">作用域、闭包以及this</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-30 14:50:06" itemprop="dateCreated datePublished" datetime="2019-11-30T14:50:06+08:00">2019-11-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-26 11:27:53" itemprop="dateModified" datetime="2020-04-26T11:27:53+08:00">2020-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><p>执行环境（execution context, 有时也成为环境）是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。<strong>每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。</strong><br>全局执行环境是最外层的一个执行环境。根据ECMAScript实现的所在的宿主环境不同，表示执行环境的对象也不一样。在web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境知道应用程序退出————例如关闭网页或浏览器————时才会被销毁）。<br>每个函数都有自己的而执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正事由这个方便的机制控制着。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，时保证对执行换进有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。<strong>如果这个环境是函数，则将其活动对象（activation object）作为变量对象。</strong>活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的<strong>最后一个对象</strong>。<br>标识符解析是沿着作用域链一级一级地搜索标识符地过程。搜索过程始终从作用域链地前端开始，然后逐级地向后回溯，知道找到表示符为止（如果找不到标识符，通常会导致错误发生）。<br><strong>延长作用域链</strong><br>虽然执行环境地类型总共只有两种————全局和局部（函数），但还是有其他办法来演唱作用域链。这么说是因为有些语句可以在作用域链地前端临时增加一个变量对象，该变量对象会在代码执行后被移除。当执行流进入下列任何一个语句时，作用域链就会得到加长：<br>try-catch语句地catch块；<br>with语句<br>这两个语句都会在作用域链地前端添加一个变量对象。对with语句来输欧，会将指定的对象添加到作用域链中。对于catch语句来说，他会创建一个新的变量对象，其中包含的时被抛出的错误对象的声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = <span class="string">'?debug=true'</span></span><br><span class="line">    <span class="keyword">with</span>(localtion) &#123;</span><br><span class="line">        <span class="keyword">var</span> url = href + qs      <span class="comment">//href相当于location.href</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>没有块级作用域</strong><br>JavaScript没有块级作用域。在其他类C语言中，由花括号封闭的代码块都有自己的作用域（如果用ECMAScript的话来讲，就是他们自己的执行环境），<strong>因而支持根据条件来定义变量</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(color)    <span class="comment">//'blue'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ ) &#123;</span><br><span class="line">    doSomething(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)        <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p><strong>声明变量</strong><br>使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。<strong>如果初始化变量时没有使用var声明，该变量会自动添加到全局环境</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum)               <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    sum = num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum)             <span class="comment">//30</span></span><br></pre></td></tr></table></figure>
<p><strong>查询标识符</strong><br>挡在某个环境中为了读取或者写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到改变两名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>尽管通常将JavaScript归类为“动态”或“解释执行”语言，但事实上他是一门编译语言。但与传统的编译语言不通，它不是提前编译的，编译的结果也不能在分布式系统中进行移植。<br>在传统编译语言的流程中，程序的一段源代码在执行之前会经历三个步骤，统称为编译。<br><strong>分词/词法分析（Tokenizing/Lexing)</strong><br>这个过程会将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元（token）。例如，考虑程序var a = 2;。这段程序通常会被分解成下面这些词法单元：var、a、=、2、;。空格是否会被当作词法单元，取决于空额在这门语言中是否具有意义。<br><strong>分词和词法分析之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断a是一个独立的此法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被成为词法分析。</strong><br><strong>解析/语法分析</strong><br>这个过程是将词法单元流（数组）转换成一个铀元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree, AST)。<br>var a = 2; 的抽象语法树中可能会有一个叫作VariableDeclaration的顶级节点，接下来是一个叫做Identifier（它的值是a）的子节点，以及一个叫做AssignmentExpression的子节点。AssignmentExpression节点有一个叫做Numericliteral（它的值是2）的子节点。<br><strong>代码生成</strong><br>将AST转换为可执行代码的过程被车跟为代码生成。这个过程与语言、目标平台等息息相关。简单来说就是有某种方法可以将var a = 2;的AST转化为一组机器指令，用来创建一个叫做a的变量（包括分配内存等），并将一个值存储在a中。</p>
<p>比起那些编译过程中只有三个步骤的语言的编译器，JavaScript引擎要复杂的多。例如在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。<br>首先，JavaScript引擎不会有大量的时间来进行优化，因为与其它语言不同，JavaScript的编译过程不是发生在构建之前的。对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒的时间内。在我们要讨论的作用域背后，JavaScript引擎用了各种办法（比如JIT，可以延迟编译甚至试试重编译）来保证性能最佳。<br>简单地说，任何JavaScript代码片段在执行前都要进行编译。因此JavaScript编译器首先会对var a = 2;这段程序进行编译，然后做好执行它的准备。</p>
<h2 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h2><p>为理解JavaScript的工作原理，需要以下几个概念：<br><strong>引擎</strong><br>从头到尾负责整个JavaScript程序的编译以及执行过程<br><strong>编译器</strong><br>负责语法分析及代码生成<br><strong>作用域</strong><br>负责收集并维护所有声明的标识符（变量）组成一些列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。<br>实例分析，针对程序 var a = 2;<br>对于引擎，上述程序代表两个不同的声明，一个由编译器在编译时处理，另一个由引擎在运行时处理。编译器将这段程序分解成词法单元，然后将词法单元解析成一个树结构。编译器会进行如下处理：<br>1.遇到var a，编译器会询问作用域是否已经有一个改名的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a；<br>2.接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做a的变量。如果时，引擎就会使用这个变量；如果否，引擎就会继续查找该变量。<br>如果引擎最终找到了a变量，就会将2赋值给它。否则引擎就会抛出一个异常。<br>总结：变量的赋值操作会执行两个操作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对其赋值。<br><strong>编译器术语</strong><br>编译器在编译过程的第二步中生成了代码，引擎执行时，会通过查找变量a来判断它是否已经声明过。例子中，引擎会为变量进行LHS查询。<br>当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。RHS查询与简单地查找某个变量地值别无二致，而LHS查询则时视图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS并不是真正意义上的赋值操作的左侧，更准去的说时“非左侧”。<br><strong>异常</strong><br>如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError异常。值得注意的是，ReferenceError 是非常重要的异常类型。相较之下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。ES5 中引入了“严格模式”。同正常模式，或者说宽松 / 懒惰模式相比，严格模式在行为上有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常。接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。<br><strong>ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</strong></p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>大部分标准语言编译器的第一个工作阶段叫作词法化，词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。<strong>简单来说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由在写代码时将变量和块作用域写在那里来决定的，因此当词法分析器处理代码时会保持作用域不变。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();           <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>理解：词法作用域（静态作用域）是由程序所处的位置有关，foo()函数写在全局作用域下，虽然在bar()函数下调用，但由于JavaScript遵循词法作用域，因此foo()函数引用的是全局作用域下的value。<br><strong>欺骗词法</strong><br>JavaSprict中的eval()函数可以接收一个字符串为参数，并将其中的内容是为好像在书写时就存在与程序中这个位置的代码，换句话说，可以在写的代码中用程序生成代码运行，就好像代码是写在那个位置的一样。根据这个原理来理解eval(),它是如何通过代码欺骗和假装成书写时（也就是词法期）代码就在那，来实现修改词法作用域环境的，这个原理就变得清晰易懂了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(str)</span><br><span class="line">    <span class="built_in">console</span>.log(a,b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">foo(<span class="string">'var b = 3'</span>, <span class="number">1</span>)          <span class="comment">//1,3</span></span><br></pre></td></tr></table></figure>
<p>eval()调用中的’var b = 3’这段代码会被当做本来就在那里一样来处理。由于那段代码声明了一个新的变量b，因此它对已经存在的foo()的词法作用域进行了修改，事实上，和前面提到的原理一样，这段代码实际上在foo()内部创建了一个变量b，并遮蔽了外部（全局）作用域中的同名变量。<br><strong>在这个例子中，为了展示的方便和简洁，我们传递进去的“代码”字符串是固定不变的。而在实际情况中，可以非常容易地根据程序逻辑动态地将字符拼接在一起之后再传递进去。eval(..) 通常被用来执行动态创建的代码，因为像例子中这样动态地执行一段固定字符所组成的代码，并没有比直接将代码写在那里更有好处。</strong><br>在严格模式的程序中，eval()在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="built_in">eval</span>(str)</span><br><span class="line">    <span class="built_in">console</span>.log(a)                 <span class="comment">//ReferenceError: a is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">'var a = 2'</span>)</span><br></pre></td></tr></table></figure>
<p>JavaScript中还有其他一些功能效果和eval()很相似。setTimeout()和setInerval()的第一个参数可以是字符串，字符产的内容可以被解释为一段动态生成的函数代码。<br>new Function()函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成的函数的形参）。这种构建函数的语法比eval()略微安全些。<br>with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。<br>尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object1 = &#123;</span><br><span class="line">	a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(object1) &#123;</span><br><span class="line">	<span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br><span class="line"><span class="built_in">console</span>.log(object1.c)</span><br><span class="line"><span class="built_in">console</span>.log(object1.a)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>
<p>eval(..) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。<br>可以这样理解，当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含有一个同 o1.a 属性相符的标识符。但当我们将 o2 作为作用域时，其中并没有 a 标识符，因此进行了正常的 LHS 标识符查找（查看第 1 章）。o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a＝2 执行时，自动创建了一个全局变量（因为是非严格模式）。<br><strong>另外一个不推荐使用 eval(..) 和 with 的原因是会被严格模式所影响（限制）。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用eval(..) 也被禁止了。</strong></p>
<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（<em>事实上在嵌套的作用域中也可以使用</em>）。</p>
<h3 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    b = a + doSomethingElse( a * <span class="number">2</span> );</span><br><span class="line">    <span class="built_in">console</span>.log( b * <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>变量 b 和函数 doSomethingElse(..) 应该是 doSomething(..) 内部具体实现的“私有”内容。给予外部作用域对 b 和 doSomethingElse(..) 的“访问权限”不仅没有必要，而且可能是“危险”的，因为它们可能被有意或无意地以非预期的方式使用，从而导致超出了 doSomething(..) 的适用条件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用隐藏内部实现的思想实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> b;</span><br><span class="line">    b = a + doSomethingElse( a * <span class="number">2</span> );</span><br><span class="line">    <span class="built_in">console</span>.log( b * <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>现在，b 和 doSomethingElse(..) 都无法从外部被访问，而只能被 doSomething(..) 所控制。功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会依此进行实现。</p>
<h2 id="规避冲突"><a href="#规避冲突" class="headerlink" title="规避冲突"></a>规避冲突</h2><p>“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        i = <span class="number">3</span>; <span class="comment">// 修改 for 循环所属作用域中的 i</span></span><br><span class="line">        <span class="built_in">console</span>.log( a + i );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        bar( i * <span class="number">2</span> ); <span class="comment">// 糟糕，无限循环了！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">3</span>; <span class="comment">// 修改 for 循环所属作用域中的 i</span></span><br><span class="line">        <span class="built_in">console</span>.log( a + i );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        bar( i * <span class="number">2</span> ); <span class="comment">// 糟糕，无限循环了！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p><strong>全局命名空间</strong><br>变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。<br>这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属<br>性，而不是将自己的标识符暴漏在顶级的词法作用域中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyReallyCoolLibrary = &#123;</span><br><span class="line">    awesome: <span class="string">"stuff"</span>,</span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    doAnotherThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模块管理</strong><br>另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。<br>显而易见，这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。</p>
<h3 id="函数作用域-1"><a href="#函数作用域-1" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>利用函数作用域可以对变量和函数进行隐藏，但仍存在需要为函数命名以及函数运行的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">// &lt;-- 添加这一行</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">&#125;)(); <span class="comment">// &lt;-- 以及这一行</span></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。</p>
<h3 id="匿名和具名"><a href="#匿名和具名" class="headerlink" title="匿名和具名"></a>匿名和具名</h3><p>对于函数表达式最首席的场景就是回调参数了，比如： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I waited 1 second!'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>这叫做匿名函数表达式，因为function()没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名。<br>匿名函数的缺点如下：<br>1.匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。<br>2.如果没有函数名，当函数需要应用自身时只能使用已经过期的arguments.callee引用，比如在递归中，另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。<br>3.匿名函数省略了对于代码可读性/可理解性很重要的函数名。<br><strong>行内函数表达式</strong>非常强大且有用————匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timeoutHandler</span>(<span class="params"></span>) </span>&#123; <span class="comment">// &lt;-- 快看，我有名字了！</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"I waited 1 second!"</span> )</span><br><span class="line">&#125;, <span class="number">1000</span> )</span><br></pre></td></tr></table></figure>
<h3 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个() 可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表<br>达式，第二个 ( ) 执行了这个函数。这种模式很常见，几年前社区给它规定了一个术语：IIFE，代表立即执行函数表达式（Immediately Invoked Function Expression）；<br>函数名对 IIFE 当然不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的 IIFE 并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>我们将 window 对象的引用传递进去，但将参数命名为 global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字。这对于改进代码风格是非常有帮助的。<br>这个模式的另外一个应用场景是解决undefined标识符的默认值被错误覆盖导致的异常。将一个参数命名为undefined，但是在对应的场景不传入任何值，这样就可以保证代码块中undefined标识符的值真的是undefined；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> = <span class="literal">true</span>           <span class="comment">//错误的</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">undefined</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a</span><br><span class="line">    <span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'undefined is safe here'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上述代码运行不通，这段代码要表达的意思是当undefined被错误赋值时，通过定义一个不传入参数的形参（undefined）来保证代码块中的undefined（此处为数据类型）是JavaScript中原始定义的undefined，保证代码安全。<br>IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去。这种模式在 UMD（Universal Module Definition）项目中被广泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> def </span>) </span>&#123;</span><br><span class="line">    def( <span class="built_in">window</span> )</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"> global </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">    <span class="built_in">console</span>.log( a ) <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">console</span>.log( global.a) <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>函数表达式 def 定义在片段的第二部分，然后当作参数（这个参数也叫作 def）被传递进IIFE 函数定义的第一部分中。最后，参数 def（也就是传递进去的函数）被调用，并将window 传入当作 global 参数的值。</p>
<h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><p>除 JavaScript 外的很多编程语言都支持块作用域，因此其他语言的开发者对于相关的思维方式会很熟悉，但是对于主要使用 JavaScript 的开发者来说，这个概念会很陌生。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( i )</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)             <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<h3 id="ES6中提供块级声明"><a href="#ES6中提供块级声明" class="headerlink" title="ES6中提供块级声明"></a>ES6中提供块级声明</h3><p>块级声明也就是让所声明的变量在指定块的作用域外无法被访问。块级作用域（又被称为词法作用域）在如下情况被创建：</p>
<ol>
<li>在一个函数内部</li>
<li>在一个代码块（由一对花括号包裹）内部</li>
</ol>
<p><strong>let声明</strong><br>let可以将变量限制在当前代码块中，语法和var的一致，几乎可以利用let对var进行替代。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)              <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>但let声明并不会尽进行提升</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>                  <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>同时禁止重复声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分节</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>let能为垃圾收集提供帮助，考虑如下代码（现在考虑不明白，等看完闭包回来总结😂）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 在这里做点有趣的事情</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someReallyBigData = &#123; .. &#125;;</span><br><span class="line">process( someReallyBigData );</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">"my_button"</span> );</span><br><span class="line">btn.addEventListener( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"button clicked"</span>);</span><br><span class="line">&#125;, <span class="comment">/*capturingPhase=*/</span><span class="literal">false</span> );</span><br></pre></td></tr></table></figure>
<p>click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构（取决于具体实现）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 在这里做点有趣的事情</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这个块中定义的内容可以销毁了！</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> someReallyBigData = &#123; .. &#125;;</span><br><span class="line">    process( someReallyBigData );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">"my_button"</span> );</span><br><span class="line">btn.addEventListener( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"button clicked"</span>);</span><br><span class="line">&#125;, <span class="comment">/*capturingPhase=*/</span><span class="literal">false</span> );</span><br></pre></td></tr></table></figure>

<p><strong>常量声明</strong><br>在ES6中也可以使用const语法进行声明。使用const声明的变量会被认为是常量（constant），意味着他们的值在被设置完成后就不能再被改变。因此所有的const变量都需要在声明时进行初始化。<br>常量声明与 let 声明一样，都是块级声明。这意味着常量在声明它们的语句块外部是无法访问的，并且声明也不会被提升，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">const</span> maxItems = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(maxItems)                 <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>与 let 的另一个相似之处，是 const 声明会在同一作用域（全局或是函数作用域）内定义一个已有变量时会抛出错误，无论是该变量此前是用 var 声明的，还是用 let 声明的。例如以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'007'</span></span><br><span class="line"><span class="comment">// 三者均会抛出错误</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">"Goodbye!"</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'008'</span></span><br></pre></td></tr></table></figure>
<p><strong>使用const声明对象</strong><br>const 声明会阻止对于变量绑定与变量自身值的修改，这意味着 const 声明并不会阻止对变量成员的修改。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Nicholas'</span>,</span><br><span class="line">&#125;</span><br><span class="line">person.name = <span class="string">'daming'</span>                  <span class="comment">//可以正常赋值</span></span><br><span class="line">person = &#123;</span><br><span class="line">    name: <span class="string">'daming'</span></span><br><span class="line">&#125;                                       <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p><strong>只需记住： const 阻止的是对于变量绑定的修改，而不阻止对成员值的修改。</strong><br><strong>循环内的函数</strong><br>为实现输出1到9，考虑一下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环内使用var实现</span></span><br><span class="line"><span class="keyword">var</span> funcs = []</span><br><span class="line"><span class="keyword">for</span> （<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func()                                  <span class="comment">//输出数值'10'十次</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 由于输出函数并未立即执行，当通过数组调用时，输出函数输出的是对变量i的引用，此时i为10，因此输出10十次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push((<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(i)))</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func()                              <span class="comment">//输出0-9</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//利用IIFE，变量i传递给匿名函数时被立即执行，创建了value变量作为i的副本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func(); <span class="comment">// 从 0 到 9 依次输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>全局块级绑定</strong><br>let和const不同于var的另一个方面时在全局作用域上的表现。当全局作用于上使用var时，它会创建一个新的全局变量，并成为全局对象（浏览器中时window）的一个属性。这意味着var使用var可能会无意中覆盖一个已有的全局属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">RegExp</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp)               <span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ncz = <span class="string">'hi'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.ncz)                 <span class="comment">//hi</span></span><br></pre></td></tr></table></figure>
<p>若在全局作用域上使用let或const，虽然在全局作用域上会创建新的绑定，但不会有任何属性被添加到全局对象上。这就意味着不能使用let或const来<em>覆盖<em>一个全局变量，只能将其</em>屏蔽</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">RegExp</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>)                              <span class="comment">//hello</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp === <span class="built_in">RegExp</span>)            <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ncz = <span class="string">'hi'</span></span><br><span class="line"><span class="built_in">console</span>.log(ncz)                                 <span class="comment">//hi</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ncz'</span> <span class="keyword">in</span> <span class="built_in">window</span>)                     <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将附属于这个作用域。<br>考虑如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a)            <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>由于在JavaScript中，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。对于 var a = 2, JavaScript会将器堪称两个声明：var a和a = 2,第一个定义声明式在编译阶段进行的，第二个赋值声明会被<em>留在原地</em>等待执行阶段。<br>对于上面的代码，会被做如下处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>
<p>其中第一部分式编译，第二部分是执行。考虑另外一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)        <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b)        <span class="comment">//ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>
<p>总结来说，这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。对于函数，也存在变量提升：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)        <span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码经编译器处理后可以看作如下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a</span><br><span class="line">    <span class="built_in">console</span>.log(a)         <span class="comment">//undefined</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>可以看到，函数声明会被提升，但函数表达式却不会被提升。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo()             <span class="comment">//不是ReferenceError，而是TypeError</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    // ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>理解：这段程序中的变量标识符foo()被提升并分配给所在作用域（在这里是全局作用域），因此foo()不会导致ReferenceError。但是foo此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值）。foo()由于对undefined值进行函数调用而导致非法操作，因此抛出TypeError异常。<br>同时要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo()        <span class="comment">//TypeError</span></span><br><span class="line">bar()        <span class="comment">//ReferenceError</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码会出现上述运行情况是经过提升后，会被理解为以下形式：</span></span><br><span class="line"><span class="keyword">var</span> foo</span><br><span class="line">foo()             <span class="comment">//TypeError</span></span><br><span class="line">bar()             <span class="comment">//ReferenceError</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar = ...self...</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h3><p>函数声明和变量声明都会被提升，但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数回首先被提升，然后才是变量。<br>考虑以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo()             <span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> foo</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会输出1而不是2，这个代码片段会被引擎理解为如下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo()              <span class="comment">//</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo()                <span class="comment">//1     变量和函数提升，函数表达式没有提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo()             <span class="comment">//b</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'a'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，再块内部声明函数并不可靠，要避免。</p>
<h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><p><strong>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。</strong><br>闭包概念：<strong>当一个内部函数被调用，就会形成闭包，闭包就是能够读取其他函数内部变量的函数，定义在一个函数内部的函，创建一个闭包环境，让返回的这个子程序抓住i，以便在后续执行时可以保持对这个i的引用。内部函数比外部函数有更长的生命周期；函数可以访问它被创建时所处的上下文环境。</strong><br>考虑以下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo()</span><br><span class="line">baz();      <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。<br>考虑如下程序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getNum;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> n++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNum = getCounter();</span><br><span class="line"><span class="built_in">console</span>.log(getNum());</span><br><span class="line"><span class="built_in">console</span>.log(getNum());</span><br><span class="line"></span><br><span class="line"><span class="comment">// dsadS</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line">　　nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　alert(n);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result=f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br><span class="line">nAdd();</span><br><span class="line">result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>
<p>分析如下循环代码，理解闭包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;), i*<span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码预期是分别输出数字1-5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出5次6。<br>这段代码的缺陷在于，我们假设循环中的每个迭代在运行时会给自己“捕获”一个i副本。但是根据作用域的工作原理，实际情况时尽管循环中的5个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。循环的终止条件为i&gt;5，条件首次成立时i的值是6。<br>换一种方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;, i*<span class="number">1000</span>)</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用IIFE会通过声明并立即执行一个函数来创建作用域，但同样不能实现设想的输出，因为i并不在IIFE生成的作用域中，导致函数引用的i仍旧为全局作用域中的i。本质上这是将一个块转换成一个可以被关闭的作用域。<br>再换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> j = i</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j)</span><br><span class="line">        &#125;, i*<span class="number">1000</span>)</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再换一种方式，结合块作用域和闭包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更简便的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, i*<span class="number">1000</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>利用闭包实现模块，考虑如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">'cool'</span></span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(something)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(another.join(<span class="string">'i'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如这段代码中显示的，这里并没有明显的闭包，只有两个私有数据变量something和another，以及doSomething()和doAnother()两个内部函数，它们的词法作用域（而就是闭包）也就是foo()的内部作用域。<br>考虑一下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">'cool'</span></span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(something)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(another.join(<span class="string">'!'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = CoolModule()</span><br><span class="line">foo.doSomething()       <span class="comment">//cool</span></span><br><span class="line">foo.doAnother()         <span class="comment">//1!2!3</span></span><br></pre></td></tr></table></figure>
<p>这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。<br>首先，CoolModule()只是一个函数，必须通过调用来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。其次，CoolModule()返回一个用对象字面量语法{key: value}来表示的对象。这个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公开API。<br><em>从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函数。jQuery 就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery 模块的公共 API，但它们本身都是函数（由于函数也是对象，它们本身也可以拥有属性）。</em><br>如果要更简单的描述，模块模式需要具备两个必要条件。</p>
<ol>
<li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ol>
<p>上一个示例代码中有一个叫作 CoolModule() 的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的<br>改进来实现单例模式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">"cool"</span></span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( something )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( another.join( <span class="string">" ! "</span> ) )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    doSomething: doSomething,</span><br><span class="line">    doAnother: doAnother</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>
<p>模块也是普通的函数，因此可以接受参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( id )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        identify: identify</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo1 = CoolModule( <span class="string">"foo 1"</span> )</span><br><span class="line"><span class="keyword">var</span> foo2 = CoolModule( <span class="string">"foo 2"</span> )</span><br><span class="line">foo1.identify(); <span class="comment">// "foo 1"</span></span><br><span class="line">foo2.identify(); <span class="comment">// "foo 2"</span></span><br></pre></td></tr></table></figure>
<p>模块模式另一个简单但强大的变化用法是，命名将要作为公共 API 返回的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 修改公共 API</span></span><br><span class="line">        publicAPI.identify = identify2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">identify1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( id )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">identify2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( id.toUpperCase() )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> publicAPI = &#123;</span><br><span class="line">        change: change,</span><br><span class="line">        identify: identify1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> publicAPI;</span><br><span class="line">&#125;)( <span class="string">"foo module"</span> );</span><br><span class="line">foo.identify(); <span class="comment">// foo module</span></span><br><span class="line">foo.change();</span><br><span class="line">foo.identify(); <span class="comment">// FOO MODULE</span></span><br></pre></td></tr></table></figure>
<p>通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p>
<p>现代模块机制<br>大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。这里并不会研究某个具体的库，为了宏观了解我会简单地介绍一些核心概念：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> modules = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class="line">            deps[i] = modules[deps[i]]</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name] = impl.apply(impl, deps)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modules[name]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        define: define,</span><br><span class="line">        <span class="keyword">get</span>: <span class="keyword">get</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h3 id="未来模块机制"><a href="#未来模块机制" class="headerlink" title="未来模块机制"></a>未来模块机制</h3><p><strong><em>待整理</em></strong></p>
<h2 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h2><h3 id="调用位置（存疑）"><a href="#调用位置（存疑）" class="headerlink" title="调用位置（存疑）"></a>调用位置（存疑）</h3><p><strong>以下书中所述和实际测试不符，利用var a = 2声明变量无法使a成为全局对象的属性</strong><br>调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回到这个问题：这个this到底引用的是什么。<br>通常来说，寻找调用位置就是寻找“函数被调用的位置”， 但是做起来并没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。<br>最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就是在当前正在执行的函数的前一个调用中。<br>下面从一个例子中分析什么是调用栈和调用位置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是baz</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置是全局作用域</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'baz'</span>)</span><br><span class="line">    bar()  <span class="comment">//&lt;-- bar的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是baz-&gt;bar</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在baz中</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">    foo() <span class="comment">//&lt;-- foo的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是baz-&gt;bar-&gt;foo</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在bar中</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line">baz()      <span class="comment">//&lt;-- baz的调用位置</span></span><br></pre></td></tr></table></figure>
<h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则是的默认规则。<br>考虑以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo()   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>声明在全局作用域中的变量（比如var a = 2）就是全局对象的一个同名属性。它们本质上就是同一个东西，并不是通过复制得到的。<br>分析调用位置，foo()是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定。<br>如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定到undefined：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">foo() <span class="comment">//TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>
<p>这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只<br>有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象；严格模式下与 foo()<br>的调用位置无关：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line">    foo() <span class="comment">// undefined</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能造成一些误解<br>考虑如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo() <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span>,</span><br><span class="line">	foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br></pre></td></tr></table></figure>
<p>当foo()被调用时，它的落脚点确实指向obj对象。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。因为调用foo()时this被绑定到obj，因此this.a和obj.a是一样的<br>**对象属性引用链中只有最顶层（最后一层）会影响调用位置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">42</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    obj2: obj2</span><br><span class="line">&#125;</span><br><span class="line">obj1.obj2.foo()  <span class="comment">//42</span></span><br></pre></td></tr></table></figure>
<p><strong>隐式丢失</strong><br>一个最常见的this绑定问题就是被饮食绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上（取决于是否是严格模式）<br>考虑以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'oops, global'</span></span><br><span class="line">bar()       <span class="comment">//oops, global(sublime测试输出为undefined)</span></span><br></pre></td></tr></table></figure>
<p>虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dooFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// fn其实引用的是foo</span></span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'oops, global'</span></span><br><span class="line">doFoo(obj.foo) <span class="comment">//'oops, global</span></span><br></pre></td></tr></table></figure>
<p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span></span><br><span class="line">setTimeout(obj.foo,<span class="number">100</span>)  <span class="comment">//oops,global</span></span><br></pre></td></tr></table></figure>
<h4 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h4><p>利用call和apply方法对this进行显示绑定，它们的第一个参数是一个对象，它们会把这个对象绑定到this，接着在调用函数时指定这个 this。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj)   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。<br>如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者new Number(..)）。这通常被称为“装箱”。<br><strong>从 this 绑定的角度来说，call(..) 和 apply(..) 是一样的，它们的区别体现在其他的参数上</strong><br><strong>硬绑定</strong><br>考虑以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo.call( obj )</span><br><span class="line">&#125;</span><br><span class="line">bar() <span class="comment">// 2</span></span><br><span class="line">setTimeout( bar, <span class="number">100</span> ) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 硬绑定的 bar 不可能再修改它的 this</span></span><br><span class="line">bar.call( <span class="built_in">window</span> ) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>创建了函数 bar()，并在它的内部手动调用了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。<br>硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>)      <span class="comment">//2, 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b)      <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>另一种使用方法是创建一个可以重复使用的辅助函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + something</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单的辅助绑定函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = bind(foo, obj)</span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>)       <span class="comment">//2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b)       <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>由于硬绑定是一种非常常用的模式，所以在ES5中提供了内置的方法Function.prototype.bind，它的用法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj)</span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>)        <span class="comment">//2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b)        <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>bind()会返回一个硬绑定的新韩淑，他会把参数设置为this的上下文并调用原始函数。<br><strong>API调用的“上下文”</strong><br>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一<br>个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调<br>函数使用指定的 this。<br>举例来说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( el, <span class="keyword">this</span>.id );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="string">"awesome"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用 foo(..) 时把 this 绑定到 obj</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj );</span><br><span class="line"><span class="comment">// 1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure>
<p>这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些代码。</p>
<h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><p>在传统的面向对象的语言中，“构造函数”是类中的一些特殊方法，使用new初始化类是会调用类中的构造函数，通常的形式是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">something = <span class="keyword">new</span> MyClass()</span><br></pre></td></tr></table></figure>
<p>JavaScript也有一个new操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开发者人为JavaScript中new的机制也和那些语言一样，然而，JavaScript中new的机制实际上和面向类的语言完全不同。<br>首先重定义一下JavaScript中的“构造函数”。在JavaScript中，构造函数<strong>只是一些使用new操作符时被调用的函数</strong>。它们不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被new操作符调用的普通函数而已。<br>举例来说，Number()作为构造函数时的行为，ES5.1中这样描述：<br>当Number在new表达式中被调用时，它是一个构造函数：它会初始化新创建的对象<br>所以，包括内置对象函数（比如Number()）在内的所有函数都可以用new来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区别：<strong>实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</strong><br>使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作<br>1.创建（或者说构造）一个全新的对象<br>2.这个新对象会被执行[[原型]]连接<br>3.这个新对象会被绑定到函数调用的this<br>4.如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。<br>思考下面代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bar.a)    <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p><strong>使用new来调用foo()时，我们会构造一个新对象并把它绑定到foo()调用中的this上。new是最后一种可以影响函数调用时this绑定行为的方法，我们称之为new绑定。</strong></p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>考虑如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj1.foo()   <span class="comment">//2</span></span><br><span class="line">obj2.foo()   <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2)    <span class="comment">//3</span></span><br><span class="line">obj2.foo.call(obj1)    <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>由此看到，显示绑定优先级更高，也就是说在判断时应当优先考虑是否可以应用显示绑定<br>接下来考虑new绑定和隐式绑定的优先级谁高谁低</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj1.foo(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a)   <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj2.a)   <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.foo(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a)     <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.a)      <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>可以看到 new 绑定比隐式绑定优先级高。<br>考虑如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.a = something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj1)</span><br><span class="line">bar(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a)   <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a)   <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(baz.a)    <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>事实上，new并没有改变obj1的a，二是修改了硬绑定（到obj1的）调用bar()中的this<br><strong>判断this</strong><br>可以根据优先级来判断函数在某个调用位置应用的是那条规则。按下面的顺序来进行判断：<br>1.函数是否在new中调用（new绑定）。如果时的话，this绑定的是新创建的对象。<br>var bar = new foo()<br>2.函数是否通过call、apply（显示绑定）或者硬绑定调用。如果是的话，this绑定的是指定的对象。<br>var bar = foo.bind(obj2)<br>3.函数是否在某个上下文对象中调用（隐式绑定）。如果是的话，this绑定的是那个上下文对象。<br>var bar = obj1.foo<br>4.如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。<br>var bar = foo</p>
<h3 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h3><p>当把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">foo.call(<span class="literal">null</span>)  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>传入null的情景：<br>一种非常常见的做法是使用apply()来“展开”一个数组，并当作参数传入一个函数。类似的，bind()可以对参数进行柯里化（预先设置一些参数）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把数组“展开”成参数</span></span><br><span class="line">foo.apply(<span class="literal">null</span>, [<span class="number">2</span>,<span class="number">3</span>])  <span class="comment">//a:2,b:3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用bind()进行柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">bar(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>这两种方法都需要传入一个参数当作 this 的绑定对象。如果函数并不关心 this 的话，仍然需要传入一个占位值，这时 null 可能是一个不错的选择，就像代码所示的那样。<br>在 ES6 中，可以用 … 操作符代替 apply(..) 来“展开”数组，foo(…[1,2]) 和 foo(1,2) 是一样的，这样可以避免不必要的this 绑定。可惜，在 ES6 中没有柯里化的相关语法，因此还是需要使用bind(..)。</p>
<p>然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了this（比如第三方库中的一个函数），那默认绑定规则会把 this 绑定到全局对象（在浏览器中这个对象是 window），这将导致不可预计的后果（比如修改全局对象）。显而易见，这种方式可能会导致许多难以分析和追踪的 bug。<br><strong>更安全的this</strong><br>一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序产生任何副作用。就像网络（以及军队）一样，我们可以创建一个“DMZ”（demilitarized<br>zone，非军事区）对象——它就是一个空的非委托的对象（委托在第 5 章和第 6 章介绍）。如果我们在忽略 this 绑定时总是传入一个 DMZ 对象，那就什么都不用担心了，因为任何对于 this 的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)。Object.create(null) 和 {} 很 像， 但 是 并 不 会 创 建 Object.prototype 这个委托，所以它比 {}“更空”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们的 DMZ 空对象</span></span><br><span class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create( <span class="literal">null</span> );</span><br><span class="line"><span class="comment">// 把数组展开成参数</span></span><br><span class="line">foo.apply( ø, [<span class="number">2</span>, <span class="number">3</span>] ); <span class="comment">// a:2, b:3</span></span><br><span class="line"><span class="comment">// 使用 bind(..) 进行柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( ø, <span class="number">2</span> );</span><br><span class="line">bar( <span class="number">3</span> ); <span class="comment">// a:2, b:3</span></span><br></pre></td></tr></table></figure>
<p>使用变量名 ø 不仅让函数变得更加“安全”，而且可以提高代码的可读性，因为 ø 表示“我希望 this 是空”，这比 null 的含义更清楚。不过再说一遍，你可以用任何喜欢的名字<br>来命名 DMZ 对象。</p>
<h4 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h4><p>另一个需要注意的是，有可能创建一个“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。<br>间接引用最容易发生在赋值时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a: <span class="number">3</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    a: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.foo()    <span class="comment">//3</span></span><br><span class="line">(p.foo = o.foo)()  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。<br>注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则this 会被绑定到全局对象。</p>
<h4 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h4><p>硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。<br>如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。<br>可以通过一种被称为软绑定的方法来实现我们想要的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Function</span>.prototype.softBind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="keyword">this</span></span><br><span class="line">        <span class="comment">// 捕获所有curried参数</span></span><br><span class="line">        <span class="keyword">var</span> curried = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(</span><br><span class="line">                (!<span class="keyword">this</span> || <span class="keyword">this</span> === (<span class="built_in">window</span> || global))?</span><br><span class="line">                    obj : <span class="keyword">this</span></span><br><span class="line">                curried.concat.apply(curried, <span class="built_in">arguments</span>)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        bound.prototype = <span class="built_in">Object</span>.create(fn.prototope)</span><br><span class="line">        <span class="keyword">return</span> bound</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了软绑定之外，softBind(..) 的其他原理和 ES5 内置的 bind(..) 类似。它会对指定的函数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"name: "</span> + <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'obj'</span>&#125;,</span><br><span class="line">    obj2 = &#123;<span class="attr">name</span>: <span class="string">'obj2'</span>&#125;</span><br><span class="line">    obj3 = &#123;<span class="attr">name</span>: <span class="string">'obj3'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> fooOBJ = foo.softBind(obj)</span><br><span class="line">fooOBJ()    <span class="comment">//name: obj</span></span><br><span class="line">obj2.foo = foo.softBind(obj)</span><br><span class="line">obj2.foo()         <span class="comment">//name: obj2</span></span><br><span class="line">fooOBJ.call(obj3)  <span class="comment">//name: obj3</span></span><br><span class="line">setTimeout(obj2.foo, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// name: obj</span></span><br></pre></td></tr></table></figure>
<p>可以看到，软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默认绑定，则会将 this 绑定到 obj。</p>
<h3 id="this词法-1"><a href="#this词法-1" class="headerlink" title="this词法"></a>this词法</h3><p>之前介绍的四条规则已经可以包含所有正常的函数。但是ES6中介绍了一种无法使用这些规则的特殊函数类型：箭头函数<br>箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// this继承自foo()</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj1)</span><br><span class="line">bar.call(obj2)         <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1，bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。（new 也不行！）<br>箭头函数最常用于回调函数中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的this在词法上继承自foo()</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj)   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(self.a)</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj)    <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// var self = this</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj)    <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Iversoncurry/Iversoncurry.github.io.git/2019/11/02/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Iversoncurry.github.io/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Iversoncurry.github.io/2019/11/02/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">引用类型之数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-02 20:27:08" itemprop="dateCreated datePublished" datetime="2019-11-02T20:27:08+08:00">2019-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:38:16" itemprop="dateModified" datetime="2020-05-31T10:38:16+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>除Object之外，Array类型是ECMAScript中最常用的类型，与其他语言不同，数组中可以保存任何类型的数据；同时数组大小可以随意调整，不同于java，当数组长度确定时不能再进行改变；Array 存储的对象能动态增多和减少，并且可以存储任何JavaScript值。</p>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>1.利用Array构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(args)</span><br></pre></td></tr></table></figure>
<p>其中args可以为空，也可以为一个数值或是字符串，当为数值时，生成一个长度为该数值的数组，当为字符串时，生成一个含有该字符串的数组；其中，new可以省略<br>2.利用数组字面量表示法进行创建</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>]</span><br></pre></td></tr></table></figure>
<p>其中数组中最后一项不要为逗号，如为逗号将产生一个长度不定的数组</p>
<h2 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h2><p>在读取和设置数组的值时，利用方括号并提供相应的数字索引，数字索引是从0开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])</span><br><span class="line">colors[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>通过length属性可以获取数组长度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">23</span>]</span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br></pre></td></tr></table></figure>
<p>对数组的length进行设置时，会改变数组项数，当设置的length大于数组实际长度时，超过的数组位置为undefined，当设置的length小于数组实际长度时，多余的数组会被移除</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">23</span>]</span><br><span class="line">colors.length = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>])</span><br><span class="line">colors.length = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>由此可以利用length属性实现数组的栈方法（构想，还没写😁）</p>
<h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><p>对于同一个网页或者一个全局作用域而言，利用instanceof操作符可以实现数组的检测</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)</span><br></pre></td></tr></table></figure>
<p>但如果网页中包含多个框架，导致存在两个及以上不同全局执行环境，从而导致多个不同版本的Array构造函数，instanceof方法将失效，此时可以利用Array.isArray()方法，该方法是最终确定一个值是否是数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value))</span><br></pre></td></tr></table></figure>

<h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><p>所有对象都有toLocaleString(), toString(), valueOf()方法。其中调用数组的toString()会返回有数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串（调用数组每一项的toString()方法；而调用valueOf()，返回的是数组；toLocaleString()方法调用每一项的toLocaleString()方法，对于alert方法，当其参数为数组时，会先调用数组的toString()方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(color.toString())</span><br><span class="line"><span class="built_in">console</span>.log(color.valueOf())</span><br></pre></td></tr></table></figure>
<p>通过调用数组的join()方法，传入分隔符参数，更改分隔符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(color.join(<span class="string">"||"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p>数组的push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改数组长度；pop()方法从数组末尾移除最后一项，减少数组的length，然后返回移除的项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">var</span> count = color.push(<span class="string">'yellow'</span>, <span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count)</span><br><span class="line">myColor = color.pop()</span><br><span class="line"><span class="built_in">console</span>.log(myColor)</span><br></pre></td></tr></table></figure>

<h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><p>与栈方法相比，队列方法将pop()方法变为shift()方法，该方法移除数组第一项并返回该项，push()方法与栈方法相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">myColor = color.shift()</span><br><span class="line"><span class="built_in">console</span>.log(myColor)</span><br></pre></td></tr></table></figure>

<h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2><p>数组有两个可以直接用来重排序的方法，reverse()和sort()方法。<br>reverse()方法将数组进行倒排</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">values.reverse()</span><br><span class="line"><span class="built_in">console</span>.log(values)</span><br></pre></td></tr></table></figure>
<p>sort()方法默认按升序排列数组，为实现排序，sort()方法会调用每个数组项的toString()方法，然后比较字符串，即使数组里每一项都是数值，sort()方法比较的也是字符串。但有些情况下，通过字符串比较会出现错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>]</span><br><span class="line">values.sort()</span><br><span class="line"><span class="built_in">console</span>.log(values) <span class="comment">//0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
<p>可通过给sort()函数传递一个比较函数作为参数（升序）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>]</span><br><span class="line">values.sort(compare)</span><br><span class="line"><span class="built_in">console</span>.log(values) <span class="comment">//0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
<p>当数组元素为数值类型或其valueOf方法会返回数值类型对象时比较函数可简化为（升序）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value2 - value1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：reverse()和sort()方法都是对原始数组进行修改</p>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。当concat()方法不传入参数时，只是对原数组进行复制并返回副本；当传入参数为一个或多个数组该方法将每个数组的每一项都添加到结果数组中；如果传入的参数不是数组，则值将会被简单添加到结果数组的末尾。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">var</span> color2 = colors.concat(<span class="string">'yellow'</span>, [<span class="string">'black'</span>, <span class="string">'brown'</span>])</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(color2)</span><br></pre></td></tr></table></figure>
<p>注意concat()方法不改变原始数组。<br>slice()方法能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一个或两个参数，即要返回项的起始和结束位置；若slice()方法只传递一个参数，则返回从该参数指定位置看是到当前数组末尾的所有项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>, <span class="string">'black'</span>, <span class="string">'brown'</span>]</span><br><span class="line"><span class="keyword">var</span> color2 = colors.slice(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> color3 = colors.slice(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(color2)</span><br><span class="line"><span class="built_in">console</span>.log(color3)</span><br></pre></td></tr></table></figure>
<p>注意slice()方法不改变原始数组。<br>splice()方法主要用途时向数组中部插入项：<br>1.删除：可以删除任意数量的的项，需指定2个参数：要删除的第一项的位置和要删除的项数；<br>2.插入：可以向指定位置插入任意数量的项，需提供3个参数：起始位置、0（要删除的项）和要插入的项。最后一个参数可以为任意多项<br>3.替换：可以项指定位置插入任意数量的项，且同时删除任意数量的项，需指定3个参数：其实位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。<br>splice()方法始终返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">var</span> removed = color.splice(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(removed)</span><br><span class="line"></span><br><span class="line">removed = color.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">'yellow'</span>,<span class="string">'orange'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(removed)</span><br><span class="line"></span><br><span class="line">removed = color.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'red'</span>, <span class="string">'purple'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(color)</span><br><span class="line"><span class="built_in">console</span>.log(removed)</span><br></pre></td></tr></table></figure>
<p>splice()方法改变原数组</p>
<h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><p>数组实例有两个位置方法：indexOf()和lastIndexOf()。这两个方法都接收两个参数，要查找的项和表示查找起点位置的索引（可选）。其中，indexOf()方法从起点位置从前向后查找，lastIndexOf()方法从起始点从后向前查找，两个方法返回要查找项在数组中的位置。如果要查找项不在数组中则返回-1.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(number.indexOf(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(number.lastIndexOf(<span class="number">4</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>ECMAScript5为数组定义了5个迭代方法，每个方法接受两个参数：要在每一项上运行的函数和运行该函数的作用域对象—-影响this的值。传入这些方法的函数接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。<br>1.every(): 对数组中的每一项运行给定函数，如果该函数对每一项都返回true则返回true；(当找到不满足条件的项时停止迭代)(不改变原数组)<br>2.filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组；(不改变原数组)<br>3.forEach(): 对数组中的每一项运行给定函数。这个方法没有返回值；本质上与for循环迭代数组一样。 (不改变原数组)<br>4.map(): 对数组中的每一项运行给定函数，返回每次函数调用结果组成的数组；(不改变原数组)<br>5.some(): 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。(当找到满足条件的项时停止迭代) (不改变原数组)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> everyResult = number.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> someResult = number.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> filterResult = number.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> mapResult = number.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line">number.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">	number[index] = item*<span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="缩小方法"><a href="#缩小方法" class="headerlink" title="缩小方法"></a>缩小方法</h2><p>reduce()和reduceRight()方法为两个缩小数组方法，这两个方法都会迭代数组的所有项，其中reduce()方法从数组的第一项开始，逐个遍历到最后；而reduceRight()则从数组的最后一项开始，向前遍历到第一项。这连个方法都接收两个参数：一个在每一项上调用的函数和作为缩小基础的初始值（可选）。串给reduce()和reduceRight()函数接收4个参数：前一个值，当前值，想的索引和数组对象，函数返回的任何值都会作为第一个参数自动传给下一项，第一次迭代发生在数组的第二项上，因此第一个参数时数组的第一项，第二个参数就是数组的第二项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(sum)</span><br></pre></td></tr></table></figure>
<p>reduceRight()方法相较reduce()方法区别在于执行的方向不同。</p>
<h2 id="ES6增强的数组功能"><a href="#ES6增强的数组功能" class="headerlink" title="ES6增强的数组功能"></a>ES6增强的数组功能</h2><h3 id="Array-of-方法"><a href="#Array-of-方法" class="headerlink" title="Array.of()方法"></a>Array.of()方法</h3><p>JS语言中存在一个怪异点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> item = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])     <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">1</span>])     <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">item = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"2"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">item = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])     <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">1</span>])     <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">item = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="string">"2"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])     <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">1</span>])     <span class="comment">//"2"</span></span><br></pre></td></tr></table></figure>

<p>ES6中引用Array.of()方法来解决这个问题，该方法类似 Array 构造器，但在使用多个数值参数的时候不会导致特殊结果。Array.of()方法总会创建一个包含所有出入参数的数组，不管参数的数量和类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> item = <span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length)      <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])          <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">1</span>])          <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> item = <span class="built_in">Array</span>.of(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length)      <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])          <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> item = <span class="built_in">Array</span>.of(<span class="string">"2"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(item.length)      <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(item[<span class="number">0</span>])          <span class="comment">//"2"</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-from-方法"><a href="#Array-from-方法" class="headerlink" title="Array.from()方法"></a>Array.from()方法</h3><p>该方法将类数组对象转化为数组对象,同时，可以向from传入一个映射函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, (value) =&gt; value + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> number = translate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(number)                  <span class="comment">//2,3,4</span></span><br></pre></td></tr></table></figure>
<p>如果映射函数需要在对象上工作，可以手动传递第三个参数给Array.from()方法，从而<strong>指定映射函数内部</strong>的this值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> diff = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> helper = &#123;</span><br><span class="line">    diff: <span class="number">1</span>,</span><br><span class="line">    add(value) &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="keyword">this</span>.diff)</span><br><span class="line">        <span class="keyword">return</span> value + <span class="keyword">this</span>.diff</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.diff = <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, helper.add, helper) <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, helper.add)         <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers = translate(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers)       <span class="comment">//1     2,3,4   2    4,5,6</span></span><br></pre></td></tr></table></figure>
<p>Array.from()方法不仅可以用于类数组对象，也可以用于迭代对象，这意味着该方法可以将任意包含Symbol.iterator属性的对象转换为数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = &#123;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator] () &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers2 = <span class="built_in">Array</span>.from(numbers, (value)=&gt;value+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers2)</span><br></pre></td></tr></table></figure>
<h3 id="数组上的新方法"><a href="#数组上的新方法" class="headerlink" title="数组上的新方法"></a>数组上的新方法</h3><p>find()与findIndex()方法。ES5中增加了indexOf()和lastIndexOf()方法，从而允许开发者在数组中查找特定值，但仍存在限制。<br>find()和findIndex()方法均接受两个参数：一个回调函数、一个可选值用于指定回调函数内部的this。该回调函数可接受三个参数：数组的某个元素、该元素对应的索引位置以及该数组自身，这与map()和forEach()方法的回调函数所用的参数一致。<strong>该回调函数应当在给定的元素满足你定义的条件时返回true</strong>，而find()和findIndex()方法均会在回调函数第一次返回true时停止查找。find()会返回匹配的值，findIndex()会返回匹配位置的索引。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line"><span class="built_in">console</span>.log(numbers.find(<span class="function"><span class="params">n</span>=&gt;</span> n &gt; <span class="number">30</span>))</span><br><span class="line"><span class="built_in">console</span>.log(numbers.findIndex(<span class="function"><span class="params">n</span>=&gt;</span> n &gt; <span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<p><strong>find()与findIndex()方法在查找满足特定条件的数组元素时非常有用。但若想查找特定值，则使用 indexOf() 与 lastIndexOf() 方法会是更好的选择。</strong><br>fill()方法能使用特定值填充数组中的一个或多个元素，当只使用一个参数的时候，该方法会用该参数的值填充整个数组，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers.fill(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())   <span class="comment">//1,1,1,1</span></span><br></pre></td></tr></table></figure>
<p>当只改变部分值时，可设置起始位置和结束位置的参数（不包括结束位置）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers.fill(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())   <span class="comment">//1,2,1,1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers.fill(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())   <span class="comment">//1,1,1,4</span></span><br></pre></td></tr></table></figure>
<p>copyWithin()方法和fill()方法类似，可以一次性修改数组的多个元素。copyWithin()方法允许在数组内部复制自身元素，为此你需要传毒两个参数给copyWithin()方法：从什么位置开始填充，被用来复制的数据的起始位置索引以及终止位置索引</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">numbers.copyWithin()(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())  <span class="comment">//1,2,1,2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">numbers.copyWithin(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString())</span><br></pre></td></tr></table></figure>
<h2 id="类型化数组"><a href="#类型化数组" class="headerlink" title="类型化数组"></a>类型化数组</h2><p>类型化数组是有特殊用途的数组，被设计用来处理数值类型数据（而不像名称暗示的那样，能处理所有类型）。引入类型化数组突破了格式限制并带来了更好的<br>数学运算性能，其设计概念是：单个数值可以被视为由“位”构成的数组，并且可以对其使用与JS 数组现有方法类似的方法。</p>
<h3 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a>数值数据类型</h3><p>JS 数值使用 IEEE 754 标准格式存储，使用64位来存储一个数值的浮点数表示形式，该格式在JS中被同时用来表示整数与浮点数；当值改变时，可能会频繁发生整数与浮点数之间的格式转换。而类型化数组则允许存储并操作八种不同的数值类型：</p>
<ol>
<li>8 位有符号整数（int8）</li>
<li>8 位无符号整数（uint8）</li>
<li>16 位有符号整数（int16）</li>
<li>16 位无符号整数（uint16）</li>
<li>32 位有符号整数（int32）</li>
<li>32 位无符号整数（uint32）</li>
<li>32 位浮点数（float32）</li>
<li>64 位浮点数（float64）<br>所有与类型化数组相关的操作和对象都围绕着这八种数据类型。为了使用它们，你首先需要创建一个数组缓冲区用于存储数据。<h3 id="数组缓冲区"><a href="#数组缓冲区" class="headerlink" title="数组缓冲区"></a>数组缓冲区</h3>数组缓冲区（array buffer）是内存中包含一定数量字节的区域，而所有的类型化数组都基于数组缓冲区。使用ArrayBuffer构造器来创建一个数组缓冲区；调用ArrayBuffer构造器时，只需要传入单个数值用于指定缓冲区包含的字节数。可以通过byteLength属性来获取缓冲区的字节数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(buffer.byteLength)</span><br></pre></td></tr></table></figure>
可以使用slice()方法来创建一个新的、包含已有缓冲区部分的内容数组缓冲区，和数组的slice()方法类似，可以使用起始位置与结束位置参数，返回由原缓冲区元素组成的一个新的ArrayBuffer实例。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> buffer2 = buffer.slice(<span class="number">4</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log((buffer2.byteLength))</span><br></pre></td></tr></table></figure>
<h2 id="使用视图操作数组缓冲区"><a href="#使用视图操作数组缓冲区" class="headerlink" title="使用视图操作数组缓冲区"></a>使用视图操作数组缓冲区</h2>数组缓冲区代表了一块内存区域，而视图（views）则是操作这块区域的接口。视图工作在数组缓冲区或其子集上，可以读写某种数值数据类型的数据。DataView类型时数组缓冲区的通用视图，允许对前述所有8中数值数据类型进行操作。同时可以对数据缓冲区的部分上创建视图，需要提供字节偏移量以及要包含的字节数。<strong>使用这种方式，你可以在同一个数组缓冲区上创建多个不同的视图，这样有助于将单块内存区域供给整个应用使用，而不必每次在有需要时才动态分配内存。</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buffer2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">5</span>,<span class="number">2</span>) <span class="comment">//包含位置5和位置6的字节</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>获取视图信息<br>可以通过查询一下只读属性来获取视图的信息：<br>buffer: 概述图所绑定的数组缓冲区；<br>byteOffset：传给DataView构造器的第二个参数，如果当时提供了的话（默认为0）；<br>byte Length：传给DataView构造器的第三个参数，如果当时提供的话（默认为该缓冲区的byteLength属性）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> view1 = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer)</span><br><span class="line"><span class="keyword">let</span> view2 = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(view1.buffer === buffer)            <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(view2.buffer === buffer)            <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(view1.byteOffset)</span><br><span class="line"><span class="built_in">console</span>.log(view2.byteOffset)</span><br><span class="line"><span class="built_in">console</span>.log(view1.byteLength)</span><br><span class="line"><span class="built_in">console</span>.log(view2.byteLength)</span><br></pre></td></tr></table></figure>

<p>读取和写入数据<br>对应JS所有8种数值数据类型，DataView视图的原型别提供了在数组缓冲区上写入数据的一个方法以及读取数据的一个方法，说有方法名都以“set”或“get”开始，气候跟随这对应数据类型的缩写,例如操作int8或unit8类型的读取/写入方法：<br>“get”方法接受两个参数：开始进行读取的字节偏移量、以及一个可选的布尔值，后者用于指定读取的值是否采用低字节优先方式（注：默认值为 false ）。“set”方法则接受三个参数：开始进行写入的字节偏移量、需要写入的数据值、以及一个可选的布尔值用于指定是否采用低字节优先方式存储数据。<br>**<br>getInt8(byteOffset,littleEndian): 从byteOffset处开始读取一个int8值；<br>setInt8(byteOffset, value, littleEndian): 从byteOffset处开始写入一个int8值；<br>**<br><strong>译注：低字节优先（Little-endian）也被翻译作“小端字节序”，指的是在存储数据的多个内存字节中，第一个内存字节存储着数据的最低字节数据，而最后一个内存字节存储着最高字节数据。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>),</span><br><span class="line">view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">view.setInt8(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">0</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">1</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>视图允许你使用任意格式对任意位置进行读写，而无须考虑这些数据此前是使用什么格式存储的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer)</span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">view.setInt8(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt16(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>在混用不同的数据类型时，使用DataView对象是一种完美方式，不过，若尽享使用特定的一种数据类型，那么特定类型试图会是更好的选择。</p>
<p>类型化数组即为视图</p>
<p>开始时，该数组缓冲区 16 个位均为 0 ；使用 setInt8() 向第一个字节写入 5 之后，该字节的内容就出现了一对 1 （因为 5 可以写为 8 位二进制数 00000101 ）；向第二个字节写入-1 会使得该字节的所有位都变成 1 （即 -1 的二进制补码形式）。接下来使用 getInt16() 就能将前面写入的 16 位数据以单个 16 位整数的方式读取出来，其十进制值就是1535。<br>ES6 的类型化数组实际上也是针对数组缓冲区的特定类型视图，你可以使用这些数组对象来处理特定的数据类型，而不必使用通用的 DataView 对象。一共存在八种特定类型视图，对应着八种数值数据类型，为处理 uint8 值提供了额外的选择。</p>
<p>构造器名称                          元素大小<br>Int8Array                               1<br>Uint8Array                              1<br>Uint8ClampedArray                       1<br>Int16Array                              2<br>Uint16Array                             2<br>Int32Array                              4<br>Uint32Array                             4<br>Float32Array                            4<br>Float64Array                            8<br><strong>类型化数组的构造器可以接受多种类型的参数</strong>，因此存在几种创建类型化数组的方式。<br>第一种方式是使用与创建 DataView 时相同的参数，即：一个数组缓冲区、一个可选的字节偏移量、以及一个可选的字节数量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> view1 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer)</span><br><span class="line"><span class="keyword">let</span> view2 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(view1.buffer === buffer)                    <span class="comment">//true               </span></span><br><span class="line"><span class="built_in">console</span>.log(view2.buffer === buffer)                    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(view1.byteOffset)                           <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(view2.byteOffset)                           <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(view1.byteLength)                           <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(view2.byteLength)                           <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>第二种方法是传递单个数值给类型化数组的构造器，<strong>此数值表示该数组包含的元素数量（而不是分配的字节数）</strong>。构造器会创建一个新的缓冲区，分配正确的字节数以便容纳指定数量的数组元素。可以通过length属性来获取这个元素数量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> floats = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ints.byteLength)</span><br><span class="line"><span class="built_in">console</span>.log(ints.length)</span><br><span class="line"><span class="built_in">console</span>.log(floats.byteLength)</span><br><span class="line"><span class="built_in">console</span>.log(floats.length)</span><br></pre></td></tr></table></figure>
<p><strong>如果调用类型化数组构造器时没有传入参数，构造器会认为传入了 0 ，这种方式创建的类型化数组不会被分配任何存储空间，因此也就不能被用于保存数据。</strong><br>第三种方式是向构造器传递单个对象参数<br><strong>类型化数组</strong>：数组所有元素都会被复制到新的类型化数组中。例如，如果你传递一个 int8类型的数组给 Int16Array 构造器，这些 int8 的值会被复制到 int16 数组中。新的类型化数组与原先的类型化数组会使用不同的数组缓冲区。<br><strong>可迭代对象</strong>：该对象的迭代器会被调用以便将数据插入到类型化数组中。如果其中包含了不匹配视图类型的值，那么构造器就会抛出错误。<br><strong>数组</strong>：该数组的元素会被插入到新的类型化数组中。如果其中包含了不匹配视图类型的值，那么构造器就会抛出错误。<br><strong>类数组对象</strong>：与传入数组的表现一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints1 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</span><br><span class="line">ints2 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(ints1);</span><br><span class="line"><span class="built_in">console</span>.log(ints1.buffer === ints2.buffer); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1.byteLength); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1[<span class="number">1</span>]); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2.byteLength); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2[<span class="number">1</span>]); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<h3 id="类型化数组与常规数组的相似点"><a href="#类型化数组与常规数组的相似点" class="headerlink" title="类型化数组与常规数组的相似点"></a>类型化数组与常规数组的相似点</h3><p>类型化数组与常规数组有好几个相似点，类型化数组在很多场景中都可以像常规数组那样被使用。例如，你可以使用length属性来获取类型化数组包含的元素数量，还可以使用数值类型的索引值来直接访问类型化数组的元素。<br><strong>与常规数组不同的是，你不能使用 length 属性来改变类型化数组的大小。该属性是不可写的，在非严格模式下写入操作会被忽略，而严格模式下则会抛出错误。</strong><br>类型化数组也拥有大量与常规数组等效的方法，你可以对类型化数组使用下列这些方法：<br>copyWithin()、entries()、fill()、filter()、find()、findIndex()、forEach()、indexOf()、join()、keys()、lastIndexOf()、map()、reduce()、reduceRight()、reverse()、slice()、some()、sort()、values()<br><strong>注意</strong>虽然这些方法的表现与数组原型上的对应方法相似，但它们并不完全相同。类型化数组的方法会进行额外的类型检查以确保安全，并且返回值会是某种类型化数组，而不是常规数组（归结于 Symbol.species 属性）。这里有个例子用于演示其中的区别：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</span><br><span class="line">mapped = ints.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mapped.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped[<span class="number">0</span>]); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped[<span class="number">1</span>]); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>**相同的迭代器<br>与常规数组相同，类型化数组也拥有三个迭代器，它们是 entries() 方法、 keys() 方法与values() 方法。这就意味着你可以对类型化数组使用扩展运算符，或者对其使用for-of 循环，就像对待常规数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</span><br><span class="line">intsArray = [...ints];</span><br><span class="line"><span class="built_in">console</span>.log(intsArray <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(intsArray[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(intsArray[<span class="number">1</span>]); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>of()和from()方法<br>所有的类型化数组都包含静态的 of() 与 from() 方法，作用类似于 Array.of() 与Array.from() 方法。其中的区别是类型化数组的版本会返回类型化数组，而不返回常规数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="built_in">Int16Array</span>.of(<span class="number">25</span>, <span class="number">50</span>),</span><br><span class="line">floats = <span class="built_in">Float32Array</span>.from([<span class="number">1.5</span>, <span class="number">2.5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(floats <span class="keyword">instanceof</span> <span class="built_in">Float32Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(ints.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(floats.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(floats[<span class="number">0</span>]); <span class="comment">// 1.5</span></span><br><span class="line"><span class="built_in">console</span>.log(floats[<span class="number">1</span>]); <span class="comment">// 2.5</span></span><br></pre></td></tr></table></figure>
<p>类型化数组与常规数组的区别</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(ints)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>行为差异<br>**常规数组可以被伸展或是收缩，然而类型化数组却会始终保持自身大小不变。你可以对常规数组一个不存在的索引位置进行赋值，但在类型化数组上这么做则会被忽略。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]); <span class="comment">// 50</span></span><br><span class="line">ints[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ints.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>类型化数组也会对数据类型进行检查以保证只使用有效的值，当无效的值被传入时，将会被替换为0</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="string">"hi"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(ints.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>所有在类型化数组上修改项目值的方法都会受到相同的限制，例如当 map() 方法使用的映射函数返回一个无效值的时候，类型化数组会使用 0 来代替返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</span><br><span class="line">mapped = ints.map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mapped.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped[<span class="number">0</span>]); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped[<span class="number">1</span>]); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>尽管类型化数组拥有常规数组的很多同名方法，但仍然缺少了几个数组方法，包括下列这些：<br>concat()、pop()、push()、shift()、splice()、unshift()<br>除了 concat() 方法之外，该列表中的其余方法都会改变数组的大小，而由于类型化数组的大小不可变，因此这些方法都不能作用于类型化数组。 concat() 方法不可用的原因则是：连接两个类型化数组的结果是不确定的（特别是当它们处理的数据类型不同时），这种不确定情况原本就不应当使用类型化数组。</p>
<p>**附加的方法<br>类型化数组还有两个常规数组所不具备的方法： set() 方法与 subarray() 方法。这两个方法作用相反： set() 方法从另一个数组中复制元素到当前的类型化数组，而subarray() 方法则是将当前类型化数组的一部分提取为新的类型化数组。<br>set() 方法接受一个数组参数（无论是类型化的还是常规的）、以及一个可选的偏移量参数，后者指示了从什么位置开始插入数据（默认值为 0 ）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">4</span>);</span><br><span class="line">ints.set([<span class="number">25</span>, <span class="number">50</span>]);</span><br><span class="line">ints.set([<span class="number">75</span>, <span class="number">100</span>], <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ints.toString()); <span class="comment">// 25,50,75,100</span></span><br></pre></td></tr></table></figure>
<p>subarray() 方法接受一个可选的开始位置索引参数、以及一个可选的结束位置索引参数（像slice() 方法一样，结束位置的元素不会被包含在结果中），并会返回一个新的类型化数组。你可以同时省略这两个参数，从而创建原类型化数组的一个复制品。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]),</span><br><span class="line">subints1 = ints.subarray(),</span><br><span class="line">subints2 = ints.subarray(<span class="number">2</span>),</span><br><span class="line">subints3 = ints.subarray(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(subints1.toString()); <span class="comment">// 25,50,75,100</span></span><br><span class="line"><span class="built_in">console</span>.log(subints2.toString()); <span class="comment">// 75,100</span></span><br><span class="line"><span class="built_in">console</span>.log(subints3.toString()); <span class="comment">// 50,75</span></span><br></pre></td></tr></table></figure>



<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="attr"></p>
<p>上图中展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系，由于所有实现中都无法访问到[[Prototype]]，因此可以通过isPrototypeOf()确定对象对象间是否存在这种关系，如下所示：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/Iversoncurry.github.io/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/Iversoncurry.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/Iversoncurry.github.io/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">蚂蚁</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Iversoncurry.github.io/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蚂蚁</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Iversoncurry.github.io/lib/anime.min.js"></script>
  <script src="/Iversoncurry.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/Iversoncurry.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/Iversoncurry.github.io/js/utils.js"></script>

<script src="/Iversoncurry.github.io/js/motion.js"></script>


<script src="/Iversoncurry.github.io/js/schemes/pisces.js"></script>


<script src="/Iversoncurry.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
